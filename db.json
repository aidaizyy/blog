{"meta":{"version":1,"warehouse":"1.0.2"},"models":{"Asset":[{"_id":"source/robots.txt","path":"robots.txt","modified":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0},{"_id":"themes/landscape-plus/source/js/script.js","path":"js/script.js","modified":0},{"_id":"themes/landscape-plus/source/img/scrollup.png","path":"img/scrollup.png","modified":0},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0},{"_id":"themes/landscape-plus/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0},{"_id":"themes/landscape-plus/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0},{"_id":"themes/landscape-plus/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0},{"_id":"themes/landscape-plus/source/css/style.styl","path":"css/style.styl","modified":0},{"_id":"themes/landscape-plus/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0},{"_id":"themes/landscape-plus/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0},{"_id":"themes/landscape-plus/source/css/bdshare.styl","path":"css/bdshare.styl","modified":0},{"_id":"source/CNAME","path":"CNAME","modified":0}],"Cache":[{"_id":"source/CNAME","shasum":"f9a607335f7be25feebddb51024d8b6b1b400b68","modified":1430214617000},{"_id":"source/404.html","shasum":"3cb1b23ff4b4b734408dc6f1670046f782a4fc00","modified":1436782474000},{"_id":"source/_posts/android_proguard.md","shasum":"921444992a53b2c347a19794fc7155182a0229f3","modified":1436783768000},{"_id":"source/_posts/dpdk.md","shasum":"73fac3929eb6602d0a3dac12e90d81c70c62cac4","modified":1436782132000},{"_id":"source/_posts/dpdk_l2fwd.md","shasum":"4c1acc40b8ab46845763236876e3fad90684547f","modified":1436784494000},{"_id":"source/_posts/swift_2.md","shasum":"048ea3523f8dc58d8fb4250f80fbff4c6827f062","modified":1436951824000},{"_id":"source/_posts/swift_1.md","shasum":"c62558d801a092ee95b9941e5fd7c28909a927c7","modified":1436948447000},{"_id":"source/_posts/swift_3.md","shasum":"0cb8591f637a8823a09712696e18826bab9e5d39","modified":1437468640000},{"_id":"source/_posts/swift_7.md","shasum":"f4fc4950ed511699b2fecb2d2db382d44ce301ec","modified":1437620100000},{"_id":"source/_posts/swift_4.md","shasum":"f7729da23039c4788339168f41799660fed019f0","modified":1437468720000},{"_id":"source/_posts/swift_5.md","shasum":"0a893e2a9a5b87d8eb65bcbd25445a8fb4c3fe04","modified":1437578101000},{"_id":"source/_posts/swift_6.md","shasum":"2d69813891ef501596cbc3eb9a716921c20dbcd1","modified":1437578295000},{"_id":"source/_posts/swift_8.md","shasum":"fc0ad9698c16910d4f497cd01417346757617cf5","modified":1437578670000},{"_id":"source/robots.txt","shasum":"4b51c1160118132f8dd0f20d783fc45f40871a32","modified":1430486746000},{"_id":"source/about/index.md","shasum":"b286980879c3c62c33dcd4fd7ab60695a599f16b","modified":1437467822000},{"_id":"source/favicon.ico","shasum":"7678474d9b5b54af16295a6b6c0dbe9c3ecd07fc","modified":1430475428000},{"_id":"themes/landscape-plus/LICENSE","shasum":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1430473844000},{"_id":"themes/landscape-plus/Gruntfile.js","shasum":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1430473844000},{"_id":"themes/landscape-plus/_config.yml","shasum":"f29aca64da2a00abaf214a98f7a37caec5f18e0c","modified":1437581886000},{"_id":"themes/landscape-plus/README.md","shasum":"04a1227d8fc5a019884fe7f2149d8a3ac9f1a689","modified":1430473844000},{"_id":"themes/landscape-plus/languages/default.yml","shasum":"06f4e3aaa695b5d5a8fb7087e66fdab9749d2527","modified":1430493999000},{"_id":"themes/landscape-plus/languages/zh-CN.yml","shasum":"c7f273107b09217fa10f3e1dd9f4c3e9aae660f2","modified":1430493975000},{"_id":"themes/landscape-plus/layout/_partial/after-footer.ejs","shasum":"e5ce4e4c493c6e022ad53d199c3507551cccf918","modified":1437375749000},{"_id":"themes/landscape-plus/layout/_partial/archive-post.ejs","shasum":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/article.ejs","shasum":"011291497daeda65916240eabf5e9eea5a644e2c","modified":1430489727000},{"_id":"themes/landscape-plus/layout/_partial/archive.ejs","shasum":"d7de6421497ffaf65e4f5fe4bed71fcea51fde80","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/footer.ejs","shasum":"78d29e0a625e21ebc05d7ec28029c2246001cf71","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/google-analytics.ejs","shasum":"78823298e9e47d8e6556fc2bb4598fc2814f2d52","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/mathjax.ejs","shasum":"7b3d1a8d27ea674c373022a8f95898b5f1bf4a33","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/head.ejs","shasum":"93eb99cadcece8c1428d8287e3a508fb434f7fb3","modified":1437580671000},{"_id":"themes/landscape-plus/layout/_partial/header.ejs","shasum":"0a1d3b2ddf20eae3ed0fbf6520a1bc45125744bd","modified":1437451981000},{"_id":"themes/landscape-plus/layout/_partial/post/category.ejs","shasum":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/mobile-nav.ejs","shasum":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/post/gallery.ejs","shasum":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/post/date.ejs","shasum":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/post/nav.ejs","shasum":"16a904de7bceccbb36b4267565f2215704db2880","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/post/tag.ejs","shasum":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/post/title.ejs","shasum":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/sidebar.ejs","shasum":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/search.ejs","shasum":"7323e76f36cec85af6c85bba68d0a7d74c39b277","modified":1430555458000},{"_id":"themes/landscape-plus/layout/_partial/totop.ejs","shasum":"aa3a3eadf31d9b3e4d3081cd3ca61860e55ef553","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_widget/archive.ejs","shasum":"bbb86beab343e08e689a372ddb60bfa782e93bc4","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_widget/category.ejs","shasum":"ae96217d072f637925c907f5f467450083863f50","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_widget/links.ejs","shasum":"231e8caa63e8ab4c12215915e8fa66541a666dab","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_widget/recent_posts.ejs","shasum":"bb4b99b49fb0b647f6c9d8ebb06fc94bbca6b7f7","modified":1437530264000},{"_id":"themes/landscape-plus/layout/_widget/tag.ejs","shasum":"b461390feb5ef82df7aef9677a31d5137c352f61","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_widget/weibo.ejs","shasum":"6d8b422e8b2cb4bcd1505ee95db42d17de5cb0e8","modified":1430490483000},{"_id":"themes/landscape-plus/layout/_widget/tagcloud.ejs","shasum":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1430473844000},{"_id":"themes/landscape-plus/layout/archive.ejs","shasum":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1430473844000},{"_id":"themes/landscape-plus/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1430473844000},{"_id":"themes/landscape-plus/layout/category.ejs","shasum":"765426a9c8236828dc34759e604cc2c52292835a","modified":1430473844000},{"_id":"themes/landscape-plus/layout/layout.ejs","shasum":"3626a74826657529bea744fb014dd9607e9834d0","modified":1430473844000},{"_id":"themes/landscape-plus/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1430473844000},{"_id":"themes/landscape-plus/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1430473844000},{"_id":"themes/landscape-plus/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1430473844000},{"_id":"themes/landscape-plus/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1430473844000},{"_id":"themes/landscape-plus/package.json","shasum":"b2bc52ea54ee3e5798de96d8f16f55b74af1ab4b","modified":1430475178000},{"_id":"themes/landscape-plus/source/css/_partial/archive.styl","shasum":"19b5af4e0969d93fb757577bd6ff380ef2224eb9","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_extend.styl","shasum":"3f8a9e4e63b7249408ac54559a5f9633d703e132","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_partial/comment.styl","shasum":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_partial/article.styl","shasum":"d7869c19e796c4a59042665576af13fd0c5ba90f","modified":1430489697000},{"_id":"themes/landscape-plus/source/css/_partial/header.styl","shasum":"f8d63b45dcfb9ab343199d6774db9875623f311a","modified":1437365562000},{"_id":"themes/landscape-plus/source/css/_partial/footer.styl","shasum":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_partial/highlight.styl","shasum":"a3c2f696d9477223bd45b49e5f996d7998ae52e5","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_partial/mobile.styl","shasum":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1430651020000},{"_id":"themes/landscape-plus/source/css/_partial/sidebar-aside.styl","shasum":"c9ea5b3956b73418dc8b1572e32eb65dc68ca0e5","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_partial/sidebar-bottom.styl","shasum":"bc5487b9a0bfe5f745423331824d3f3637ccd430","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_partial/sidebar.styl","shasum":"b7bdc11effa98c6d88850eff75634e2ea9207c14","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_partial/totop.styl","shasum":"817f36dd591d6beef9d41011ae8490d31d5e2e50","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_util/grid.styl","shasum":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_util/mixin.styl","shasum":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/bdshare.styl","shasum":"efb757d9aa21c35f75601dec49533d81b2d9fd08","modified":1437375846000},{"_id":"themes/landscape-plus/source/css/_variables.styl","shasum":"7d8a3ff6f9864a0aee94b41db1f0f49e6fd7345d","modified":1430474355000},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.eot","shasum":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.woff","shasum":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/style.styl","shasum":"30fdb982f5324d0023f38c28e83238b9518f2756","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1430473844000},{"_id":"themes/landscape-plus/source/img/scrollup.png","shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1430473844000},{"_id":"themes/landscape-plus/source/js/script.js","shasum":"f3bc4ff3fb41918a6b58f9b86bf4249ecc6bbb0c","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/fonts/FontAwesome.otf","shasum":"6270a4a561a69fef5f5cc18cdf9efc256ec2ccbe","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.ttf","shasum":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.svg","shasum":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/images/banner.jpg","shasum":"28bde0491ed558215efe7d4c6f5a9e73ea397ccd","modified":1430651894000},{"_id":"public/robots.txt","modified":1437619782102,"shasum":"4b51c1160118132f8dd0f20d783fc45f40871a32"},{"_id":"public/favicon.ico","modified":1437619782106,"shasum":"7678474d9b5b54af16295a6b6c0dbe9c3ecd07fc"},{"_id":"public/js/script.js","modified":1437619782109,"shasum":"f3bc4ff3fb41918a6b58f9b86bf4249ecc6bbb0c"},{"_id":"public/img/scrollup.png","modified":1437619782111,"shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1437619782112,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1437619782115,"shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1437619782120,"shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1437619782121,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1437619782126,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1437619782128,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1437619782130,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1437619782131,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1437619782132,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1437619782134,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1437619782135,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1437619782137,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1437619782139,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1437619782147,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1437619782150,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1437619782788,"shasum":"70ac490e248ac515ed036ed5c0355b7ab9001f4b"},{"_id":"public/css/images/banner.jpg","modified":1437619782998,"shasum":"28bde0491ed558215efe7d4c6f5a9e73ea397ccd"},{"_id":"public/css/fonts/fontawesome-webfont.woff","modified":1437619783001,"shasum":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c"},{"_id":"public/css/fonts/fontawesome-webfont.ttf","modified":1437619783003,"shasum":"6225ccc4ec94d060f19efab97ca42d842845b949"},{"_id":"public/css/fonts/fontawesome-webfont.svg","modified":1437619783005,"shasum":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9"},{"_id":"public/css/fonts/fontawesome-webfont.eot","modified":1437619783007,"shasum":"0183979056f0b87616cd99d5c54a48f3b771eee6"},{"_id":"public/css/fonts/FontAwesome.otf","modified":1437619783009,"shasum":"6270a4a561a69fef5f5cc18cdf9efc256ec2ccbe"},{"_id":"public/css/bdshare.css","modified":1437619783097,"shasum":"382b2417dc7aa054bb796e084f38fcd2f7c9a15f"},{"_id":"public/CNAME","modified":1437619783147,"shasum":"f9a607335f7be25feebddb51024d8b6b1b400b68"},{"_id":"public/404.html","modified":1437619783168,"shasum":"d1af91416e220b2d038f28210b14b6b8cb855099"},{"_id":"public/about/index.html","modified":1437623952931,"shasum":"7092e8431b863771626ddf66679eb6902349036d"},{"_id":"public/swift_8/index.html","modified":1437623952989,"shasum":"e83c9f6cd8f72897caedbd3902946b5edca8407c"},{"_id":"public/swift_7/index.html","modified":1437623953016,"shasum":"305bbcd2e3ee08c10ffcb0dbfe1c8b44963acaab"},{"_id":"public/swift_6/index.html","modified":1437623953033,"shasum":"b8b16cde9675f9fb9f1cef1f528b2ae9aa3e3f3b"},{"_id":"public/swift_5/index.html","modified":1437623953055,"shasum":"5e4bc091ae2173b0f654185ddec06ccfdb830190"},{"_id":"public/swift_4/index.html","modified":1437623953079,"shasum":"6ee9d8195bacee846a0a3358c8f7e3d169f7f885"},{"_id":"public/swift_3/index.html","modified":1437623953099,"shasum":"48dffe3b0baacbf2ac23ae61fcded215b79a56ea"},{"_id":"public/swift_2/index.html","modified":1437623953112,"shasum":"9e4352ee14b78cb1f6beb3e41502083505018cb6"},{"_id":"public/swift_1/index.html","modified":1437623953136,"shasum":"bcd851b9cd7aeff042ac5646ace67ebd476cd9d1"},{"_id":"public/android_proguard/index.html","modified":1437623953151,"shasum":"961f4024c605879731e61c67aca81b570691fc1b"},{"_id":"public/dpdk/index.html","modified":1437623953176,"shasum":"d5c19891525ece91640b138ab14c9a3d0d5d2618"},{"_id":"public/dpdk_l2fwd/index.html","modified":1437623953201,"shasum":"70b8a7fede062c80123db3711aa209281147f6b2"},{"_id":"public/archives/index.html","modified":1437619783501,"shasum":"05b593328c54411ca973f571da573c23ead9e1f9"},{"_id":"public/archives/page/2/index.html","modified":1437619783506,"shasum":"7189559b7b15ebdaa4d89b3e679e899765f2b63f"},{"_id":"public/archives/2015/index.html","modified":1437619783532,"shasum":"af0cda4a221dc4735ecefcc63ebae0608f54e26e"},{"_id":"public/archives/2015/page/2/index.html","modified":1437619783542,"shasum":"0490f3cfe609979fc1ddb43d3f1f6ec147429a1b"},{"_id":"public/archives/2015/03/index.html","modified":1437619783549,"shasum":"b8d63a1f54485f97b2302b08f99ceb8f25c62425"},{"_id":"public/archives/2015/04/index.html","modified":1437619783556,"shasum":"2855a29127d65eb1595c8c59b25bc71b6a30fc73"},{"_id":"public/archives/2015/07/index.html","modified":1437619783579,"shasum":"598b2f8be16576a80d8280d4b3d6e39180dac71b"},{"_id":"public/categories/swift/index.html","modified":1437619783598,"shasum":"c79dc44c16fc731f98d64d0dec80ebef40d22dc4"},{"_id":"public/categories/dpdk/index.html","modified":1437619783607,"shasum":"50210dc61dec9a909a49f3037114824892714bf7"},{"_id":"public/categories/android/index.html","modified":1437619783615,"shasum":"a28fcb331c5b6bb277022918a3c9bf7e8a6ce59e"},{"_id":"public/atom.xml","modified":1437623953329,"shasum":"871682d16ab4941e7b669d743e13db72342dc5ae"},{"_id":"public/index.html","modified":1437619783659,"shasum":"9c0665bfb967bf98782dc99207a254d512b8855e"},{"_id":"public/page/2/index.html","modified":1437619783669,"shasum":"a3544f1929e63f38609e6118cf53e02c06e47f27"},{"_id":"public/sitemap.xml","modified":1437620104930,"shasum":"7552ff5c2d936c813a1e421daac096ea9bd9ab1a"},{"_id":"public/tags/swift/index.html","modified":1437619783697,"shasum":"c8de9458d7f762b5e4814ae604682a0033780782"},{"_id":"public/tags/dpdk/index.html","modified":1437619783711,"shasum":"a27efdfa5d2316ac5f5fe50a5281a7b5afd2af64"},{"_id":"public/tags/android/index.html","modified":1437619783719,"shasum":"47b3edf83daab7bb7d9ccae94cbe0b4b91900721"},{"_id":"public/tags/proguard/index.html","modified":1437619783730,"shasum":"c4b8db850e4b50244c0499af944392748f3fedb6"}],"Category":[{"name":"swift","_id":"cicflp6iw0003r2o3tovushb3"},{"name":"dpdk","_id":"cicflp6jl000sr2o3q8362x2u"},{"name":"android","_id":"cicflp6jr0010r2o3kjwl90kf"}],"Data":[],"Page":[{"yout":false,"_content":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n    <title>404</title>\n    <link rel=\"icon\" href=\"/favicon.ico\">\n  </head>\n  <body>\n    <div align=\"center\">\n      <p>出错啦~！</p>\n      <p>邮箱联系: aidaizyy@gmail.com</p>\n    </div>\n  </body>\n</html>\n","source":"404.html","raw":"yout: false\n--------\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n    <title>404</title>\n    <link rel=\"icon\" href=\"/favicon.ico\">\n  </head>\n  <body>\n    <div align=\"center\">\n      <p>出错啦~！</p>\n      <p>邮箱联系: aidaizyy@gmail.com</p>\n    </div>\n  </body>\n</html>\n","date":"2015-07-13T10:14:34.000Z","updated":"2015-07-13T10:14:34.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cicflp6ho0000r2o3ph84lkbo"},{"title":"About Me","toc":false,"_content":"\n[Yunyao Zhang（张云尧）](http://aidaiz.com)\n\nBirthday: December 25, 1992\n\nEmail Address: <aidaizyy@gmail.com>\n\nResearch Area: Computer Architecture & High Performance Computer\n\nLaboratory: [High Performance Computer Research Center](http://www.ncic.ac.cn)\n\nEducation: \n- [Insitute of Computing Technology](http://www.ict.ac.cn), [University of Chinese Academy of Sciences](http://www.ucas.ac.cn), since 2015 \n\n- [College of Software Engineering](http://sw.scu.edu.cn), [Sichuan University](http://www.scu.edu.cn), 2011 - 2015\n\n- [Mianzhu High School](http://www.scmzzx.com), Sichuan Province, 2008 - 2011\n\nWeibo: [@张云尧](http://weibo.com/aidaiz)\n\nGithub: [aidaizyy](https:///github.com/aidaizyy)\n\n![](http://7xivk7.com1.z0.glb.clouddn.com/about.jpg-about)\n","source":"about/index.md","raw":"title: About Me\ntoc: false\n---\n\n[Yunyao Zhang（张云尧）](http://aidaiz.com)\n\nBirthday: December 25, 1992\n\nEmail Address: <aidaizyy@gmail.com>\n\nResearch Area: Computer Architecture & High Performance Computer\n\nLaboratory: [High Performance Computer Research Center](http://www.ncic.ac.cn)\n\nEducation: \n- [Insitute of Computing Technology](http://www.ict.ac.cn), [University of Chinese Academy of Sciences](http://www.ucas.ac.cn), since 2015 \n\n- [College of Software Engineering](http://sw.scu.edu.cn), [Sichuan University](http://www.scu.edu.cn), 2011 - 2015\n\n- [Mianzhu High School](http://www.scmzzx.com), Sichuan Province, 2008 - 2011\n\nWeibo: [@张云尧](http://weibo.com/aidaiz)\n\nGithub: [aidaizyy](https:///github.com/aidaizyy)\n\n![](http://7xivk7.com1.z0.glb.clouddn.com/about.jpg-about)\n","date":"2015-07-21T08:37:02.000Z","updated":"2015-07-21T08:37:02.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cicflp6id0001r2o3zgyznqw9"}],"Post":[{"title":"Swift基础入门(8)：继承，构造过程和析构过程","date":"2015-07-21T09:17:02.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：类的继承；枚举，结构体和类的构造过程和析构过程。\n\n<!--more-->\n**Title: [Swift基础入门(8)：继承，构造过程和析构过程](https://aidaizyy.github.io/swift_8)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-22](http://aidaizyy.github.io)**\n\n# 继承\n\n## 基本语法\n子类（_subclass_）继承（_inherit_）继承超类/父类（_superclass_）的属性，方法，下标脚本和其他特性。\n声明子类时，将超类名写在子类名的后面，用冒号分割：\n``` swift\nclass Vehicle {\n    var currentSpeed = 0.0\n    var description: String {\n        return \"traveling at \\(currentSpeed) miles per hour\"\n    }\n    func makeNoise() {\n        // 什么也不做-因为车辆不一定会有噪音\n    }\n}\n\nclass Bicycle: Vehicle {\n    var hasBasket = false\n}\n\nclass Tandem: Bicycle {\n    var currentNumberOfPassengers = 0\n}\n\nlet tandem = Tandem()\ntandem.hasBasket = true\ntandem.currentNumberOfPassengers = 2\ntandem.currentSpeed = 22.0\nprintln(\"Tandem: \\(tandem.description)\")\n// Tandem: traveling at 22.0 miles per hour\n```\n\n## 重写\n重写（_overriding_）指子类把父类的实例方法，类方法，实例属性和下表脚本等提供自己定制的实现。\n在重写定义的前面加上关键字`override`。\n使用`super`前缀可以访问超类的属性，方法和下表脚本。\n\n### 重写方法\n``` swift\nclass Train: Vehicle {\n    override func makeNoise() {\n        println(\"Choo Choo\")\n    }\n}\n\nclass Car: Vehicle {\n    var gear = 1\n    override var description: String {\n        return super.description + \" in gear \\(gear)\"\n    }\n}\n\nlet train = Train()\ntrain.makeNoise()\n// prints \"Choo Choo\"\n```\n\n### 重写属性\n- 超类的只读属性在子类中可以重写为读写属性，但是读写属性不能重写为只读属性。\n- 超类的重写属性在子类中必须完整实现setter和getter，可以用`super.someProperty`返回超类的getter。\n``` swift\nclass Car: Vehicle {\n    var gear = 1\n    override var description: String {\n        return super.description + \" in gear \\(gear)\"\n    }\n}\n\nlet car = Car()\ncar.currentSpeed = 25.0\ncar.gear = 3\nprintln(\"Car: \\(car.description)\")\n// Car: traveling at 25.0 miles per hour in gear 3\n```\n\n### 重写属性观察器\nsetter和属性观察器不能同时存在，setter中可以观察到值的变化。\n``` swift\nclass AutomaticCar: Car {\n    override var currentSpeed: Double {\n        didSet {\n            gear = Int(currentSpeed / 10.0) + 1\n        }\n    }\n}\n\nlet automatic = AutomaticCar()\nautomatic.currentSpeed = 35.0\nprintln(\"AutomaticCar: \\(automatic.description)\")\n// AutomaticCar: traveling at 35.0 miles per hour in gear 4\n```\n\n## 防止重写\n属性，方法和下标脚本前面加上`final`关键字可以防止它们被重写。\n`final var`，`final func`，`final class func`，`final subscript`。\n\n# 构造过程\n构造过程（_Inititalization_）为实例的每个属性设置初始值和为其执行必要的准备和初始化任务。\n\n## 构造器\n### 属性默认值\n属性声明时，可以为其设置默认值。\n``` swift\nstruct Fahrenheit {\n    var temperature = 32.0\n}\n\nvar f = Fahrenheit()\nprintln(\"The default temperature is \\(f.temperature)° Fahrenheit\")\n// 输出 \"The default temperature is 32.0° Fahrenheit”\n```\n构造器，也可以为属性赋初始值，关键字`init`。\n``` swift\nstruct Fahrenheit {\n    var temperature: Double\n    init() {\n        temperature = 32.0\n    }\n}\n\nvar f = Fahrenheit()\nprintln(\"The default temperature is \\(f.temperature)° Fahrenheit\")\n// 输出 \"The default temperature is 32.0° Fahrenheit”\n```\n\n### 构造器参数\n构造器可以传入参数。\n传入参数默认具有和内部参数名一致的外部参数名，相当于默认在参数名前加上了`#`。\n用`_`替代外部参数名，可以取消默认的外部参数名。\n``` swift\nstruct Color {\n    let red, green, blue: Double\n    init(red: Double, g green: Double, _ blue: Double) {\n        self.red   = red\n        self.green = green\n        self.blue  = blue\n    }\n    init(white: Double) {\n        red   = white\n        green = white\n        blue  = white\n    }\n}\n\nlet magenta = Color(red: 1.0, g: 0.0, 1.0)\nlet halfGray = Color(white: 0.5)\n```\n\n### 可选类型属性\n如果属性为可选类型，构造器自动初始化为`nil`。\n\n### 常量属性\n构造器中可以修改常量`let`属性的值，在构造过程中结束后，常量的值不能被修改。\n\n### 默认构造器\n所有属性已提供默认值且没有定义构造器的结构体或基类，具有一个默认的构造器，把默认值赋值给属性作为初始值。\n\n前面讲过，结构体的逐一成员构造器，算是一个默认的构造器。\n``` swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nlet twoByTwo = Size(width: 2.0, height: 2.0)\n```\n这里`Size`获得了一个逐一成员构造器`init(width: height: )`。\n\n## 值类型的构造器代理\n构造器可以通过调用其他构造器来完成构造过程，称为构造器代理。\n值类型比较简单，只能调用本身提供的其他构造器，而类可以继承构造器。\n``` swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Point {\n    var x = 0.0, y = 0.0\n}\n\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    init() {}\n    init(origin: Point, size: Size) {\n        self.origin = origin\n        self.size = size\n    }\n    init(center: Point, size: Size) {\n        let originX = center.x - (size.width / 2)\n        let originY = center.y - (size.height / 2)\n        self.init(origin: Point(x: originX, y: originY), size: size)\n    }\n}\n```\n结构体`Rect`中实现了三个构造器。\n第一个构造器功能和默认构造器类似，把默认值赋值给属性。\n第二个构造器功能和逐一成员构造器类似，逐一把值赋值给属性。\n第三个构造器调用了第二个构造器，完成了部分构造过程。\n\n## 类的构造器代理\n\n### 指定构造器和便利构造器\n类类型的构造器要确保所有存储型属性获得初始值，包括继承来的属性，分为指定构造器和便利构造器。\n- 指定构造器\n主要的类构造器，根据父类链依次往上调用父类的构造器，每个类都必须拥有至少一个指定构造器。\n写法和值类型的构造器一样：\n``` swift\ninit(parameters) {\n    statements\n}\n```\n- 便利构造器\n次要的类构造器，调用同一个类中的指定构造器，也可以创建一个特殊用途或特定输入的实例，只在必要时提供便利构造器。\n写法和值类型的构造器也基本一样，在`init`前加上`convenience`关键字：\n``` swift\nconvenience init(parameters) {\n    statements\n}\n```\n\n+ 指定构造器必须调用其直接父类的指定构造器。\n+ 便利构造器必须调用同一类中定义的其他构器。\n+ 便利构造器必须最终以调用一个指定构造器结束。\n\n也就是说：\n- 指定构造器必须总是向上代理\n- 便利构造器必须总是横向代理\n\n### 构造器继承和重写\n重写（_Override_）指定构造器，在子类中重写实现并调用父类构造器。\n重写便利构造器，必须通过调用同一类提供的其他指定构造器来实现。\n\n子类不会默认继承父类的构造器。\n如果特定条件满足，父类构造器也会被自动继承：\n- 子类的任意新属性都有默认值，且没有定义任何指定构造器，它将自动继承所有父类的指定构造器。\n- 子类提供了所有父类指定构造器的实现，它将自动继承所有父类的便利构造器。\n\n### 构造过程\n构造过程分为两个阶段。\n第一个阶段：\n沿着构造器链先初始化子类的属性，再代理给父类构造器，初始化父类的属性。\n当到达构造器链最顶部时，所有的存储型属性都已经赋值。\n这个阶段不能调用任何实例方法，不能读取任何实例属性的值，不能引用`self`的值。\n\n第二个阶段：\n沿着构造器链沿相反方向，从顶部向下，进一步定制实例，可以为任意属性赋新值。\n这个阶段可以调用实例方法，修改实例属性，并访问`self`。\n\n### 实例\n``` swift\nclass Food {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n    convenience init() {\n        self.init(name: \"[Unnamed]\")\n    }\n}\n\nlet namedMeat = Food(name: \"Bacon\")\n// namedMeat 的名字是 \"Bacon”\n\nlet mysteryMeat = Food()\n// mysteryMeat 的名字是 [Unnamed]\n```\n类`Food`提供了一个指定构造器`init(name: String)`和一个便利构造器`init()`。\n第11行：指定构造器，初始化属性`name`，因为`Food`没有父类，所以结束构造过程。\n第14行：便利构造器，调用了同一个类的指定构造器并给参数`name`传入值`[Unnamed]`。\n``` swift\nclass RecipeIngredient: Food {\n    var quantity: Int\n    init(name: String, quantity: Int) {\n        self.quantity = quantity\n        super.init(name: name)\n    }\n    override convenience init(name: String) {\n        self.init(name: name, quantity: 1)\n    }\n}\n\nlet sixEggs = RecipeIngredient(name: \"Eggs\", quantity: 6)\nlet oneBacon = RecipeIngredient(name: \"Bacon\")\nlet oneMysteryItem = RecipeIngredient()\n```\n类`RecipeIngredient`继承类`Food`，提供了一个指定构造器`init(name: String, quantity: Int)`和一个便利构造器`init(name: String)。\n第12行：指定构造器，先初始化子类的属性`quantity`，再代理给父类`Food`的`init(name: String)`。\n第13行：便利构造器，调用了同一个类的指定构造器并给参数`name`和`quantity`传入了值。\n因为`init(name: String)`和父类的`init(name: String)`使用了相同的参数，所以在前面使用`override`标识。\n第14行：父类的`init()`被子类继承了，但是它其中调用的`init(name: String)`替换成子类`RecipeIngredient`重写过后的便利构造器。\n``` swift\nclass ShoppingListItem: RecipeIngredient {\n    var purchased = false\n    var description: String {\n    var output = \"\\(quantity) x \\(name.lowercaseString)\"\n        output += purchased ? \" ✔\" : \" ✘\"\n        return output\n    }\n}\n\nvar breakfastList = [\n    ShoppingListItem(),\n    ShoppingListItem(name: \"Bacon\"),\n    ShoppingListItem(name: \"Eggs\", quantity: 6),\n]\nbreakfastList[0].name = \"Orange juice\"\nbreakfastList[0].purchased = true\nfor item in breakfastList {\n    println(item.description)\n}\n// 1 x orange juice ✔\n// 1 x bacon ✘\n// 6 x eggs ✘\n```\n类`ShoppingListItem`继承类`RecipeIngredient`。\n因为子类的新属性`purchased`有默认值，而且自己没有定义任何构造器，所以继承了父类的所有指定构造器。\n这时就满足上面提到继承父类构造器的第二个条件：子类提供了所有父类指定构造器的实现。\n所以子类也继承了父类的所有便利构造器。\n类`shoppingListItem`就继承了`init()`，`init(name: String)`和`init(name: String, quantity: Int)`三种构造器。\n\n## 可失败构造器\n构造过程中可能因为传入无效参数值，缺少资源，不满足必要条件等原因构造失败的构造器，称为可失败构造器。\n\n### 基本语法\n可失败构造器在`init`关键字后面加上`?`，即`init?`。\n并在失败的情况下加上`return nil`使构造器返回`nil`，非可失败构造器中不能使用`return`返回值。\n可失败构造器的参数名和参数类型不能与其他非可失败构造器完全相同。\n``` swift\nstruct Animal {\n    let species: String\n    init?(species: String) {\n        if species.isEmpty { return nil }\n        self.species = species\n    }\n}\n\nlet someCreature = Animal(species: \"Giraffe\")\n// someCreature 的类型是 Animal? 而不是 Animal\n\nif let giraffe = someCreature {\n    println(\"An animal was initialized with a species of \\(giraffe.species)\")\n}\n// 打印 \"An animal was initialized with a species of Giraffe\"\n\nlet anonymousCreature = Animal(species: \"\")\n// anonymousCreature 的类型是 Animal?, 而不是 Animal\n\nif anonymousCreature == nil {\n    println(\"The anonymous creature could not be initialized\")\n}\n// 打印 \"The anonymous creature could not be initialized\"\n```\n\n### 枚举类型的可失败构造器\n``` swift\nenum TemperatureUnit {\n    case Kelvin, Celsius, Fahrenheit\n    init?(symbol: Character) {\n        switch symbol {\n        case \"K\":\n            self = .Kelvin\n        case \"C\":\n            self = .Celsius\n        case \"F\":\n            self = .Fahrenheit\n        default:\n            return nil\n        }\n    }\n}\n\nlet fahrenheitUnit = TemperatureUnit(symbol: \"F\")\nif fahrenheitUnit != nil {\n    println(\"This is a defined temperature unit, so initialization succeeded.\")\n}\n// 打印 \"This is a defined temperature unit, so initialization succeeded.\"\n\nlet unknownUnit = TemperatureUnit(symbol: \"X\")\nif unknownUnit == nil {\n    println(\"This is not a defined temperature unit, so initialization failed.\")\n}\n// 打印 \"This is not a defined temperature unit, so initialization failed.\"\n```\n当参数值不能与任意一枚举成员相匹配时，该枚举类型的构建过程失败。\n\n带原始值的枚举类型会自带一个可失败构造器`init?(rawValue: )`，`rawValue`是一个默认参数，和枚举类型的原始值类型一致。\n如果该参数的值能和枚举类型成员所带的原始值匹配，则构建器构造一个带此原始值的枚举成员，否则构造失败。\n上面的例子可以重写为：\n``` swift\nenum TemperatureUnit: Character {\n    case Kelvin = \"K\", Celsius = \"C\", Fahrenheit = \"F\"\n}\n\nlet fahrenheitUnit = TemperatureUnit(rawValue: \"F\")\nif fahrenheitUnit != nil {\n    println(\"This is a defined temperature unit, so initialization succeeded.\")\n}\n// prints \"This is a defined temperature unit, so initialization succeeded.\"\n\nlet unknownUnit = TemperatureUnit(rawValue: \"X\")\nif unknownUnit == nil {\n    println(\"This is not a defined temperature unit, so initialization failed.\")\n}\n// prints \"This is not a defined temperature unit, so initialization failed.\"\n```\n\n### 类的可失败构造器\n类的可失败构造器只能在所有类属性被初始化和所有类之间的构造代理之间的代理调用发生完后触发失败行为。\n而值类型的可失败构造器可以随时随地触发。\n``` swift\nclass Product {\n    let name: String!\n    init?(name: String) {\n        self.name = name\n        if name.isEmpty { return nil }\n    }\n}\n\nif let bowTie = Product(name: \"bow tie\") {\n    // 不需要检查 bowTie.name == nil\n    println(\"The product's name is \\(bowTie.name)\")\n}\n// 打印 \"The product's name is bow tie\"\n```\n类`Product`的可失败构造器必须建立在`name`被赋值的情况下。\n所以`name`被声明为隐式解析可选类型（`String!`）保证触发失败条件时，`name`一定有值。\n类`Prodcut`构建成功时，`name`一定有一个非`nil`值，可以直接访问`name`。\n\n### 可失败构造器的代理\n可失败构造器的代理规则和构造器基本一致，只是一旦触发构造失败，整个构造过程就会被立即终止。\n可失败构造器可以在同一类中代理调用其他非可失败构造器，这样可以为已有的构造器添加构造失败的条件。\n``` swift\nclass Product {\n    let name: String!\n    init?(name: String) {\n        if name.isEmpty { return nil }\n        self.name = name\n    }\n}\n\nclass CartItem: Product {\n    let quantity: Int!\n    init?(name: String, quantity: Int) {\n        super.init(name: name)\n        if quantity < 1 { return nil }\n        self.quantity = quantity\n    }\n}\n\nif let twoSocks = CartItem(name: \"sock\", quantity: 2) {\n    println(\"Item: \\(twoSocks.name), quantity: \\(twoSocks.quantity)\")\n}\n// 打印 \"Item: sock, quantity: 2\"\n\nif let zeroShirts = CartItem(name: \"shirt\", quantity: 0) {\n    println(\"Item: \\(zeroShirts.name), quantity: \\(zeroShirts.quantity)\")\n} else {\n    println(\"Unable to initialize zero shirts\")\n}\n// 打印 \"Unable to initialize zero shirts\"\n\nif let oneUnnamed = CartItem(name: \"\", quantity: 1) {\n    println(\"Item: \\(oneUnnamed.name), quantity: \\(oneUnnamed.quantity)\")\n} else {\n    println(\"Unable to initialize one unnamed product\")\n}\n// 打印 \"Unable to initialize one unnamed product\"\n```\n第18行：构造成功。\n第23行：`quantiry`的值小于`1`，不满足条件，构造失败。\n第30行：`name`为空，父类`Product`可失败构造器触发构造失败，整个构造过程停止并失败。\n\n### 可失败构造器的重写\n父类的可失败构造器可以被子类的可失败构造器或者非可失败构造器重写。\n但是父类的非可失败构造器不可以被子类的可失败构造器重写。\n如果用非可失败构造器重写可失败构造器时，不再向上代理父类的可失败构造器，非可失败构造器不不会代理调用可失败构造器。\n``` swift\nclass Document {\n    var name: String?\n    // 该构造器构建了一个name属性值为nil的document对象\n    init() {}\n    // 该构造器构建了一个name属性值为非空字符串的document对象\n    init?(name: String) {\n        if name.isEmpty { return nil }\n        self.name = name\n    }\n}\n\nclass AutomaticallyNamedDocument: Document {\n    override init() {\n        super.init()\n        self.name = \"[Untitled]\"\n    }\n    override init(name: String) {\n        super.init()\n        if name.isEmpty {\n            self.name = \"[Untitled]\"\n        } else {\n            self.name = name\n        }\n    }\n}\n```\n\n### 隐私解析可选类型的可失败构造器\n`init!`同`init?`一样都是可失败构造器，该可失败构造器就会构造一个特定类型的隐私解析可选类型的对象。\n`init?`和`init!`可以相互代理调用，相互重写。\n`init`也可以代理调用`init!`，但这会触发一个断言：`init!`是否会触发构造失败。\n\n### 必要构造器\n在类的构造器前添加`required`关键字表示该类的子类都必须实现该构造器。\n子类重写父类的`required`必要构造器时，也要加上`required`关键字，也是必要构造器。\n覆盖基类的必要构造器时，不需要添加`override`关键字。\n``` swift\nclass SomeClass {\n    required init() {\n        // 在这里添加该必要构造器的实现代码\n    }\n}\n\nclass SomeSubclass: SomeClass {\n    required init() {\n        // 在这里添加子类必要构造器的实现代码\n    }\n}\n```\n不一定需要显示的实现父类的必要构造器，只要满足父类的必要构造器需求即可。\n\n## 闭包设置属性默认值\n闭包可以用来为属性提供定制的默认值，返回和属性类型相同类型的默认值。\n在闭包中不能使用其他属性，不能访问其他实例方法，不能使用`self`属性。\n``` swift\nclass SomeClass {\n    let someProperty: SomeType = {\n        // 在这个闭包中给 someProperty 创建一个默认值\n        // someValue 必须和 SomeType 类型相同\n        return someValue\n        }()\n}\n```\n闭包后面接`()`表示闭包立刻执行，否则会把闭包赋值给`someProperty`。\n``` swift\nstruct Checkerboard {\n    let boardColors: [Bool] = {\n        var temporaryBoard = [Bool]()\n        var isBlack = false\n        for i in 1...10 {\n            for j in 1...10 {\n                temporaryBoard.append(isBlack)\n                isBlack = !isBlack\n            }\n            isBlack = !isBlack\n        }\n        return temporaryBoard\n        }()\n    func squareIsBlackAtRow(row: Int, column: Int) -> Bool {\n        return boardColors[(row * 10) + column]\n    }\n}\n\nlet board = Checkerboard()\nprintln(board.squareIsBlackAtRow(0, column: 1))\n// 输出 \"true\"\nprintln(board.squareIsBlackAtRow(9, column: 9))\n// 输出 \"false\"\n```\n这里的闭包把类`Checkerboard`的布尔型数组`boardColors`初始化为`true`和`false`交替的数组，可以用来标识国际象棋的棋盘。\n\n# 析构过程\nSwift会自动释放不再需要的实例以释放资源。如果我们需要进行一些额外的清理，就需要使用析构函数。\n每个类最多只能有一个析构函数。\n析构函数使用关键字`deinit`，不带任何参数，在写法上不带括号：\n``` swift\nclass ClassName {\n    deinit { \n\t//some action\n    }\n}\n```\n析构函数是在实例释放前被自动调用，不允许自己主动调用。\n子类的析构函数先调用，父类的析构函数后调用。子类没有提供析构函数，也会调用父类的析构函数。\n\n","source":"_posts/swift_8.md","raw":"title: \"Swift基础入门(8)：继承，构造过程和析构过程\"\ndate: 2015-07-21 17:17:02\ntags:\n- swift\ncategories: swift\ntoc: true\n---\n\n本篇介绍Swift的基础知识：类的继承；枚举，结构体和类的构造过程和析构过程。\n\n<!--more-->\n**Title: [Swift基础入门(8)：继承，构造过程和析构过程](https://aidaizyy.github.io/swift_8)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-22](http://aidaizyy.github.io)**\n\n# 继承\n\n## 基本语法\n子类（_subclass_）继承（_inherit_）继承超类/父类（_superclass_）的属性，方法，下标脚本和其他特性。\n声明子类时，将超类名写在子类名的后面，用冒号分割：\n``` swift\nclass Vehicle {\n    var currentSpeed = 0.0\n    var description: String {\n        return \"traveling at \\(currentSpeed) miles per hour\"\n    }\n    func makeNoise() {\n        // 什么也不做-因为车辆不一定会有噪音\n    }\n}\n\nclass Bicycle: Vehicle {\n    var hasBasket = false\n}\n\nclass Tandem: Bicycle {\n    var currentNumberOfPassengers = 0\n}\n\nlet tandem = Tandem()\ntandem.hasBasket = true\ntandem.currentNumberOfPassengers = 2\ntandem.currentSpeed = 22.0\nprintln(\"Tandem: \\(tandem.description)\")\n// Tandem: traveling at 22.0 miles per hour\n```\n\n## 重写\n重写（_overriding_）指子类把父类的实例方法，类方法，实例属性和下表脚本等提供自己定制的实现。\n在重写定义的前面加上关键字`override`。\n使用`super`前缀可以访问超类的属性，方法和下表脚本。\n\n### 重写方法\n``` swift\nclass Train: Vehicle {\n    override func makeNoise() {\n        println(\"Choo Choo\")\n    }\n}\n\nclass Car: Vehicle {\n    var gear = 1\n    override var description: String {\n        return super.description + \" in gear \\(gear)\"\n    }\n}\n\nlet train = Train()\ntrain.makeNoise()\n// prints \"Choo Choo\"\n```\n\n### 重写属性\n- 超类的只读属性在子类中可以重写为读写属性，但是读写属性不能重写为只读属性。\n- 超类的重写属性在子类中必须完整实现setter和getter，可以用`super.someProperty`返回超类的getter。\n``` swift\nclass Car: Vehicle {\n    var gear = 1\n    override var description: String {\n        return super.description + \" in gear \\(gear)\"\n    }\n}\n\nlet car = Car()\ncar.currentSpeed = 25.0\ncar.gear = 3\nprintln(\"Car: \\(car.description)\")\n// Car: traveling at 25.0 miles per hour in gear 3\n```\n\n### 重写属性观察器\nsetter和属性观察器不能同时存在，setter中可以观察到值的变化。\n``` swift\nclass AutomaticCar: Car {\n    override var currentSpeed: Double {\n        didSet {\n            gear = Int(currentSpeed / 10.0) + 1\n        }\n    }\n}\n\nlet automatic = AutomaticCar()\nautomatic.currentSpeed = 35.0\nprintln(\"AutomaticCar: \\(automatic.description)\")\n// AutomaticCar: traveling at 35.0 miles per hour in gear 4\n```\n\n## 防止重写\n属性，方法和下标脚本前面加上`final`关键字可以防止它们被重写。\n`final var`，`final func`，`final class func`，`final subscript`。\n\n# 构造过程\n构造过程（_Inititalization_）为实例的每个属性设置初始值和为其执行必要的准备和初始化任务。\n\n## 构造器\n### 属性默认值\n属性声明时，可以为其设置默认值。\n``` swift\nstruct Fahrenheit {\n    var temperature = 32.0\n}\n\nvar f = Fahrenheit()\nprintln(\"The default temperature is \\(f.temperature)° Fahrenheit\")\n// 输出 \"The default temperature is 32.0° Fahrenheit”\n```\n构造器，也可以为属性赋初始值，关键字`init`。\n``` swift\nstruct Fahrenheit {\n    var temperature: Double\n    init() {\n        temperature = 32.0\n    }\n}\n\nvar f = Fahrenheit()\nprintln(\"The default temperature is \\(f.temperature)° Fahrenheit\")\n// 输出 \"The default temperature is 32.0° Fahrenheit”\n```\n\n### 构造器参数\n构造器可以传入参数。\n传入参数默认具有和内部参数名一致的外部参数名，相当于默认在参数名前加上了`#`。\n用`_`替代外部参数名，可以取消默认的外部参数名。\n``` swift\nstruct Color {\n    let red, green, blue: Double\n    init(red: Double, g green: Double, _ blue: Double) {\n        self.red   = red\n        self.green = green\n        self.blue  = blue\n    }\n    init(white: Double) {\n        red   = white\n        green = white\n        blue  = white\n    }\n}\n\nlet magenta = Color(red: 1.0, g: 0.0, 1.0)\nlet halfGray = Color(white: 0.5)\n```\n\n### 可选类型属性\n如果属性为可选类型，构造器自动初始化为`nil`。\n\n### 常量属性\n构造器中可以修改常量`let`属性的值，在构造过程中结束后，常量的值不能被修改。\n\n### 默认构造器\n所有属性已提供默认值且没有定义构造器的结构体或基类，具有一个默认的构造器，把默认值赋值给属性作为初始值。\n\n前面讲过，结构体的逐一成员构造器，算是一个默认的构造器。\n``` swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nlet twoByTwo = Size(width: 2.0, height: 2.0)\n```\n这里`Size`获得了一个逐一成员构造器`init(width: height: )`。\n\n## 值类型的构造器代理\n构造器可以通过调用其他构造器来完成构造过程，称为构造器代理。\n值类型比较简单，只能调用本身提供的其他构造器，而类可以继承构造器。\n``` swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Point {\n    var x = 0.0, y = 0.0\n}\n\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    init() {}\n    init(origin: Point, size: Size) {\n        self.origin = origin\n        self.size = size\n    }\n    init(center: Point, size: Size) {\n        let originX = center.x - (size.width / 2)\n        let originY = center.y - (size.height / 2)\n        self.init(origin: Point(x: originX, y: originY), size: size)\n    }\n}\n```\n结构体`Rect`中实现了三个构造器。\n第一个构造器功能和默认构造器类似，把默认值赋值给属性。\n第二个构造器功能和逐一成员构造器类似，逐一把值赋值给属性。\n第三个构造器调用了第二个构造器，完成了部分构造过程。\n\n## 类的构造器代理\n\n### 指定构造器和便利构造器\n类类型的构造器要确保所有存储型属性获得初始值，包括继承来的属性，分为指定构造器和便利构造器。\n- 指定构造器\n主要的类构造器，根据父类链依次往上调用父类的构造器，每个类都必须拥有至少一个指定构造器。\n写法和值类型的构造器一样：\n``` swift\ninit(parameters) {\n    statements\n}\n```\n- 便利构造器\n次要的类构造器，调用同一个类中的指定构造器，也可以创建一个特殊用途或特定输入的实例，只在必要时提供便利构造器。\n写法和值类型的构造器也基本一样，在`init`前加上`convenience`关键字：\n``` swift\nconvenience init(parameters) {\n    statements\n}\n```\n\n+ 指定构造器必须调用其直接父类的指定构造器。\n+ 便利构造器必须调用同一类中定义的其他构器。\n+ 便利构造器必须最终以调用一个指定构造器结束。\n\n也就是说：\n- 指定构造器必须总是向上代理\n- 便利构造器必须总是横向代理\n\n### 构造器继承和重写\n重写（_Override_）指定构造器，在子类中重写实现并调用父类构造器。\n重写便利构造器，必须通过调用同一类提供的其他指定构造器来实现。\n\n子类不会默认继承父类的构造器。\n如果特定条件满足，父类构造器也会被自动继承：\n- 子类的任意新属性都有默认值，且没有定义任何指定构造器，它将自动继承所有父类的指定构造器。\n- 子类提供了所有父类指定构造器的实现，它将自动继承所有父类的便利构造器。\n\n### 构造过程\n构造过程分为两个阶段。\n第一个阶段：\n沿着构造器链先初始化子类的属性，再代理给父类构造器，初始化父类的属性。\n当到达构造器链最顶部时，所有的存储型属性都已经赋值。\n这个阶段不能调用任何实例方法，不能读取任何实例属性的值，不能引用`self`的值。\n\n第二个阶段：\n沿着构造器链沿相反方向，从顶部向下，进一步定制实例，可以为任意属性赋新值。\n这个阶段可以调用实例方法，修改实例属性，并访问`self`。\n\n### 实例\n``` swift\nclass Food {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n    convenience init() {\n        self.init(name: \"[Unnamed]\")\n    }\n}\n\nlet namedMeat = Food(name: \"Bacon\")\n// namedMeat 的名字是 \"Bacon”\n\nlet mysteryMeat = Food()\n// mysteryMeat 的名字是 [Unnamed]\n```\n类`Food`提供了一个指定构造器`init(name: String)`和一个便利构造器`init()`。\n第11行：指定构造器，初始化属性`name`，因为`Food`没有父类，所以结束构造过程。\n第14行：便利构造器，调用了同一个类的指定构造器并给参数`name`传入值`[Unnamed]`。\n``` swift\nclass RecipeIngredient: Food {\n    var quantity: Int\n    init(name: String, quantity: Int) {\n        self.quantity = quantity\n        super.init(name: name)\n    }\n    override convenience init(name: String) {\n        self.init(name: name, quantity: 1)\n    }\n}\n\nlet sixEggs = RecipeIngredient(name: \"Eggs\", quantity: 6)\nlet oneBacon = RecipeIngredient(name: \"Bacon\")\nlet oneMysteryItem = RecipeIngredient()\n```\n类`RecipeIngredient`继承类`Food`，提供了一个指定构造器`init(name: String, quantity: Int)`和一个便利构造器`init(name: String)。\n第12行：指定构造器，先初始化子类的属性`quantity`，再代理给父类`Food`的`init(name: String)`。\n第13行：便利构造器，调用了同一个类的指定构造器并给参数`name`和`quantity`传入了值。\n因为`init(name: String)`和父类的`init(name: String)`使用了相同的参数，所以在前面使用`override`标识。\n第14行：父类的`init()`被子类继承了，但是它其中调用的`init(name: String)`替换成子类`RecipeIngredient`重写过后的便利构造器。\n``` swift\nclass ShoppingListItem: RecipeIngredient {\n    var purchased = false\n    var description: String {\n    var output = \"\\(quantity) x \\(name.lowercaseString)\"\n        output += purchased ? \" ✔\" : \" ✘\"\n        return output\n    }\n}\n\nvar breakfastList = [\n    ShoppingListItem(),\n    ShoppingListItem(name: \"Bacon\"),\n    ShoppingListItem(name: \"Eggs\", quantity: 6),\n]\nbreakfastList[0].name = \"Orange juice\"\nbreakfastList[0].purchased = true\nfor item in breakfastList {\n    println(item.description)\n}\n// 1 x orange juice ✔\n// 1 x bacon ✘\n// 6 x eggs ✘\n```\n类`ShoppingListItem`继承类`RecipeIngredient`。\n因为子类的新属性`purchased`有默认值，而且自己没有定义任何构造器，所以继承了父类的所有指定构造器。\n这时就满足上面提到继承父类构造器的第二个条件：子类提供了所有父类指定构造器的实现。\n所以子类也继承了父类的所有便利构造器。\n类`shoppingListItem`就继承了`init()`，`init(name: String)`和`init(name: String, quantity: Int)`三种构造器。\n\n## 可失败构造器\n构造过程中可能因为传入无效参数值，缺少资源，不满足必要条件等原因构造失败的构造器，称为可失败构造器。\n\n### 基本语法\n可失败构造器在`init`关键字后面加上`?`，即`init?`。\n并在失败的情况下加上`return nil`使构造器返回`nil`，非可失败构造器中不能使用`return`返回值。\n可失败构造器的参数名和参数类型不能与其他非可失败构造器完全相同。\n``` swift\nstruct Animal {\n    let species: String\n    init?(species: String) {\n        if species.isEmpty { return nil }\n        self.species = species\n    }\n}\n\nlet someCreature = Animal(species: \"Giraffe\")\n// someCreature 的类型是 Animal? 而不是 Animal\n\nif let giraffe = someCreature {\n    println(\"An animal was initialized with a species of \\(giraffe.species)\")\n}\n// 打印 \"An animal was initialized with a species of Giraffe\"\n\nlet anonymousCreature = Animal(species: \"\")\n// anonymousCreature 的类型是 Animal?, 而不是 Animal\n\nif anonymousCreature == nil {\n    println(\"The anonymous creature could not be initialized\")\n}\n// 打印 \"The anonymous creature could not be initialized\"\n```\n\n### 枚举类型的可失败构造器\n``` swift\nenum TemperatureUnit {\n    case Kelvin, Celsius, Fahrenheit\n    init?(symbol: Character) {\n        switch symbol {\n        case \"K\":\n            self = .Kelvin\n        case \"C\":\n            self = .Celsius\n        case \"F\":\n            self = .Fahrenheit\n        default:\n            return nil\n        }\n    }\n}\n\nlet fahrenheitUnit = TemperatureUnit(symbol: \"F\")\nif fahrenheitUnit != nil {\n    println(\"This is a defined temperature unit, so initialization succeeded.\")\n}\n// 打印 \"This is a defined temperature unit, so initialization succeeded.\"\n\nlet unknownUnit = TemperatureUnit(symbol: \"X\")\nif unknownUnit == nil {\n    println(\"This is not a defined temperature unit, so initialization failed.\")\n}\n// 打印 \"This is not a defined temperature unit, so initialization failed.\"\n```\n当参数值不能与任意一枚举成员相匹配时，该枚举类型的构建过程失败。\n\n带原始值的枚举类型会自带一个可失败构造器`init?(rawValue: )`，`rawValue`是一个默认参数，和枚举类型的原始值类型一致。\n如果该参数的值能和枚举类型成员所带的原始值匹配，则构建器构造一个带此原始值的枚举成员，否则构造失败。\n上面的例子可以重写为：\n``` swift\nenum TemperatureUnit: Character {\n    case Kelvin = \"K\", Celsius = \"C\", Fahrenheit = \"F\"\n}\n\nlet fahrenheitUnit = TemperatureUnit(rawValue: \"F\")\nif fahrenheitUnit != nil {\n    println(\"This is a defined temperature unit, so initialization succeeded.\")\n}\n// prints \"This is a defined temperature unit, so initialization succeeded.\"\n\nlet unknownUnit = TemperatureUnit(rawValue: \"X\")\nif unknownUnit == nil {\n    println(\"This is not a defined temperature unit, so initialization failed.\")\n}\n// prints \"This is not a defined temperature unit, so initialization failed.\"\n```\n\n### 类的可失败构造器\n类的可失败构造器只能在所有类属性被初始化和所有类之间的构造代理之间的代理调用发生完后触发失败行为。\n而值类型的可失败构造器可以随时随地触发。\n``` swift\nclass Product {\n    let name: String!\n    init?(name: String) {\n        self.name = name\n        if name.isEmpty { return nil }\n    }\n}\n\nif let bowTie = Product(name: \"bow tie\") {\n    // 不需要检查 bowTie.name == nil\n    println(\"The product's name is \\(bowTie.name)\")\n}\n// 打印 \"The product's name is bow tie\"\n```\n类`Product`的可失败构造器必须建立在`name`被赋值的情况下。\n所以`name`被声明为隐式解析可选类型（`String!`）保证触发失败条件时，`name`一定有值。\n类`Prodcut`构建成功时，`name`一定有一个非`nil`值，可以直接访问`name`。\n\n### 可失败构造器的代理\n可失败构造器的代理规则和构造器基本一致，只是一旦触发构造失败，整个构造过程就会被立即终止。\n可失败构造器可以在同一类中代理调用其他非可失败构造器，这样可以为已有的构造器添加构造失败的条件。\n``` swift\nclass Product {\n    let name: String!\n    init?(name: String) {\n        if name.isEmpty { return nil }\n        self.name = name\n    }\n}\n\nclass CartItem: Product {\n    let quantity: Int!\n    init?(name: String, quantity: Int) {\n        super.init(name: name)\n        if quantity < 1 { return nil }\n        self.quantity = quantity\n    }\n}\n\nif let twoSocks = CartItem(name: \"sock\", quantity: 2) {\n    println(\"Item: \\(twoSocks.name), quantity: \\(twoSocks.quantity)\")\n}\n// 打印 \"Item: sock, quantity: 2\"\n\nif let zeroShirts = CartItem(name: \"shirt\", quantity: 0) {\n    println(\"Item: \\(zeroShirts.name), quantity: \\(zeroShirts.quantity)\")\n} else {\n    println(\"Unable to initialize zero shirts\")\n}\n// 打印 \"Unable to initialize zero shirts\"\n\nif let oneUnnamed = CartItem(name: \"\", quantity: 1) {\n    println(\"Item: \\(oneUnnamed.name), quantity: \\(oneUnnamed.quantity)\")\n} else {\n    println(\"Unable to initialize one unnamed product\")\n}\n// 打印 \"Unable to initialize one unnamed product\"\n```\n第18行：构造成功。\n第23行：`quantiry`的值小于`1`，不满足条件，构造失败。\n第30行：`name`为空，父类`Product`可失败构造器触发构造失败，整个构造过程停止并失败。\n\n### 可失败构造器的重写\n父类的可失败构造器可以被子类的可失败构造器或者非可失败构造器重写。\n但是父类的非可失败构造器不可以被子类的可失败构造器重写。\n如果用非可失败构造器重写可失败构造器时，不再向上代理父类的可失败构造器，非可失败构造器不不会代理调用可失败构造器。\n``` swift\nclass Document {\n    var name: String?\n    // 该构造器构建了一个name属性值为nil的document对象\n    init() {}\n    // 该构造器构建了一个name属性值为非空字符串的document对象\n    init?(name: String) {\n        if name.isEmpty { return nil }\n        self.name = name\n    }\n}\n\nclass AutomaticallyNamedDocument: Document {\n    override init() {\n        super.init()\n        self.name = \"[Untitled]\"\n    }\n    override init(name: String) {\n        super.init()\n        if name.isEmpty {\n            self.name = \"[Untitled]\"\n        } else {\n            self.name = name\n        }\n    }\n}\n```\n\n### 隐私解析可选类型的可失败构造器\n`init!`同`init?`一样都是可失败构造器，该可失败构造器就会构造一个特定类型的隐私解析可选类型的对象。\n`init?`和`init!`可以相互代理调用，相互重写。\n`init`也可以代理调用`init!`，但这会触发一个断言：`init!`是否会触发构造失败。\n\n### 必要构造器\n在类的构造器前添加`required`关键字表示该类的子类都必须实现该构造器。\n子类重写父类的`required`必要构造器时，也要加上`required`关键字，也是必要构造器。\n覆盖基类的必要构造器时，不需要添加`override`关键字。\n``` swift\nclass SomeClass {\n    required init() {\n        // 在这里添加该必要构造器的实现代码\n    }\n}\n\nclass SomeSubclass: SomeClass {\n    required init() {\n        // 在这里添加子类必要构造器的实现代码\n    }\n}\n```\n不一定需要显示的实现父类的必要构造器，只要满足父类的必要构造器需求即可。\n\n## 闭包设置属性默认值\n闭包可以用来为属性提供定制的默认值，返回和属性类型相同类型的默认值。\n在闭包中不能使用其他属性，不能访问其他实例方法，不能使用`self`属性。\n``` swift\nclass SomeClass {\n    let someProperty: SomeType = {\n        // 在这个闭包中给 someProperty 创建一个默认值\n        // someValue 必须和 SomeType 类型相同\n        return someValue\n        }()\n}\n```\n闭包后面接`()`表示闭包立刻执行，否则会把闭包赋值给`someProperty`。\n``` swift\nstruct Checkerboard {\n    let boardColors: [Bool] = {\n        var temporaryBoard = [Bool]()\n        var isBlack = false\n        for i in 1...10 {\n            for j in 1...10 {\n                temporaryBoard.append(isBlack)\n                isBlack = !isBlack\n            }\n            isBlack = !isBlack\n        }\n        return temporaryBoard\n        }()\n    func squareIsBlackAtRow(row: Int, column: Int) -> Bool {\n        return boardColors[(row * 10) + column]\n    }\n}\n\nlet board = Checkerboard()\nprintln(board.squareIsBlackAtRow(0, column: 1))\n// 输出 \"true\"\nprintln(board.squareIsBlackAtRow(9, column: 9))\n// 输出 \"false\"\n```\n这里的闭包把类`Checkerboard`的布尔型数组`boardColors`初始化为`true`和`false`交替的数组，可以用来标识国际象棋的棋盘。\n\n# 析构过程\nSwift会自动释放不再需要的实例以释放资源。如果我们需要进行一些额外的清理，就需要使用析构函数。\n每个类最多只能有一个析构函数。\n析构函数使用关键字`deinit`，不带任何参数，在写法上不带括号：\n``` swift\nclass ClassName {\n    deinit { \n\t//some action\n    }\n}\n```\n析构函数是在实例释放前被自动调用，不允许自己主动调用。\n子类的析构函数先调用，父类的析构函数后调用。子类没有提供析构函数，也会调用父类的析构函数。\n\n","slug":"swift_8","published":1,"updated":"2015-07-22T15:24:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cicflp6is0002r2o3tvi7aq5y"},{"title":"Swift基础入门(7)：属性，方法和下标脚本","date":"2015-07-20T02:10:20.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：枚举，结构体和类的属性，方法和下标脚本。\n\n<!--more-->\n**Title: [Swift基础入门(7)：属性，方法和下标脚注](https://aidaizyy.github.io/swift_7)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-22](http://aidaizyy.github.io)**\n\n# 属性\n属性分为存储属性（只能用于类和结构体）和计算属性（可用于类，结构体和枚举）。\n\n## 存储属性\n存储属性可用`var`或`let`修饰。\n结构体用`let`修饰，属性不可以更改，因为结构体是值类型。\n类用`let`修饰，属性可以更改，因为类是引用类型。\n结构体可以在构造时逐一初始化属性，而类不可以，参见[类和结构体](http://aidaizyy.github.io/swift_6/#类和结构体)。\n- 延迟属性\n延迟属性用`lazy`标示，且必须使用`var`关键字，只有在第一次被调用时才会计算其初始值，在构造时不会计算初始值。\n``` swift\nclass DataImporter {\n    /*\n    DataImporter 是一个将外部文件中的数据导入的类。\n    这个类的初始化会消耗不少时间。\n    */\n    var fileName = \"data.txt\"\n    // 这是提供数据导入功能\n}\n\nclass DataManager {\n    lazy var importer = DataImporter()\n    var data = [String]()\n    // 这是提供数据管理功能\n}\n\nlet manager = DataManager()\nmanager.data.append(\"Some data\")\nmanager.data.append(\"Some more data\")\n// DataImporter 实例的 importer 属性还没有被创建\n\nprintln(manager.importer.fileName)\n// DataImporter 实例的 importer 属性现在被创建了\n// 输出 \"data.txt”\n```\n以上并未给出全部代码，类`DataManager`中声明了延迟属性`importer`。\n类`DataImporter`实现数据导入功能，会消耗不少时间。\n初始化类`DataManager`时，延迟属性并不会创建。\n只有在`println(manager.importer.fileName)`时，属性`importer`第一次被调用时，才会创建延迟属性`importer`，完成数据导入功能。\n\n## 计算属性\n计算属性不直接存储值，提供getter获取值和可选的setter来间接设置其他属性的值，必须用`var`修饰。\n``` swift\nstruct Point {\n    var x = 0.0, y = 0.0\n}\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n    get {\n        let centerX = origin.x + (size.width / 2)\n        let centerY = origin.y + (size.height / 2)\n        return Point(x: centerX, y: centerY)\n    }\n    set(newCenter) {\n        origin.x = newCenter.x - (size.width / 2)\n        origin.y = newCenter.y - (size.height / 2)\n    }\n    }\n}\nvar square = Rect(origin: Point(x: 0.0, y: 0.0),\n    size: Size(width: 10.0, height: 10.0))\nlet initialSquareCenter = square.center\nsquare.center = Point(x: 15.0, y: 15.0)\nprintln(\"square.origin is now at (\\(square.origin.x), \\(square.origin.y))\")\n// 输出 \"square.origin is now at (10.0, 10.0)”\n```\n在结构体`Rect`中，属性`center`是计算属性，分别设置了`get`方法和`set`方法。\n`set`方法可以不指定新值的参数名称，比如`newCenter`，在方法中直接使用默认名称`newValue`，上面可写作：\n``` swift\nset {\n        origin.x = newValue.x - (size.width / 2)\n        origin.y = newValue.y - (size.height / 2)\n    }\n```\n- 只读计算属性\n不设置setter，只设置getter的计算属性称为只读计算属性。\n``` swift\nstruct Cuboid {\n    var width = 0.0, height = 0.0, depth = 0.0\n    var volume: Double {\n    return width * height * depth\n    }\n}\nlet fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)\nprintln(\"the volume of fourByFiveByTwo is \\(fourByFiveByTwo.volume)\")\n// 输出 \"the volume of fourByFiveByTwo is 40.0\"\n```\n只读计算属性可省略`get`关键字。\n\n## 属性观察器\n属性观察器可以监控和响应属性值的变化。\n- willSet 在设置新值之前调用\n- didSet 在设置新值之后调用\n``` swift\nclass StepCounter {\n    var totalSteps: Int = 0 {\n    willSet(newTotalSteps) {\n        println(\"About to set totalSteps to \\(newTotalSteps)\")\n    }\n    didSet(oldTotalSteps) {\n        if totalSteps > oldTotalSteps  {\n            println(\"Added \\(totalSteps - oldTotalSteps) steps\")\n        }\n    }\n    }\n}\nlet stepCounter = StepCounter()\nstepCounter.totalSteps = 200\n// About to set totalSteps to 200\n// Added 200 steps\nstepCounter.totalSteps = 360\n// About to set totalSteps to 360\n// Added 160 steps\nstepCounter.totalSteps = 896\n// About to set totalSteps to 896\n// Added 536 steps\n```\n`willSet`如果不指定新值参数名，可用`newValue`替代。\n`didSet`如果不指定旧值参数名，可用`oldValue`替代。\n通过重写的方式可以为继承来的存储属性和计算属性添加属性观察器。\n\n计算属性和属性观察器也可以用于全局变量和局部变量。\n全局的常量变量都是延迟计算的，不需要标记`lazy`。而局部的常量变量不会延迟计算。\n\n## 类型属性\n类型属性指所有类型实例公用的属性，类似于其他语言中的静态属性（_static_）。\n值类型可以定义存储型和计算型的类型属性。\n因为类是引用类型，所以只能定义计算型的类型属性。\n存储型的类型属性必须指定默认值。\n类型属性在属性前加上`static`关键字。\n``` swift\nstruct SomeStructure {\n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n    // 这里返回一个 Int 值\n    }\n}\nenum SomeEnumeration {\n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n    // 这里返回一个 Int 值\n    }\n}\nclass SomeClass {\n    class var computedTypeProperty: Int {\n    // 这里返回一个 Int 值\n    }\n}\n\nprintln(SomeClass.computedTypeProperty)\n// 输出 \"42\"\n\nprintln(SomeStructure.storedTypeProperty)\n// 输出 \"Some value.\"\nSomeStructure.storedTypeProperty = \"Another value.\"\nprintln(SomeStructure.storedTypeProperty)\n// 输出 \"Another value.”\n```\n这里计算型类型属性都是只读型，也可以定义为可读可写。\n\n# 方法\n\n## 实例方法\n方法是定义在类，结构体和枚举中的方法，和函数类似。\n类，结构体和枚举创建实例后，其中的方法被称为实例方法，只属于当前实例。\n``` swift\nclass Counter {\n  var count = 0\n  func increment() {\n    count++\n  }\n  func incrementBy(amount: Int) {\n    count += amount\n  }\n  func reset() {\n    count = 0\n  }\n}\n\nlet counter = Counter()\n// 初始计数值是0\ncounter.increment()\n// 计数值现在是1\ncounter.incrementBy(5)\n// 计数值现在是6\ncounter.reset()\n// 计数值现在是0\n```\n### 外部参数名\n方法默认第一个参数没有外部参数名，第二个及以后参数默认有外部参数名，和参数名一致，相当于默认在参数前加上了`#`。\n``` swift\nclass Counter {\n  var count: Int = 0\n  func incrementBy(amount: Int, numberOfTimes: Int) {\n    count += amount * numberOfTimes\n  }\n}\n\nlet counter = Counter()\ncounter.incrementBy(5, numberOfTimes: 3)\n// counter value is now 15\n```\n也可以在第一个参数名添加外部参数名，也可以用_放在第二个及以后的参数名前取消默认的外部参数名。\n``` swift\nclass Counter {\n    var count: Int = 0\n    func incrementBy(#amount: Int, _ numberOfTimes: Int) {\n        count += amount * numberOfTimes\n    }\n}\n\nlet counter = Counter()\ncounter.incrementBy(amount: 5, 3)\nprintln(counter.count)\n// counter value is now 15\n```\n关于外部参数名，参见[函数的外部参数名](http://aidaizyy.github.io/swift_5/#外部参数名)。\n\n### self属性\n在每个实例中，都有一个隐藏属性`self`，指代实例变身，以便方法调用实例本身。\n``` swift\nfunc increment() {\n  self.count++\n}\n```\n\n### 变异方法\n结构体和枚举是值类型。值类型的属性不可以在实例方法中被修改。\n变异方法可以完成对属性的修改，在`func`前加上`mutating`关键字。\n``` swift\nstruct Point {\n  var x = 0.0, y = 0.0\n  mutating func moveByX(deltaX: Double, y deltaY: Double) {\n    x += deltaX\n    y += deltaY\n  }\n}\nvar somePoint = Point(x: 1.0, y: 1.0)\nsomePoint.moveByX(2.0, y: 3.0)\nprintln(\"The point is now at (\\(somePoint.x), \\(somePoint.y))\")\n// 输出 \"The point is now at (3.0, 4.0)\"\n```\n变异方法也可以给`self`赋值，即新建一个实例替代旧的实例。\n``` swift\nstruct Point {\n  var x = 0.0, y = 0.0\n  mutating func moveByX(deltaX: Double, y deltaY: Double) {\n    self = Point(x: x + deltaX, y: y + deltaY)\n  }\n}\n```\n``` swift\nenum TriStateSwitch {\n  case Off, Low, High\n  mutating func next() {\n    switch self {\n    case Off:\n      self = Low\n    case Low:\n      self = High\n    case High:\n      self = Off\n    }\n  }\n}\nvar ovenLight = TriStateSwitch.Low\novenLight.next()\n// ovenLight 现在等于 .High\novenLight.next()\n// ovenLight 现在等于 .Off\n```\n类是引用类型，实例方法可以直接修改属性。\n\n## 类型方法\n类型方法和类型属性类似，都是指所有类型实例公共的方法，类似于其他语言中的静态方法（_static_）。\n类型方法在类型前加上`class`关键字。\n类型方法能够直接通过静态属性的名称访问静态属性。\n``` swift\nclass SomeClass {\n  class func someTypeMethod() {\n    // type method implementation goes here\n  }\n}\nSomeClass.someTypeMethod()\n```\n\n# 下标脚本\n下标脚本（_subscripts_）可以定义在类，结构体和枚举中，是访问对象，集合和序列的快捷方式。比如[数组的访问](http://aidaizyy.github.io/swift_3/#访问)：Array[index]，[字典的访问](http://aidaizyy.github.io/swift_3/#访问-1)：Dictionary[key]。\n下标脚本的定义类似于实例方法和计算性属性的混合。\n使用`subscript`关键字，定义了传入参数数量和类型和返回类型，定义了getter和setter。\n``` swift\nsubscript(index: Int) -> Int {\n    get {\n      // 返回与入参匹配的Int类型的值\n    }\n\n    set(newValue) {\n      // 执行赋值操作\n    }\n}\n```\ngetter和setter的定义和计算型属性一样。\nsetter中可以使用`newValue`默认值，可以省略setter定义成只读类型。\n``` swift\nstruct TimesTable {\n    let multiplier: Int\n    subscript(index: Int) -> Int {\n      return multiplier * index\n    }\n}\nlet threeTimesTable = TimesTable(multiplier: 3)\nprintln(\"3的6倍是\\(threeTimesTable[6])\")\n// 输出 \"3的6倍是18\"\n```\n下标脚本允许任意数量的传入参数，任意类型的传入参数和任意类型的返回值。\n可以使用[变量参数](http://aidaizyy.github.io/swift_5/#变量参数)和[可变参数](http://aidaizyy.github.io/swift_5/#可变参数)，但是不能使用[输入输出参数（inout）](http://aidaizyy.github.io/swift_5/#输入输出参数)和[默认参数值](http://aidaizyy.github.io/swift_5/#默认参数值)。\n``` swift\nstruct Matrix {\n    let rows: Int, columns: Int\n    var grid: [Double]\n    init(rows: Int, columns: Int) {\n      self.rows = rows\n      self.columns = columns\n      grid = Array(count: rows * columns, repeatedValue: 0.0)\n    }\n    func indexIsValidForRow(row: Int, column: Int) -> Bool {\n        return row >= 0 && row < rows && column >= 0 && column < columns\n    }\n    subscript(row: Int, column: Int) -> Double {\n        get {\n            assert(indexIsValidForRow(row, column: column), \"Index out of range\")\n            return grid[(row * columns) + column]\n        }\n        set {\n            assert(indexIsValidForRow(row, column: column), \"Index out of range\")\n            grid[(row * columns) + column] = newValue\n        }\n    }\n}\n\nvar matrix = Matrix(rows: 2, columns: 2)\nprintln(matrix[0, 1])\n//0.0\nmatrix[0, 1] = 1.5\nprintln(matrix[0, 1])\n//1.5\n```\n","source":"_posts/swift_7.md","raw":"title: \"Swift基础入门(7)：属性，方法和下标脚本\"\ndate: 2015-07-20 10:10:20\ntags:\n- swift\ncategories: \ntoc: true\n---\n\n本篇介绍Swift的基础知识：枚举，结构体和类的属性，方法和下标脚本。\n\n<!--more-->\n**Title: [Swift基础入门(7)：属性，方法和下标脚注](https://aidaizyy.github.io/swift_7)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-22](http://aidaizyy.github.io)**\n\n# 属性\n属性分为存储属性（只能用于类和结构体）和计算属性（可用于类，结构体和枚举）。\n\n## 存储属性\n存储属性可用`var`或`let`修饰。\n结构体用`let`修饰，属性不可以更改，因为结构体是值类型。\n类用`let`修饰，属性可以更改，因为类是引用类型。\n结构体可以在构造时逐一初始化属性，而类不可以，参见[类和结构体](http://aidaizyy.github.io/swift_6/#类和结构体)。\n- 延迟属性\n延迟属性用`lazy`标示，且必须使用`var`关键字，只有在第一次被调用时才会计算其初始值，在构造时不会计算初始值。\n``` swift\nclass DataImporter {\n    /*\n    DataImporter 是一个将外部文件中的数据导入的类。\n    这个类的初始化会消耗不少时间。\n    */\n    var fileName = \"data.txt\"\n    // 这是提供数据导入功能\n}\n\nclass DataManager {\n    lazy var importer = DataImporter()\n    var data = [String]()\n    // 这是提供数据管理功能\n}\n\nlet manager = DataManager()\nmanager.data.append(\"Some data\")\nmanager.data.append(\"Some more data\")\n// DataImporter 实例的 importer 属性还没有被创建\n\nprintln(manager.importer.fileName)\n// DataImporter 实例的 importer 属性现在被创建了\n// 输出 \"data.txt”\n```\n以上并未给出全部代码，类`DataManager`中声明了延迟属性`importer`。\n类`DataImporter`实现数据导入功能，会消耗不少时间。\n初始化类`DataManager`时，延迟属性并不会创建。\n只有在`println(manager.importer.fileName)`时，属性`importer`第一次被调用时，才会创建延迟属性`importer`，完成数据导入功能。\n\n## 计算属性\n计算属性不直接存储值，提供getter获取值和可选的setter来间接设置其他属性的值，必须用`var`修饰。\n``` swift\nstruct Point {\n    var x = 0.0, y = 0.0\n}\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n    get {\n        let centerX = origin.x + (size.width / 2)\n        let centerY = origin.y + (size.height / 2)\n        return Point(x: centerX, y: centerY)\n    }\n    set(newCenter) {\n        origin.x = newCenter.x - (size.width / 2)\n        origin.y = newCenter.y - (size.height / 2)\n    }\n    }\n}\nvar square = Rect(origin: Point(x: 0.0, y: 0.0),\n    size: Size(width: 10.0, height: 10.0))\nlet initialSquareCenter = square.center\nsquare.center = Point(x: 15.0, y: 15.0)\nprintln(\"square.origin is now at (\\(square.origin.x), \\(square.origin.y))\")\n// 输出 \"square.origin is now at (10.0, 10.0)”\n```\n在结构体`Rect`中，属性`center`是计算属性，分别设置了`get`方法和`set`方法。\n`set`方法可以不指定新值的参数名称，比如`newCenter`，在方法中直接使用默认名称`newValue`，上面可写作：\n``` swift\nset {\n        origin.x = newValue.x - (size.width / 2)\n        origin.y = newValue.y - (size.height / 2)\n    }\n```\n- 只读计算属性\n不设置setter，只设置getter的计算属性称为只读计算属性。\n``` swift\nstruct Cuboid {\n    var width = 0.0, height = 0.0, depth = 0.0\n    var volume: Double {\n    return width * height * depth\n    }\n}\nlet fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)\nprintln(\"the volume of fourByFiveByTwo is \\(fourByFiveByTwo.volume)\")\n// 输出 \"the volume of fourByFiveByTwo is 40.0\"\n```\n只读计算属性可省略`get`关键字。\n\n## 属性观察器\n属性观察器可以监控和响应属性值的变化。\n- willSet 在设置新值之前调用\n- didSet 在设置新值之后调用\n``` swift\nclass StepCounter {\n    var totalSteps: Int = 0 {\n    willSet(newTotalSteps) {\n        println(\"About to set totalSteps to \\(newTotalSteps)\")\n    }\n    didSet(oldTotalSteps) {\n        if totalSteps > oldTotalSteps  {\n            println(\"Added \\(totalSteps - oldTotalSteps) steps\")\n        }\n    }\n    }\n}\nlet stepCounter = StepCounter()\nstepCounter.totalSteps = 200\n// About to set totalSteps to 200\n// Added 200 steps\nstepCounter.totalSteps = 360\n// About to set totalSteps to 360\n// Added 160 steps\nstepCounter.totalSteps = 896\n// About to set totalSteps to 896\n// Added 536 steps\n```\n`willSet`如果不指定新值参数名，可用`newValue`替代。\n`didSet`如果不指定旧值参数名，可用`oldValue`替代。\n通过重写的方式可以为继承来的存储属性和计算属性添加属性观察器。\n\n计算属性和属性观察器也可以用于全局变量和局部变量。\n全局的常量变量都是延迟计算的，不需要标记`lazy`。而局部的常量变量不会延迟计算。\n\n## 类型属性\n类型属性指所有类型实例公用的属性，类似于其他语言中的静态属性（_static_）。\n值类型可以定义存储型和计算型的类型属性。\n因为类是引用类型，所以只能定义计算型的类型属性。\n存储型的类型属性必须指定默认值。\n类型属性在属性前加上`static`关键字。\n``` swift\nstruct SomeStructure {\n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n    // 这里返回一个 Int 值\n    }\n}\nenum SomeEnumeration {\n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n    // 这里返回一个 Int 值\n    }\n}\nclass SomeClass {\n    class var computedTypeProperty: Int {\n    // 这里返回一个 Int 值\n    }\n}\n\nprintln(SomeClass.computedTypeProperty)\n// 输出 \"42\"\n\nprintln(SomeStructure.storedTypeProperty)\n// 输出 \"Some value.\"\nSomeStructure.storedTypeProperty = \"Another value.\"\nprintln(SomeStructure.storedTypeProperty)\n// 输出 \"Another value.”\n```\n这里计算型类型属性都是只读型，也可以定义为可读可写。\n\n# 方法\n\n## 实例方法\n方法是定义在类，结构体和枚举中的方法，和函数类似。\n类，结构体和枚举创建实例后，其中的方法被称为实例方法，只属于当前实例。\n``` swift\nclass Counter {\n  var count = 0\n  func increment() {\n    count++\n  }\n  func incrementBy(amount: Int) {\n    count += amount\n  }\n  func reset() {\n    count = 0\n  }\n}\n\nlet counter = Counter()\n// 初始计数值是0\ncounter.increment()\n// 计数值现在是1\ncounter.incrementBy(5)\n// 计数值现在是6\ncounter.reset()\n// 计数值现在是0\n```\n### 外部参数名\n方法默认第一个参数没有外部参数名，第二个及以后参数默认有外部参数名，和参数名一致，相当于默认在参数前加上了`#`。\n``` swift\nclass Counter {\n  var count: Int = 0\n  func incrementBy(amount: Int, numberOfTimes: Int) {\n    count += amount * numberOfTimes\n  }\n}\n\nlet counter = Counter()\ncounter.incrementBy(5, numberOfTimes: 3)\n// counter value is now 15\n```\n也可以在第一个参数名添加外部参数名，也可以用_放在第二个及以后的参数名前取消默认的外部参数名。\n``` swift\nclass Counter {\n    var count: Int = 0\n    func incrementBy(#amount: Int, _ numberOfTimes: Int) {\n        count += amount * numberOfTimes\n    }\n}\n\nlet counter = Counter()\ncounter.incrementBy(amount: 5, 3)\nprintln(counter.count)\n// counter value is now 15\n```\n关于外部参数名，参见[函数的外部参数名](http://aidaizyy.github.io/swift_5/#外部参数名)。\n\n### self属性\n在每个实例中，都有一个隐藏属性`self`，指代实例变身，以便方法调用实例本身。\n``` swift\nfunc increment() {\n  self.count++\n}\n```\n\n### 变异方法\n结构体和枚举是值类型。值类型的属性不可以在实例方法中被修改。\n变异方法可以完成对属性的修改，在`func`前加上`mutating`关键字。\n``` swift\nstruct Point {\n  var x = 0.0, y = 0.0\n  mutating func moveByX(deltaX: Double, y deltaY: Double) {\n    x += deltaX\n    y += deltaY\n  }\n}\nvar somePoint = Point(x: 1.0, y: 1.0)\nsomePoint.moveByX(2.0, y: 3.0)\nprintln(\"The point is now at (\\(somePoint.x), \\(somePoint.y))\")\n// 输出 \"The point is now at (3.0, 4.0)\"\n```\n变异方法也可以给`self`赋值，即新建一个实例替代旧的实例。\n``` swift\nstruct Point {\n  var x = 0.0, y = 0.0\n  mutating func moveByX(deltaX: Double, y deltaY: Double) {\n    self = Point(x: x + deltaX, y: y + deltaY)\n  }\n}\n```\n``` swift\nenum TriStateSwitch {\n  case Off, Low, High\n  mutating func next() {\n    switch self {\n    case Off:\n      self = Low\n    case Low:\n      self = High\n    case High:\n      self = Off\n    }\n  }\n}\nvar ovenLight = TriStateSwitch.Low\novenLight.next()\n// ovenLight 现在等于 .High\novenLight.next()\n// ovenLight 现在等于 .Off\n```\n类是引用类型，实例方法可以直接修改属性。\n\n## 类型方法\n类型方法和类型属性类似，都是指所有类型实例公共的方法，类似于其他语言中的静态方法（_static_）。\n类型方法在类型前加上`class`关键字。\n类型方法能够直接通过静态属性的名称访问静态属性。\n``` swift\nclass SomeClass {\n  class func someTypeMethod() {\n    // type method implementation goes here\n  }\n}\nSomeClass.someTypeMethod()\n```\n\n# 下标脚本\n下标脚本（_subscripts_）可以定义在类，结构体和枚举中，是访问对象，集合和序列的快捷方式。比如[数组的访问](http://aidaizyy.github.io/swift_3/#访问)：Array[index]，[字典的访问](http://aidaizyy.github.io/swift_3/#访问-1)：Dictionary[key]。\n下标脚本的定义类似于实例方法和计算性属性的混合。\n使用`subscript`关键字，定义了传入参数数量和类型和返回类型，定义了getter和setter。\n``` swift\nsubscript(index: Int) -> Int {\n    get {\n      // 返回与入参匹配的Int类型的值\n    }\n\n    set(newValue) {\n      // 执行赋值操作\n    }\n}\n```\ngetter和setter的定义和计算型属性一样。\nsetter中可以使用`newValue`默认值，可以省略setter定义成只读类型。\n``` swift\nstruct TimesTable {\n    let multiplier: Int\n    subscript(index: Int) -> Int {\n      return multiplier * index\n    }\n}\nlet threeTimesTable = TimesTable(multiplier: 3)\nprintln(\"3的6倍是\\(threeTimesTable[6])\")\n// 输出 \"3的6倍是18\"\n```\n下标脚本允许任意数量的传入参数，任意类型的传入参数和任意类型的返回值。\n可以使用[变量参数](http://aidaizyy.github.io/swift_5/#变量参数)和[可变参数](http://aidaizyy.github.io/swift_5/#可变参数)，但是不能使用[输入输出参数（inout）](http://aidaizyy.github.io/swift_5/#输入输出参数)和[默认参数值](http://aidaizyy.github.io/swift_5/#默认参数值)。\n``` swift\nstruct Matrix {\n    let rows: Int, columns: Int\n    var grid: [Double]\n    init(rows: Int, columns: Int) {\n      self.rows = rows\n      self.columns = columns\n      grid = Array(count: rows * columns, repeatedValue: 0.0)\n    }\n    func indexIsValidForRow(row: Int, column: Int) -> Bool {\n        return row >= 0 && row < rows && column >= 0 && column < columns\n    }\n    subscript(row: Int, column: Int) -> Double {\n        get {\n            assert(indexIsValidForRow(row, column: column), \"Index out of range\")\n            return grid[(row * columns) + column]\n        }\n        set {\n            assert(indexIsValidForRow(row, column: column), \"Index out of range\")\n            grid[(row * columns) + column] = newValue\n        }\n    }\n}\n\nvar matrix = Matrix(rows: 2, columns: 2)\nprintln(matrix[0, 1])\n//0.0\nmatrix[0, 1] = 1.5\nprintln(matrix[0, 1])\n//1.5\n```\n","slug":"swift_7","published":1,"updated":"2015-07-23T02:55:00.000Z","_id":"cicflp6j00007r2o3jhf8q58v","comments":1,"layout":"post","photos":[],"link":""},{"title":"Swift基础入门(6)：枚举，类和结构体","date":"2015-07-19T14:47:43.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：枚举，类和结构体的基本概念和语法。\n\n<!--more-->\n**Title: [Swift基础入门(6)：枚举，类和结构体](https://aidaizyy.github.io/swift_6)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-22](http://aidaizyy.github.io)**\n\n# 枚举\n\n## 枚举语法\n枚举定义了一个通用来兴的一组相关的值。\n``` swift\nenum CompassPoint {\n    case North, South\n    case East\n    case West\n}\n```\n`enum`关键字把枚举的整个定义放在大括号中，`CompassPoint`是它的名称。`case`表明新的一行成员值被定义，同一行中可以定义多个成员值，用`,`隔开，这里的成员值为`North`，`South`，`East`，`West`。\n``` swift\nvar directionToHead = CompassPoint.West\ndirectionToHead = .East\n```\n变量的类型经过第一次赋值确定后，再次赋值可省略枚举类型名称，这里`directionToHead`已经被确定为`CompassPoint`的成员值，再次赋值用`.East`的形式就可以了。\n定义的枚举成员是没有值的，不会自动分配值。后面会介绍存储原始值，不仅可以存储整数，也可以存储浮点数字符串等其他类型。\n\n## 成员值\n枚举类型用`switch`匹配时，必须每个成员值都考虑到，否则编译无法通过，可用`default`替代其他成员值。\n``` swift\ndirectionToHead = .South\nswitch directionToHead {\ncase .North:\n    println(\"Lots of planets have a north\")\ncase .South:\n    println(\"Watch out for penguins\")\ncase .East:\n    println(\"Where the sun rises\")\ncase .West:\n    println(\"Where the skies are blue\")\n}\n// 输出 \"Watch out for penguins”\n```\n\n## 相关值\n枚举类型的用法比较像C语言中的联合体（_union_），可以为成员值提供其他类型的相关值，即成员值之外的自定义信息。\n相关值可以是任何类型，每个成员的数据类型也可以不一样。\n``` swift\nenum Barcode {\n  case UPCA(Int, Int, Int)\n  case QRCode(String)\n}\n```\n枚举类型`Barcode`有两个成员值，一个是`UPCA`，它的相关值是`(Int, Int, int)`，一个是`QRCode`，它的相关值是`(String)`\n``` swift\nvar productBarcode = Barcode.UPCA(8, 85909_51226, 3)\nproductBarcode = .QRCode(\"ABCDEFGHIJKLMNOP\")\n```\n\n# 类和结构体\n\n类（_Class_）和结构体（_Struct_）的用法和其他语言类似。\n主要区别在于，类允许继承，而结构体不行；类是引用传递，而结构体是值传递。\n\n``` swift\nstruct Resolution {\n    var width = 0\n    var height = 0\n}\nclass VideoMode {\n    var resolution = Resolution()\n    var interlaced = false\n    var frameRate = 0.0\n    var name: String?\n}\n\nvar someResolution = Resolution(width: 1920, height: 1080)\nlet someVideoMode = VideoMode()\nsomeVideoMode.resolution = someResolution;\nsomeVideoMode.interlaced = true;\nsomeVideoMode.name = \"1080i\"\nsomeVideoMode.frameRate = 25.0\n\nvar otherResolution = someResolution;\nlet otherVideoMode = someVideoMode;\n\nsomeResolution.width = 2048\nprintln(\"someResolution is now  \\(someResolution.width) pixels wide\")\n// 输出 \"someResolution is now 2048 pixels wide\"\nprintln(\"otherResolution is now  \\(otherResolution.width) pixels wide\")\n// 输出 \"otherResolution is now 1920 pixels wide\"\n\nsomeVideoMode.resolution.width = 1280\nprintln(\"The width of someVideoMode is now \\(someVideoMode.resolution.width)\")\n// 输出 \"The width of someVideoMode is now 1280\"\nprintln(\"The width of otherVideoMode is now \\(otherVideoMode.resolution.width)\")\n// 输出 \"The width of otherVideoMode is now 1280\"\n\nif someVideoMode === otherVideoMode {\n    println(\"someVideoMode and otherVideoMode refer to the same VideoMode instance.\")\n}\n//输出 \"someVideoMode and otherVideoMode refer to the same VideoMode instance.\"\n```\n第1-10行是类和结构体的定义，分别用`class`和`struct`表示。\n\n第12-17行是给类和结构体创建实例，并赋值。\n结构体可以在构造时逐一初始化成员，`(width: 1920, height: 1080)`，而类不可以。\n\n第19-20行，分别用类和结构体的实例去赋值变量或常量。\n\n第22-26行，变量`otherResolution`被结构体`someResolution`赋值时采用的是值传递，因此相互是独立的，只是成员值一样。\n改变了`someResolutin`的属性`width`的值后，`otherResolution`并未受到影响。\n\n第28-32行，常量`otherVideoMode`被类`otherVideoMode`赋值时采用的是引用传递，指向的是同一个对象。\n改变了`someVideoMode`的属性`reoulution.width`的值后，`otherVideoMode`的相应属性也随之变化。\n`someVideoMode`和`otherVideoMode`被声明为常量,也可以改变其中的成员属性：\n因为他们都不存储实例，只存储了引用对象，没有改变引用对象，只改变了被引用的基础`VideoMode`的成员属性。\nSwift中，几乎所有的基本类型，包括字符串，数组和字典等都是值传递。\n\n第34-37行，因为两者指向同一对象，不仅仅是成员值相等的关系了，`==`等于符号并不足以描述这样的关系。\n`====`恒等运算符用来形容两者指向同一对象，表示两个实例等价。\n\n枚举，类和结构体的其他特性，参见：\n[Swift基础入门(7)：属性，方法和下标脚注](http://aidaizyy.github.io/swift_7)\n[Swift基础入门(8)：继承，构造过程和析构过程](http://aidaizyy.github.io/swift_8)\n","source":"_posts/swift_6.md","raw":"title: \"Swift基础入门(6)：枚举，类和结构体\"\ndate: 2015-07-19 22:47:43\ntags:\n- swift\ncategories: swift \ntoc: true\n---\n\n本篇介绍Swift的基础知识：枚举，类和结构体的基本概念和语法。\n\n<!--more-->\n**Title: [Swift基础入门(6)：枚举，类和结构体](https://aidaizyy.github.io/swift_6)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-22](http://aidaizyy.github.io)**\n\n# 枚举\n\n## 枚举语法\n枚举定义了一个通用来兴的一组相关的值。\n``` swift\nenum CompassPoint {\n    case North, South\n    case East\n    case West\n}\n```\n`enum`关键字把枚举的整个定义放在大括号中，`CompassPoint`是它的名称。`case`表明新的一行成员值被定义，同一行中可以定义多个成员值，用`,`隔开，这里的成员值为`North`，`South`，`East`，`West`。\n``` swift\nvar directionToHead = CompassPoint.West\ndirectionToHead = .East\n```\n变量的类型经过第一次赋值确定后，再次赋值可省略枚举类型名称，这里`directionToHead`已经被确定为`CompassPoint`的成员值，再次赋值用`.East`的形式就可以了。\n定义的枚举成员是没有值的，不会自动分配值。后面会介绍存储原始值，不仅可以存储整数，也可以存储浮点数字符串等其他类型。\n\n## 成员值\n枚举类型用`switch`匹配时，必须每个成员值都考虑到，否则编译无法通过，可用`default`替代其他成员值。\n``` swift\ndirectionToHead = .South\nswitch directionToHead {\ncase .North:\n    println(\"Lots of planets have a north\")\ncase .South:\n    println(\"Watch out for penguins\")\ncase .East:\n    println(\"Where the sun rises\")\ncase .West:\n    println(\"Where the skies are blue\")\n}\n// 输出 \"Watch out for penguins”\n```\n\n## 相关值\n枚举类型的用法比较像C语言中的联合体（_union_），可以为成员值提供其他类型的相关值，即成员值之外的自定义信息。\n相关值可以是任何类型，每个成员的数据类型也可以不一样。\n``` swift\nenum Barcode {\n  case UPCA(Int, Int, Int)\n  case QRCode(String)\n}\n```\n枚举类型`Barcode`有两个成员值，一个是`UPCA`，它的相关值是`(Int, Int, int)`，一个是`QRCode`，它的相关值是`(String)`\n``` swift\nvar productBarcode = Barcode.UPCA(8, 85909_51226, 3)\nproductBarcode = .QRCode(\"ABCDEFGHIJKLMNOP\")\n```\n\n# 类和结构体\n\n类（_Class_）和结构体（_Struct_）的用法和其他语言类似。\n主要区别在于，类允许继承，而结构体不行；类是引用传递，而结构体是值传递。\n\n``` swift\nstruct Resolution {\n    var width = 0\n    var height = 0\n}\nclass VideoMode {\n    var resolution = Resolution()\n    var interlaced = false\n    var frameRate = 0.0\n    var name: String?\n}\n\nvar someResolution = Resolution(width: 1920, height: 1080)\nlet someVideoMode = VideoMode()\nsomeVideoMode.resolution = someResolution;\nsomeVideoMode.interlaced = true;\nsomeVideoMode.name = \"1080i\"\nsomeVideoMode.frameRate = 25.0\n\nvar otherResolution = someResolution;\nlet otherVideoMode = someVideoMode;\n\nsomeResolution.width = 2048\nprintln(\"someResolution is now  \\(someResolution.width) pixels wide\")\n// 输出 \"someResolution is now 2048 pixels wide\"\nprintln(\"otherResolution is now  \\(otherResolution.width) pixels wide\")\n// 输出 \"otherResolution is now 1920 pixels wide\"\n\nsomeVideoMode.resolution.width = 1280\nprintln(\"The width of someVideoMode is now \\(someVideoMode.resolution.width)\")\n// 输出 \"The width of someVideoMode is now 1280\"\nprintln(\"The width of otherVideoMode is now \\(otherVideoMode.resolution.width)\")\n// 输出 \"The width of otherVideoMode is now 1280\"\n\nif someVideoMode === otherVideoMode {\n    println(\"someVideoMode and otherVideoMode refer to the same VideoMode instance.\")\n}\n//输出 \"someVideoMode and otherVideoMode refer to the same VideoMode instance.\"\n```\n第1-10行是类和结构体的定义，分别用`class`和`struct`表示。\n\n第12-17行是给类和结构体创建实例，并赋值。\n结构体可以在构造时逐一初始化成员，`(width: 1920, height: 1080)`，而类不可以。\n\n第19-20行，分别用类和结构体的实例去赋值变量或常量。\n\n第22-26行，变量`otherResolution`被结构体`someResolution`赋值时采用的是值传递，因此相互是独立的，只是成员值一样。\n改变了`someResolutin`的属性`width`的值后，`otherResolution`并未受到影响。\n\n第28-32行，常量`otherVideoMode`被类`otherVideoMode`赋值时采用的是引用传递，指向的是同一个对象。\n改变了`someVideoMode`的属性`reoulution.width`的值后，`otherVideoMode`的相应属性也随之变化。\n`someVideoMode`和`otherVideoMode`被声明为常量,也可以改变其中的成员属性：\n因为他们都不存储实例，只存储了引用对象，没有改变引用对象，只改变了被引用的基础`VideoMode`的成员属性。\nSwift中，几乎所有的基本类型，包括字符串，数组和字典等都是值传递。\n\n第34-37行，因为两者指向同一对象，不仅仅是成员值相等的关系了，`==`等于符号并不足以描述这样的关系。\n`====`恒等运算符用来形容两者指向同一对象，表示两个实例等价。\n\n枚举，类和结构体的其他特性，参见：\n[Swift基础入门(7)：属性，方法和下标脚注](http://aidaizyy.github.io/swift_7)\n[Swift基础入门(8)：继承，构造过程和析构过程](http://aidaizyy.github.io/swift_8)\n","slug":"swift_6","published":1,"updated":"2015-07-22T15:18:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cicflp6j50009r2o3ew57eity"},{"title":"Swift基础入门(5)：函数和闭包","date":"2015-07-16T09:11:53.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：函数和闭包（Closure）。\n\n<!--more-->\n**Title: [Swift基础入门(5)：函数和闭包](https://aidaizyy.github.io/swift_5)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-22](http://aidaizyy.github.io)**\n\n# 函数\n## 函数原型\n`func functionName(parameters) -> returnType { statements }`\n``` swift\nfunc halfOpenRangeLength(start: Int, end: Int) -> Int {\n    return end - start\n}\nprintln(halfOpenRangeLength(1, 10))\n// prints \"9\"\n```\n函数前必须加标识符`func`，函数名`halfOpenRangeLength`需要传入两个参数`start`和`end`，都是`Int`类型，返回`Int`类型。\n可以没有参数，也可以没有返回值，则写作`func halfOpenRangeLength() { statements }`，`statements`中不带`return`语句。\n\n函数可以有多个返回值，用元组表示返回值。\n``` swift\nfunc count(string: String) -> (vowels: Int, consonants: Int, others: Int) {\n    var vowels = 0, consonants = 0, others = 0\n    for character in string {\n        switch String(character).lowercaseString {\n        case \"a\", \"e\", \"i\", \"o\", \"u\":\n            ++vowels\n        case \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\",\n          \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\":\n            ++consonants\n        default:\n            ++others\n        }\n    }\n    return (vowels, consonants, others)\n}\n\nlet total = count(\"some arbitrary string!\")\nprintln(\"\\(total.vowels) vowels and \\(total.consonants) consonants\")\n// prints \"6 vowels and 13 consonants\"\n```\n`func count(String) -> (Int, Int, Int)`函数，传入一个`String`值，返回一个带3个`Int`值的元组。\n返回的元组成员不需要再命名，因为在函数定义时已经命名了返回元组成员的名称。\n当然也可以不命名，返回类型写作`(Int, Int, Int)`的形式，用`total.0`，`total.1`和`total.2`去获取元组`total`的第1个，第2个和第3个成员的值。\n\n## 函数参数\n\n### 外部参数名\n函数参数的名称作为局部参数名，只能在函数中使用。定义外部参数名，可以在函数外部使用帮助函数参数的意图清晰，`func functionName(externalParameterName localParameterName: dataType) { statements }`。\n注意：但是一旦定义了外部参数名，在函数调用时就**必须使用**。\n外部参数名和局部参数名如果一致，可在局部参数名前加`#`表示，`func functionName(#parameterName: dataType) { statements }`。\n``` swift\nfunc containsCharacter(str string: String, #characterToFind: Character) -> Bool {\n    for character in string {\n        if character == characterToFind {\n            return true\n        }\n    }\n    return false\n}\nlet containsAVee = containsCharacter(str: \"aardvark\", characterToFind: \"v\")\n// containsAVee equals true, because \"aardvark\" contains a \"v”\n```\n\n### 默认参数值\n函数参数可以定义默认值，但必须在函数参数列表的最后。调用时，如果不指定参数的值，则使用默认值。\n定义了默认值的函数参数会自动提供外部参数名，和局部参数名一样，也可以自己提供，如果不使用默认值，则必须在调用时使用外部参数名。\n``` swift\nfunc join(s1: String, s2: String, joiner: String = \" \", flag: String = \"!\") -> String {\n    return s1 + joiner + s2 + flag\n}\n\njoin(\"hello\", \"world\", joiner: \"-\")\n// returns \"hello-world!\"\n```\n第3个参数`joiner`和第四个参数`flag`都是提供了默认参数值，自动提供了外部参数名`joiner`和`flag`，与局部参数名一致。\n`joiner`提供了值，则必须使用参数名`joiner: \"-\"`。\n`flag`使用默认值，则不需要在调用时出现。\n\n### 可变参数\n可变参数（_variadic parameter_）表示不确定数量的输入参数，在参数后加`...`表示。一个函数最多只能有一个可变参数， 且必须是参数列表的最后一个参数。\n``` swift\nfunc arithmeticMean(numbers: Double...) -> Double {\n    var total: Double = 0\n    for number in numbers {\n        total += number\n    }\n    return total / Double(numbers.count)\n}\narithmeticMean(1, 2, 3, 4, 5)\n// returns 3.0, which is the arithmetic mean of these five numbers\narithmeticMean(3, 8, 19)\n// returns 10.0, which is the arithmetic mean of these three numbers\n```\n\n### 变量参数\nSwift的函数参数采用值拷贝传递，传递进去的参数是不能进行修改的，如果我们需要，可以定义变量参数。在参数前加`var`定义变量参数。\n``` swift\nfunc appendCharacter(var string: String, flag: Character) -> String {\n    string.append(flag)\n    return string\n}\nlet originalString = \"hello\"\nlet paddedString = appendCharacter(originalString, \"!\")\n// paddedString is equal to \"hello!\"\n```\n`string`在函数内被修改了，但是作为局部变量，只能在函数内部使用。\n\n### 输入输出参数\nSwift的函数参数不能被修改，使用变量参数修改后也不能传递到外部，采用输入输出参数可以解决这个问题。\n在参数前加`inout`定义输入输出参数。\n- 函数调用时，输入输出参数只能传入变量\n- 输入输出参数不能有默认参数值。\n- 输入输出参数不能是可变参数。\n``` swift\nfunc appendCharacter(inout string: String, flag: Character) {\n    string.append(flag)\n}\nvar originalString = \"hello\"\nappendCharacter(&originalString, \"!\")\n// originalString is equal to \"hello!\"\n```\n`appendCharacter`函数传入参数时，在输入输出参数前必须加`&`前缀。\n\n## 函数类型\n\n函数类型和其他类型一样，可以定义并赋值，如：\n``` swift\nfunc addTwoInts(a: Int, b: Int) -> Int {\n    return a + b\n}\n\nvar mathFunciton1: (Int, Int) -> Int =addTwoInts\n\nvar mathFunciton2 = addTwoInts\t\t//通过赋值自动判断mathFunction类型为函数类型\n\nprintln(\"Result: \\(mathFunction1(2, 3))\")\n// prints \"Result: 5\"\nprintln(\"Result: \\(mathFunction2(2, 3))\")\n// prints \"Result: 5\"\n```\n\n同样函数类型可以作为函数的参数类型和返回类型，形式如`func printMathResult(mathFunction: (Int, Int) -> Int, a: Int, b: Int)`和`func chooseStepFunction(backwards: Bool) -> (Int) -> Int`。前者的一个参数为`mathFunction: (Int, Int) -> Int`，后者的返回`(Int) -> Int`，都没有`func`关键字。\n\n函数也支持嵌套函数，在函数A内部定义的函数B只能在函数A内调用。\n\n# 闭包\n\n## 闭包表达式\n闭包指自包含的函数代码块，可以在代码中被传递和使用。\n函数就是特殊的闭包。\n闭包的一般形式：`{ (parameters) -> returnType in statements }\n和函数不同的是，用`in`替代了原本函数的大括号，并在最外层加上大括号。\n``` swift\nfunc backwards(s1: String, s2: String) -> Bool {\n    return s1 > s2\n}\nvar reversed = sorted(names, backwards)\n// reversed 为 [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"]\n```\n`sorted`函数需要两个参数，第一个参数是需要排序的数组，第二个参数是确定排序顺序的闭包函数，传入与数组类型相同的两个值，并返回`Bool`值。如果第二个参数返回`true`则两个数组元素顺序不变；如果第二个参数返回`false`则两个数组元素顺序相反。\n所以闭包函数中定义`return s1 > s2`，如果`s1`大于`s2`顺序不变，如果`s1`不大于`s2`则交换`s1`和`s2`的顺序，使值大的元素排在数组的前列，也就是逆序排列。\n就上面的代码改为闭包表达式的形式为：\n``` swift\nreversed = sorted(names, { (s1: String, s2: String) -> Bool in\n    return s1 > s2\n})\n```\n用闭包表达式代替了闭包函数，`in`替换函数的大括号，并在外层添加大括号。\n\n闭包表达式的参数类型由第一个参数数组元素的类型决定，返回类型确定为`Bool`型，创建闭包时可以省略已知的信息：\n``` swift\nreversed = sorted(names, { s1, s2 in return s1 > s2 })\n```\n闭包表达式中，如果只有单行表达式，比如`return s1 > s2`一行，可以省略`return`关键字：\n``` swift\nreversed = sorted(names, { s1, s2 in s1 > s2 })\n```\n闭包表达式的参数名称可以缩写成$0，$1，$2等，来顺序调用闭包参数：\n``` swift\nreversed = sorted(names, { $0 > $1 })\n```\n另外，还可以用运算符函数（operator function）使闭包表达式更简短。因为`>`的定义就是接收两个参数，并返回`Bool`类型值，所以可以写：\n``` swift\nreversed = sorted(names, >)\n```\n尾随闭包（trailing closure）：如果闭包表达是是函数的最后一个参数，可以把闭包放到函数的小括号后面，增强可读性：\n``` swift\nreversed = sorted(names, { $0 > $1 })\t//闭包表达式\n\nreversed = sorted(names) { $0 > $1 }\t//尾随闭包\n```\n如果闭包很长，尾随闭包就会非常有用。\n如果函数中只有闭包一个参数，则可以省略小括号，写成`reversed = sorted { $0 < $1 }`的形式。\n\n## 嵌套函数\n嵌套函数是最简单的闭包形式。嵌套函数可以捕获外部函数的参数和定义的常量变量。\n``` swift\nfunc makeIncrementor(forIncrement amount: Int) -> () -> Int {\n    var runningTotal = 0\n    func incrementor() -> Int {\n        runningTotal += amount\n        return runningTotal\n    }\n    return incrementor\n}\n```\n`incrementor`函数调用的`amount`是外部函数的参数，捕获并存储了副本；`runningTotal`会被修改，所以不可以是副本，而是捕获了一个引用，就算外部函数结束都不会消失。Swift会自动决定捕获引用还是副本。\n``` swift\nlet incrementByTen = makeIncrementor(forIncrement: 10)\n\nincrementByTen()\n// 返回的值为10\nincrementByTen()\n// 返回的值为20\nincrementByTen()\n// 返回的值为30\n\nlet incrementBySeven = makeIncrementor(forIncrement: 7)\nincrementBySeven()\n// 返回的值为7\nincrementByTen()\n// 返回的值为40\n```\n`incrementByTen`创建时，`runningTotal`也创建了，每调用一次函数其值就会增加10。\n`incremetnBySeven`创建时，一个新的`runningTotal`也创建了，每调用一次函数其值就会增加7。这个变量和`incrementByTen`中的变量没有任何关系，互不干扰。\n\n注意：无论是函数还是闭包，在赋值给常量或变量时都是**引用拷贝**，指向的是同一个函数/闭包对象。\n","source":"_posts/swift_5.md","raw":"title: \"Swift基础入门(5)：函数和闭包\"\ndate: 2015-07-16 17:11:53\ntags:\n- swift\ncategories: swift\ntoc: true\n---\n\n本篇介绍Swift的基础知识：函数和闭包（Closure）。\n\n<!--more-->\n**Title: [Swift基础入门(5)：函数和闭包](https://aidaizyy.github.io/swift_5)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-22](http://aidaizyy.github.io)**\n\n# 函数\n## 函数原型\n`func functionName(parameters) -> returnType { statements }`\n``` swift\nfunc halfOpenRangeLength(start: Int, end: Int) -> Int {\n    return end - start\n}\nprintln(halfOpenRangeLength(1, 10))\n// prints \"9\"\n```\n函数前必须加标识符`func`，函数名`halfOpenRangeLength`需要传入两个参数`start`和`end`，都是`Int`类型，返回`Int`类型。\n可以没有参数，也可以没有返回值，则写作`func halfOpenRangeLength() { statements }`，`statements`中不带`return`语句。\n\n函数可以有多个返回值，用元组表示返回值。\n``` swift\nfunc count(string: String) -> (vowels: Int, consonants: Int, others: Int) {\n    var vowels = 0, consonants = 0, others = 0\n    for character in string {\n        switch String(character).lowercaseString {\n        case \"a\", \"e\", \"i\", \"o\", \"u\":\n            ++vowels\n        case \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\",\n          \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\":\n            ++consonants\n        default:\n            ++others\n        }\n    }\n    return (vowels, consonants, others)\n}\n\nlet total = count(\"some arbitrary string!\")\nprintln(\"\\(total.vowels) vowels and \\(total.consonants) consonants\")\n// prints \"6 vowels and 13 consonants\"\n```\n`func count(String) -> (Int, Int, Int)`函数，传入一个`String`值，返回一个带3个`Int`值的元组。\n返回的元组成员不需要再命名，因为在函数定义时已经命名了返回元组成员的名称。\n当然也可以不命名，返回类型写作`(Int, Int, Int)`的形式，用`total.0`，`total.1`和`total.2`去获取元组`total`的第1个，第2个和第3个成员的值。\n\n## 函数参数\n\n### 外部参数名\n函数参数的名称作为局部参数名，只能在函数中使用。定义外部参数名，可以在函数外部使用帮助函数参数的意图清晰，`func functionName(externalParameterName localParameterName: dataType) { statements }`。\n注意：但是一旦定义了外部参数名，在函数调用时就**必须使用**。\n外部参数名和局部参数名如果一致，可在局部参数名前加`#`表示，`func functionName(#parameterName: dataType) { statements }`。\n``` swift\nfunc containsCharacter(str string: String, #characterToFind: Character) -> Bool {\n    for character in string {\n        if character == characterToFind {\n            return true\n        }\n    }\n    return false\n}\nlet containsAVee = containsCharacter(str: \"aardvark\", characterToFind: \"v\")\n// containsAVee equals true, because \"aardvark\" contains a \"v”\n```\n\n### 默认参数值\n函数参数可以定义默认值，但必须在函数参数列表的最后。调用时，如果不指定参数的值，则使用默认值。\n定义了默认值的函数参数会自动提供外部参数名，和局部参数名一样，也可以自己提供，如果不使用默认值，则必须在调用时使用外部参数名。\n``` swift\nfunc join(s1: String, s2: String, joiner: String = \" \", flag: String = \"!\") -> String {\n    return s1 + joiner + s2 + flag\n}\n\njoin(\"hello\", \"world\", joiner: \"-\")\n// returns \"hello-world!\"\n```\n第3个参数`joiner`和第四个参数`flag`都是提供了默认参数值，自动提供了外部参数名`joiner`和`flag`，与局部参数名一致。\n`joiner`提供了值，则必须使用参数名`joiner: \"-\"`。\n`flag`使用默认值，则不需要在调用时出现。\n\n### 可变参数\n可变参数（_variadic parameter_）表示不确定数量的输入参数，在参数后加`...`表示。一个函数最多只能有一个可变参数， 且必须是参数列表的最后一个参数。\n``` swift\nfunc arithmeticMean(numbers: Double...) -> Double {\n    var total: Double = 0\n    for number in numbers {\n        total += number\n    }\n    return total / Double(numbers.count)\n}\narithmeticMean(1, 2, 3, 4, 5)\n// returns 3.0, which is the arithmetic mean of these five numbers\narithmeticMean(3, 8, 19)\n// returns 10.0, which is the arithmetic mean of these three numbers\n```\n\n### 变量参数\nSwift的函数参数采用值拷贝传递，传递进去的参数是不能进行修改的，如果我们需要，可以定义变量参数。在参数前加`var`定义变量参数。\n``` swift\nfunc appendCharacter(var string: String, flag: Character) -> String {\n    string.append(flag)\n    return string\n}\nlet originalString = \"hello\"\nlet paddedString = appendCharacter(originalString, \"!\")\n// paddedString is equal to \"hello!\"\n```\n`string`在函数内被修改了，但是作为局部变量，只能在函数内部使用。\n\n### 输入输出参数\nSwift的函数参数不能被修改，使用变量参数修改后也不能传递到外部，采用输入输出参数可以解决这个问题。\n在参数前加`inout`定义输入输出参数。\n- 函数调用时，输入输出参数只能传入变量\n- 输入输出参数不能有默认参数值。\n- 输入输出参数不能是可变参数。\n``` swift\nfunc appendCharacter(inout string: String, flag: Character) {\n    string.append(flag)\n}\nvar originalString = \"hello\"\nappendCharacter(&originalString, \"!\")\n// originalString is equal to \"hello!\"\n```\n`appendCharacter`函数传入参数时，在输入输出参数前必须加`&`前缀。\n\n## 函数类型\n\n函数类型和其他类型一样，可以定义并赋值，如：\n``` swift\nfunc addTwoInts(a: Int, b: Int) -> Int {\n    return a + b\n}\n\nvar mathFunciton1: (Int, Int) -> Int =addTwoInts\n\nvar mathFunciton2 = addTwoInts\t\t//通过赋值自动判断mathFunction类型为函数类型\n\nprintln(\"Result: \\(mathFunction1(2, 3))\")\n// prints \"Result: 5\"\nprintln(\"Result: \\(mathFunction2(2, 3))\")\n// prints \"Result: 5\"\n```\n\n同样函数类型可以作为函数的参数类型和返回类型，形式如`func printMathResult(mathFunction: (Int, Int) -> Int, a: Int, b: Int)`和`func chooseStepFunction(backwards: Bool) -> (Int) -> Int`。前者的一个参数为`mathFunction: (Int, Int) -> Int`，后者的返回`(Int) -> Int`，都没有`func`关键字。\n\n函数也支持嵌套函数，在函数A内部定义的函数B只能在函数A内调用。\n\n# 闭包\n\n## 闭包表达式\n闭包指自包含的函数代码块，可以在代码中被传递和使用。\n函数就是特殊的闭包。\n闭包的一般形式：`{ (parameters) -> returnType in statements }\n和函数不同的是，用`in`替代了原本函数的大括号，并在最外层加上大括号。\n``` swift\nfunc backwards(s1: String, s2: String) -> Bool {\n    return s1 > s2\n}\nvar reversed = sorted(names, backwards)\n// reversed 为 [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"]\n```\n`sorted`函数需要两个参数，第一个参数是需要排序的数组，第二个参数是确定排序顺序的闭包函数，传入与数组类型相同的两个值，并返回`Bool`值。如果第二个参数返回`true`则两个数组元素顺序不变；如果第二个参数返回`false`则两个数组元素顺序相反。\n所以闭包函数中定义`return s1 > s2`，如果`s1`大于`s2`顺序不变，如果`s1`不大于`s2`则交换`s1`和`s2`的顺序，使值大的元素排在数组的前列，也就是逆序排列。\n就上面的代码改为闭包表达式的形式为：\n``` swift\nreversed = sorted(names, { (s1: String, s2: String) -> Bool in\n    return s1 > s2\n})\n```\n用闭包表达式代替了闭包函数，`in`替换函数的大括号，并在外层添加大括号。\n\n闭包表达式的参数类型由第一个参数数组元素的类型决定，返回类型确定为`Bool`型，创建闭包时可以省略已知的信息：\n``` swift\nreversed = sorted(names, { s1, s2 in return s1 > s2 })\n```\n闭包表达式中，如果只有单行表达式，比如`return s1 > s2`一行，可以省略`return`关键字：\n``` swift\nreversed = sorted(names, { s1, s2 in s1 > s2 })\n```\n闭包表达式的参数名称可以缩写成$0，$1，$2等，来顺序调用闭包参数：\n``` swift\nreversed = sorted(names, { $0 > $1 })\n```\n另外，还可以用运算符函数（operator function）使闭包表达式更简短。因为`>`的定义就是接收两个参数，并返回`Bool`类型值，所以可以写：\n``` swift\nreversed = sorted(names, >)\n```\n尾随闭包（trailing closure）：如果闭包表达是是函数的最后一个参数，可以把闭包放到函数的小括号后面，增强可读性：\n``` swift\nreversed = sorted(names, { $0 > $1 })\t//闭包表达式\n\nreversed = sorted(names) { $0 > $1 }\t//尾随闭包\n```\n如果闭包很长，尾随闭包就会非常有用。\n如果函数中只有闭包一个参数，则可以省略小括号，写成`reversed = sorted { $0 < $1 }`的形式。\n\n## 嵌套函数\n嵌套函数是最简单的闭包形式。嵌套函数可以捕获外部函数的参数和定义的常量变量。\n``` swift\nfunc makeIncrementor(forIncrement amount: Int) -> () -> Int {\n    var runningTotal = 0\n    func incrementor() -> Int {\n        runningTotal += amount\n        return runningTotal\n    }\n    return incrementor\n}\n```\n`incrementor`函数调用的`amount`是外部函数的参数，捕获并存储了副本；`runningTotal`会被修改，所以不可以是副本，而是捕获了一个引用，就算外部函数结束都不会消失。Swift会自动决定捕获引用还是副本。\n``` swift\nlet incrementByTen = makeIncrementor(forIncrement: 10)\n\nincrementByTen()\n// 返回的值为10\nincrementByTen()\n// 返回的值为20\nincrementByTen()\n// 返回的值为30\n\nlet incrementBySeven = makeIncrementor(forIncrement: 7)\nincrementBySeven()\n// 返回的值为7\nincrementByTen()\n// 返回的值为40\n```\n`incrementByTen`创建时，`runningTotal`也创建了，每调用一次函数其值就会增加10。\n`incremetnBySeven`创建时，一个新的`runningTotal`也创建了，每调用一次函数其值就会增加7。这个变量和`incrementByTen`中的变量没有任何关系，互不干扰。\n\n注意：无论是函数还是闭包，在赋值给常量或变量时都是**引用拷贝**，指向的是同一个函数/闭包对象。\n","slug":"swift_5","published":1,"updated":"2015-07-22T15:15:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cicflp6j7000cr2o3odb1lp7d"},{"title":"Swift基础入门(4)：条件与循环语句","date":"2015-07-16T06:36:11.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：条件语句和循环语句。\n\n<!--more-->\n**Title: [Swift基础入门(4)：条件与循环语句](https://aidaizyy.github.io/swift_4)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-16](http://aidaizyy.github.io)**\n\n# 循环语句\n\n## for-in循环\n``` swift\nfor index in 1...5 {\n\tprintln(index)\n}\n//1\n//2\n//3\n//4\n//5\n```\n`for-in`循环可用于区间。\n``` swift\nvar res = 1\nfor _ in 1...5 {\n\tres *= 2\n\tprintln(res)\n}\n//2\n//4\n//8\n//16\n//32\n```\n如果不需要区间中每项的值，可以用`_`替代。\n`for-in`用于字符串，请见[Swift基础入门(2)](http://aidaizyy.github.io/swift_2)。\n`for-in`用于数组集合字典，请见[Swift基础入门(3)](http://aidaizyy.github.io/swift_3)。\n\n## for循环\n`for`循环和C语言一致，格式为`for initialization; condition; increment { statements }`，区别在于没有括号。\n\n## while循环\n`while`循环和C语言一致，格式为`while condition { statements }`，区别在于没有括号。\n\n## do-while循环\n`do-while`循环和C语言一致，格式为`do { statements } while condition`，区别在于没有括号。\n\n# 条件语句\n\n## if语句\n`if`语句和C语言一直，格式为`if condition { statements } else if condition { statements } else { statesments },区别在于没有括号，`else if`和`else`不是必须存在。\n\n## switch语句\n``` swift\nlet count = 300\nvar naturalCount: String\nswitch count {\ncase 0:\n    naturalCount = \"no\"\ncase 1...3:\n    naturalCount = \"a few\"\ncase 4...9:\n    naturalCount = \"several\"\ncase 10...99:\n    naturalCount = \"tens of\"\ncase 100...999:\n    naturalCount = \"hundreds of\"\ncase 1000...999_999:\n    naturalCount = \"thousands of\"\ndefault:\n    naturalCount = \"millions and millions of\"\n}\nprintln(\"There are \\(naturalCount) stars in the Milky Way.\")\n// 输出 \"There are hundreds of stars in the Milk Way.\"\n```\n在C语言中，通常使用`break`，避免执行了一个`case`语句后继续执行下一个`case`语句。在Swift语言中不需要添加`break`，`switch`语句只执行最前面一个符合条件的`case`语句。\n`case`语句可以接类似于`1...3`的区间。\n`case`语句可以接多个情况，用逗号隔开，`switch value { case value1, value2: statements }`\n\n## 元组\n``` swift\nlet somePoint = (1, 1)\nswitch somePoint {\ncase (0, 0):\n    println(\"(0, 0) is at the origin\")\ncase (_, 0):\n    println(\"(\\(somePoint.0), 0) is on the x-axis\")\ncase (0, _):\n    println(\"(0, \\(somePoint.1)) is on the y-axis\")\ncase (-2...2, -2...2):\n    println(\"(\\(somePoint.0), \\(somePoint.1)) is inside the box\")\ndefault:\n    println(\"(\\(somePoint.0), \\(somePoint.1)) is outside of the box\")\n}\n// 输出 \"(1, 1) is inside the box\"\n``` \n元组也可以用来判断条件，`_`用来匹配所有可能的值，也就是需要忽略的值。\n\n## 值绑定\n``` swift\nlet anotherPoint = (2, 0)\nswitch anotherPoint {\ncase (let x, 0):\n    println(\"on the x-axis with an x value of \\(x)\")\ncase (0, let y):\n    println(\"on the y-axis with a y value of \\(y)\")\ncase let (x, y):\n    println(\"somewhere else at (\\(x), \\(y))\")\n}\n```\n`case`语句中，可以用临时的常量变量去绑定值并使用。\n\n## 额外条件（Where语句）\n``` swift\nlet yetAnotherPoint = (1, -1)\nswitch yetAnotherPoint {\ncase let (x, y) where x == y:\n    println(\"(\\(x), \\(y)) is on the line x == y\")\ncase let (x, y) where x == -y:\n    println(\"(\\(x), \\(y)) is on the line x == -y\")\ncase let (x, y):\n    println(\"(\\(x), \\(y)) is just some arbitrary point\")\n}\n// 输出 \"(1, -1) is on the line x == -y\"\n```\n`case`语句中可以使用`where`语句跟在条件后作为额外的补充条件，需要同时满足两个条件才可以执行。\n\n# 控制转移语句\nSwift一共有四种控制转移语句：\n-continue\n-break\n-fallthrough\n-return\n\n`continue`，`break`和`return`用法和C语言基本一致。\n在`switch`语句中，`continue`和`break`都针对整个`switch`语句，而不是C语言中的一个`case`语句。遇到`break`后直接退出整个`switch`语句，而不是判断下一个`case`，`continue`同理。\n\n## 贯穿语句（Fallthrough语句）\n``` swift\nlet integerToDescribe = 5\nvar description = \"The number \\(integerToDescribe) is\"\nswitch integerToDescribe {\ncase 2, 3, 5, 7, 11, 13, 17, 19:\n    description += \" a prime number, and also\"\n    fallthrough\ndefault:\n    description += \" an integer.\"\n}\nprintln(description)\n// 输出 \"The number 5 is a prime number, and also an integer.\"\n```\nSwift语言不支持在`switch`语句中贯穿多个`case`语句的情况，但有时我们需要这么做。这时我们可以加上关键字`fallthrough`，当遇到`fallthrough`时，就会继续执行下一个`case`语句。\n注意：遇到`fallthrough`时会直接**执行**下一个`case`语句，而不是去**判断**条件。\n\n## 精确控制转移\nSwift语言中可以让`break`和`continue`精确地表示针对哪一个循环或条件语句，这称为带标签的语句（_Labeled Statements_）。\n`label name: while condition { statements }`，之后再执行`break label name`或`continue label name`。 \n``` swift\n//求第一个质数\nloop: for integer in 1...10 {\n    switch integer {\n    case 2, 3, 5, 7, 11, 13, 17, 19:\n        println(\"\\(integer) is a prime number\")\n        break loop\n    default:\n        println(\"\\(integer) is not a prime number\")\n    }\n}\n```\n上面代码中，给`for-in`循环指定了标签`loop`，我们要求得到第一个质数，所以当遇到质数后用`break loop`结束循环。如果不加标签，`break`只能结束`switch`语句，会继续执行循环，不能达到目的。\n","source":"_posts/swift_4.md","raw":"title: \"Swift基础入门(4)：条件与循环语句\"\ndate: 2015-07-16 14:36:11\ntags:\n- swift\ncategories: swift \ntoc: true\n---\n\n本篇介绍Swift的基础知识：条件语句和循环语句。\n\n<!--more-->\n**Title: [Swift基础入门(4)：条件与循环语句](https://aidaizyy.github.io/swift_4)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-16](http://aidaizyy.github.io)**\n\n# 循环语句\n\n## for-in循环\n``` swift\nfor index in 1...5 {\n\tprintln(index)\n}\n//1\n//2\n//3\n//4\n//5\n```\n`for-in`循环可用于区间。\n``` swift\nvar res = 1\nfor _ in 1...5 {\n\tres *= 2\n\tprintln(res)\n}\n//2\n//4\n//8\n//16\n//32\n```\n如果不需要区间中每项的值，可以用`_`替代。\n`for-in`用于字符串，请见[Swift基础入门(2)](http://aidaizyy.github.io/swift_2)。\n`for-in`用于数组集合字典，请见[Swift基础入门(3)](http://aidaizyy.github.io/swift_3)。\n\n## for循环\n`for`循环和C语言一致，格式为`for initialization; condition; increment { statements }`，区别在于没有括号。\n\n## while循环\n`while`循环和C语言一致，格式为`while condition { statements }`，区别在于没有括号。\n\n## do-while循环\n`do-while`循环和C语言一致，格式为`do { statements } while condition`，区别在于没有括号。\n\n# 条件语句\n\n## if语句\n`if`语句和C语言一直，格式为`if condition { statements } else if condition { statements } else { statesments },区别在于没有括号，`else if`和`else`不是必须存在。\n\n## switch语句\n``` swift\nlet count = 300\nvar naturalCount: String\nswitch count {\ncase 0:\n    naturalCount = \"no\"\ncase 1...3:\n    naturalCount = \"a few\"\ncase 4...9:\n    naturalCount = \"several\"\ncase 10...99:\n    naturalCount = \"tens of\"\ncase 100...999:\n    naturalCount = \"hundreds of\"\ncase 1000...999_999:\n    naturalCount = \"thousands of\"\ndefault:\n    naturalCount = \"millions and millions of\"\n}\nprintln(\"There are \\(naturalCount) stars in the Milky Way.\")\n// 输出 \"There are hundreds of stars in the Milk Way.\"\n```\n在C语言中，通常使用`break`，避免执行了一个`case`语句后继续执行下一个`case`语句。在Swift语言中不需要添加`break`，`switch`语句只执行最前面一个符合条件的`case`语句。\n`case`语句可以接类似于`1...3`的区间。\n`case`语句可以接多个情况，用逗号隔开，`switch value { case value1, value2: statements }`\n\n## 元组\n``` swift\nlet somePoint = (1, 1)\nswitch somePoint {\ncase (0, 0):\n    println(\"(0, 0) is at the origin\")\ncase (_, 0):\n    println(\"(\\(somePoint.0), 0) is on the x-axis\")\ncase (0, _):\n    println(\"(0, \\(somePoint.1)) is on the y-axis\")\ncase (-2...2, -2...2):\n    println(\"(\\(somePoint.0), \\(somePoint.1)) is inside the box\")\ndefault:\n    println(\"(\\(somePoint.0), \\(somePoint.1)) is outside of the box\")\n}\n// 输出 \"(1, 1) is inside the box\"\n``` \n元组也可以用来判断条件，`_`用来匹配所有可能的值，也就是需要忽略的值。\n\n## 值绑定\n``` swift\nlet anotherPoint = (2, 0)\nswitch anotherPoint {\ncase (let x, 0):\n    println(\"on the x-axis with an x value of \\(x)\")\ncase (0, let y):\n    println(\"on the y-axis with a y value of \\(y)\")\ncase let (x, y):\n    println(\"somewhere else at (\\(x), \\(y))\")\n}\n```\n`case`语句中，可以用临时的常量变量去绑定值并使用。\n\n## 额外条件（Where语句）\n``` swift\nlet yetAnotherPoint = (1, -1)\nswitch yetAnotherPoint {\ncase let (x, y) where x == y:\n    println(\"(\\(x), \\(y)) is on the line x == y\")\ncase let (x, y) where x == -y:\n    println(\"(\\(x), \\(y)) is on the line x == -y\")\ncase let (x, y):\n    println(\"(\\(x), \\(y)) is just some arbitrary point\")\n}\n// 输出 \"(1, -1) is on the line x == -y\"\n```\n`case`语句中可以使用`where`语句跟在条件后作为额外的补充条件，需要同时满足两个条件才可以执行。\n\n# 控制转移语句\nSwift一共有四种控制转移语句：\n-continue\n-break\n-fallthrough\n-return\n\n`continue`，`break`和`return`用法和C语言基本一致。\n在`switch`语句中，`continue`和`break`都针对整个`switch`语句，而不是C语言中的一个`case`语句。遇到`break`后直接退出整个`switch`语句，而不是判断下一个`case`，`continue`同理。\n\n## 贯穿语句（Fallthrough语句）\n``` swift\nlet integerToDescribe = 5\nvar description = \"The number \\(integerToDescribe) is\"\nswitch integerToDescribe {\ncase 2, 3, 5, 7, 11, 13, 17, 19:\n    description += \" a prime number, and also\"\n    fallthrough\ndefault:\n    description += \" an integer.\"\n}\nprintln(description)\n// 输出 \"The number 5 is a prime number, and also an integer.\"\n```\nSwift语言不支持在`switch`语句中贯穿多个`case`语句的情况，但有时我们需要这么做。这时我们可以加上关键字`fallthrough`，当遇到`fallthrough`时，就会继续执行下一个`case`语句。\n注意：遇到`fallthrough`时会直接**执行**下一个`case`语句，而不是去**判断**条件。\n\n## 精确控制转移\nSwift语言中可以让`break`和`continue`精确地表示针对哪一个循环或条件语句，这称为带标签的语句（_Labeled Statements_）。\n`label name: while condition { statements }`，之后再执行`break label name`或`continue label name`。 \n``` swift\n//求第一个质数\nloop: for integer in 1...10 {\n    switch integer {\n    case 2, 3, 5, 7, 11, 13, 17, 19:\n        println(\"\\(integer) is a prime number\")\n        break loop\n    default:\n        println(\"\\(integer) is not a prime number\")\n    }\n}\n```\n上面代码中，给`for-in`循环指定了标签`loop`，我们要求得到第一个质数，所以当遇到质数后用`break loop`结束循环。如果不加标签，`break`只能结束`switch`语句，会继续执行循环，不能达到目的。\n","slug":"swift_4","published":1,"updated":"2015-07-21T08:52:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cicflp6j9000fr2o388lhug9w"},{"title":"Swift基础入门(3)：数组，集合和字典","date":"2015-07-15T09:04:30.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：数组（Array），集合（Set）和字符（Dictionary）。\n\n<!--more-->\n**Title: [Swift基础入门(3)：数组，集合和字典](https://aidaizyy.github.io/swift_3)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-16](http://aidaizyy.github.io)**\n\n# 数组\n\n## 构造\n``` swift\nvar shoppinglist = [\"Eggs\", \"Milk\"]\t//初始化为字符串数组，没有指定数据类型，通过添加数据自动判断为String数组\n\nvar someInts1 = [2, 3]\nvar someInts2: [Int] = [2, 3]\t\t//等价于上一句，初始化为整数数组，指定了数据类型Int，只能添加Int数据，并添加了元素2，3\nvar someInts3: Array<Int> = [2, 3]\t//等价于上一句\n\nvar someInts4 = Array<Int>()\t\t//初始化为整数数组，指定了数据类型Int，只能添加Int数据，没有添加元素\nvar someInts5 = [Int]()\t\t\t//等价于上一句\n\nvar someDoubles = []\t\t\t//初始化为空数组，没有指定数据类型，通过添加数据自动判断\nsomeDoubles.append(2.3)\t\t\t//通过添加数据自动判断为Double数组\n\nvar threeDoubles = [Double](count: 3, repeatedValue: 0.0)\n//(count: , repeatedValue: )形式，指定了重复的值和重复的次数，构造数组{0.0, 0.0, 0.0}\n```\n数组的元素只能有一种数据类型。\n\n## 数量\n- Array.count：属性`count`表示数组`Array`的元素个数。\n- Array.isEmpty：属性`isEmpty`表示数组`Array`的元素是否为0个，结果为`true`或`false`。\n\n## 访问\n- Array[i]：通过下标`[i]`访问数组`Array`的第`i`位，可修改。\n\n## 遍历\n``` swift\nvar shoppinglist = [\"Eggs\", \"Milk\"]\nfor item in shoppingList {\n\tprintln(item)\n}\n//Eggs\n//Milk\n```\n\n## 添加\n- Array.append(Item)：将元素`Item`添加到数组`Array`的尾部。\n- Array.imsert(Item, atIndex: i)：将元素`Item`添加到数组`Array`的第`i`位。\n- Array += [Item1, Item2]：将元素`Item1`和`Item2`添加到数组`Array`的尾部。\n\n## 删除\n- Array.removeAtIndex(i)：删除数组`Array`的第`i`位。\n- Array.removeLast()：删除数组`Array`的最后一位。\n\n## 替换\n- Array[m...n] = [Item1, Item2]：用元素`Item1`和`Item2`替换数组`Array`的第`m`位到第`n`位。这种方法不能用于添加新元素。\n\n#  集合\n集合中的元素没有确定顺序，且每个元素只出现一次。\n\n## 构造\n``` swift\nvar shoppinglist: Set = [\"Eggs\", \"Milk\"]\t//初始化为字符串集合，没有指定数据类型，通过添加数据自动判断为String集合\n\nvar someInts1: Set = [2, 3]\t\t\t\nvar someInts2: Set<Int> = [2, 3]\t\t//等价于上一句，初始化为整数集合，指定了数据类型Int，只能添加Int数据，并添加了元素2，3\n\nvar someInts3 = Set<Int>()\t\t\t//初始化为整数集合，指定了数据类型Int，只能添加Int数据，没有添加元素\n\nvar someDoubles: Set = []\t\t\t//初始化为空集合，没有指定数据类型，通过添加数据自动判断\nsomeDoubles.insert(2.3)\t\t\t\t//通过添加数据自动判断为Double集合\n```\n集合的元素只能有一种数据类型。\n\n## 数量\n- Set.count：属性`count`表示集合`Set`的元素个数。\n- Set.isEmpty：属性`isEmpty`表示集合`Set`的元素是否为0个，结果为`true`或`false`。\n\n## 遍历\n``` swift\nvar shoppinglist1: Set = [\"Milk\", \"Eggs\"]\nfor item in shoppingList {\n\tprintln(item)\n}\n//Milk\n//Eggs\n\nvar shoppinglist2: Set = [\"Milk\", \"Eggs\"]\nfor item in sorted(shoppingList) {\n\tprintln(item)\n}\n//Eggs\n//Milk\n```\n因为`Set`中没有确定顺序，可以通过`sorted(Set)`函数返回一个排序的集合。\n\n## 添加\n- Set.imsert(Item)：将元素`Item`添加到集合`Set`中。\n\n## 删除\n- Set.remove(Item)：删除集合`Set`中的元素`Item`，成功则返回`Item`，如果集合中不包含`Item`则返回`nil`。\n- Set.removeAll()：删除集合`Set`中的所有元素\n\n## 包含\n- Set.contains(Item)：检查集合`Set`是否包含元素`Item`，返回`true`或`false`。\n\n## 比较\n``` swift\nlet s1: Set = [1, 2]\nlet s2: Set = [3, 4, 5, 1, 2]\nlet cityAnimals: Set = [6, 7]\ns1.isSubsetOf(s2)\n// true\ns2.isSuperSetOf(s1)\n// true\ns2.isDisjointWith(s3)\n// true\n```\n- ==：判断两个集合是否相等\n- Set1.isSubsetOf(Set2)：判断`Set1`是否是`Set2`的子集\n- Set1.isSupersetOf(Set2)：判断`Set1`是否是`Set2`的父集\n- Set1.isStrictSubsetOf(Set2)，Set1.isStrictSupersetOf(Set2)：和上面方法相似，不过两个集合不能相等。\n- Set1.isDisjoinWith(Set2)：判断`Set1`和`Set2`是否完成没有一个相同元素\n上述方法都返回`true`或`false`。\n\n## 操作\n``` swift\nlet oddDigits: Set = [1, 3, 5, 7, 9]\nlet evenDigits: Set = [0, 2, 4, 6, 8]\nlet singleDigitPrimeNumbers: Set = [2, 3, 5, 7]\nsorted(oddDigits.union(evenDigits))\n// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nsorted(oddDigits.intersect(evenDigits))\n// []\nsorted(oddDigits.subtract(singleDigitPrimeNumbers))\n// [1, 9]\nsorted(oddDigits.exclusiveOr(singleDigitPrimeNumbers))\n// [1, 2, 9]\n```\n- Set1.intersects(Set2)：返回`Set1`和`Set2`的交集，即两个集合中都有的元素\n- Set1.union(Set2)：返回`Set1`和`Set2`的并集，即两个集合中的所有元素\n- Set1.subtract(Set2)：返回`Set1`和`Set2`的差集，即`Set1`中有的且`Set2`中没有的元素\n- Set1.exclusiverOr(Set2)：返回并集减去并集的集合，即`Set1`中独有的和`Set2`中独有的元素，也就是所有元素减去两个集合中都有的元素。\n\n## 哈希值\nSwift中的所有基本类型默认都是可哈希的，通过`a.hashValue`求得哈希值。哈希值相等可以判断对象相同，如`a == b`即`a.hashValue == b.hashValue`。\n\n# 字典\n字典中每个值（_Value_）都关联唯一的建（_key_）。\n\n## 构造\n在构造过程中，键值对默认用`[key 1: value 1, key 2: value 2, key 3: value 3]`的形式。\n``` swift\nvar airports1 = [\"TYO\": \"Tokyo\", \"DUB\": \"Dublin\"]\t\t\t\t//初始化为[String: String]字典，没有指定数据类型，通过添加数据自动判断\nvar airports2: [String: String] = [\"TYO\": \"Tokyo\", \"DUB\": \"Dublin\"]\t\t//等价于上一句\nvar airports3: Dictionary<Stringr, String> = [\"TYO\": \"Tokyo\", \"DUB\": \"Dublin\"]\t//等价于上一句\n\nvar airports4 = Dictionary<String, Sting>()\t//初始化为[Sting: String]空字典，指定了数据类型[String: String]，只能添加[String:String]数据，没有添加元素\nvar airports5 = [String: String]()\t\t//等价于上一句\n\nvar airports6 = [:]\t//初始化为空字典，没有指定数据类型，通过添加数据自动判断\nairports6[2] = 3\t//通过添加数据自动判断为[Int: Int]字典\n```\n\n## 数量\n- Dictionary.count：属性`count`表示字典`Dictionary`的元素个数。\n- Dictionary.isEmpty：属性`isEmpty`表示字典`Dictionary`的元素是否为0个，结果为`true`或`false`。\n\n## 访问\n- Dictionary[key]：通过下标`[key]`访问字典`Dictionary`的键`key`对应的值，可修改。\n\n## 遍历\n``` swift\nfor (airportCode, airportName) in airports {\n    println(\"\\(airportCode): \\(airportName)\")\n}\n// TYO: Tokyo\n// DUB: Dublin\n\nfor airportCode in airports.keys {\n    println(\"Airport code: \\(airportCode)\")\n}\n// Airport code: TYO\n// Airport code: DUB\n\nfor airportName in airports.values {\n    println(\"Airport name: \\(airportName)\")\n}\n// Airport name: Tokyo\n// Airport name: Dublin\n```\n`for-in`可便利字典，可便利键值对`(key, value)`，也可以通过属性`keys`或`values`只便利键值其中一项。\n字典的属性`keys`和`values`返回数组。\n``` swift\nlet airportCodes = Array(airports.keys)\n// airportCodes is [\"TYO\", \"DUB\"]\n\nlet airportNames = Array(airports.values)\n// airportNames is [\"Tokyo\", \"Dublin\"]\n```\n## 添加\n- Dictionary[key] = value：更新字典`Dictionary`中键`key`对应的值，如果不存在，则将键值对<key, valye>添加到字典`Dictionary`中。\n- Dicitonary.updateValue(value, forkey: key)：更新字典`Dictionary`中键`key`对应的值，如果不存在，则将键值对<key, value>添加到字典`Dictionary`。\n注意：该方法返回**原值**，即执行`updateValue`方法之前键`key`对应的值，如果不存在，则返回`nil`。\n\n## 删除\n- Dictionary[key] = nil：删除字典`Dictionary`中键`key`对应的值。\n- Dictionary.removeValueForKey(key)：删除字典`Dictionary`中键`key`对应的值，返回删除的值，如果不存在，则返回`nil`。\n\n添加操作和删除操作返回值有可能为`nil`，都是可选类型，使用时需要进行判断是否有值。\n","source":"_posts/swift_3.md","raw":"title: \"Swift基础入门(3)：数组，集合和字典\"\ndate: 2015-07-15 17:04:30\ntags:\n- swift\ncategories: swift\ntoc: true\n---\n\n本篇介绍Swift的基础知识：数组（Array），集合（Set）和字符（Dictionary）。\n\n<!--more-->\n**Title: [Swift基础入门(3)：数组，集合和字典](https://aidaizyy.github.io/swift_3)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-16](http://aidaizyy.github.io)**\n\n# 数组\n\n## 构造\n``` swift\nvar shoppinglist = [\"Eggs\", \"Milk\"]\t//初始化为字符串数组，没有指定数据类型，通过添加数据自动判断为String数组\n\nvar someInts1 = [2, 3]\nvar someInts2: [Int] = [2, 3]\t\t//等价于上一句，初始化为整数数组，指定了数据类型Int，只能添加Int数据，并添加了元素2，3\nvar someInts3: Array<Int> = [2, 3]\t//等价于上一句\n\nvar someInts4 = Array<Int>()\t\t//初始化为整数数组，指定了数据类型Int，只能添加Int数据，没有添加元素\nvar someInts5 = [Int]()\t\t\t//等价于上一句\n\nvar someDoubles = []\t\t\t//初始化为空数组，没有指定数据类型，通过添加数据自动判断\nsomeDoubles.append(2.3)\t\t\t//通过添加数据自动判断为Double数组\n\nvar threeDoubles = [Double](count: 3, repeatedValue: 0.0)\n//(count: , repeatedValue: )形式，指定了重复的值和重复的次数，构造数组{0.0, 0.0, 0.0}\n```\n数组的元素只能有一种数据类型。\n\n## 数量\n- Array.count：属性`count`表示数组`Array`的元素个数。\n- Array.isEmpty：属性`isEmpty`表示数组`Array`的元素是否为0个，结果为`true`或`false`。\n\n## 访问\n- Array[i]：通过下标`[i]`访问数组`Array`的第`i`位，可修改。\n\n## 遍历\n``` swift\nvar shoppinglist = [\"Eggs\", \"Milk\"]\nfor item in shoppingList {\n\tprintln(item)\n}\n//Eggs\n//Milk\n```\n\n## 添加\n- Array.append(Item)：将元素`Item`添加到数组`Array`的尾部。\n- Array.imsert(Item, atIndex: i)：将元素`Item`添加到数组`Array`的第`i`位。\n- Array += [Item1, Item2]：将元素`Item1`和`Item2`添加到数组`Array`的尾部。\n\n## 删除\n- Array.removeAtIndex(i)：删除数组`Array`的第`i`位。\n- Array.removeLast()：删除数组`Array`的最后一位。\n\n## 替换\n- Array[m...n] = [Item1, Item2]：用元素`Item1`和`Item2`替换数组`Array`的第`m`位到第`n`位。这种方法不能用于添加新元素。\n\n#  集合\n集合中的元素没有确定顺序，且每个元素只出现一次。\n\n## 构造\n``` swift\nvar shoppinglist: Set = [\"Eggs\", \"Milk\"]\t//初始化为字符串集合，没有指定数据类型，通过添加数据自动判断为String集合\n\nvar someInts1: Set = [2, 3]\t\t\t\nvar someInts2: Set<Int> = [2, 3]\t\t//等价于上一句，初始化为整数集合，指定了数据类型Int，只能添加Int数据，并添加了元素2，3\n\nvar someInts3 = Set<Int>()\t\t\t//初始化为整数集合，指定了数据类型Int，只能添加Int数据，没有添加元素\n\nvar someDoubles: Set = []\t\t\t//初始化为空集合，没有指定数据类型，通过添加数据自动判断\nsomeDoubles.insert(2.3)\t\t\t\t//通过添加数据自动判断为Double集合\n```\n集合的元素只能有一种数据类型。\n\n## 数量\n- Set.count：属性`count`表示集合`Set`的元素个数。\n- Set.isEmpty：属性`isEmpty`表示集合`Set`的元素是否为0个，结果为`true`或`false`。\n\n## 遍历\n``` swift\nvar shoppinglist1: Set = [\"Milk\", \"Eggs\"]\nfor item in shoppingList {\n\tprintln(item)\n}\n//Milk\n//Eggs\n\nvar shoppinglist2: Set = [\"Milk\", \"Eggs\"]\nfor item in sorted(shoppingList) {\n\tprintln(item)\n}\n//Eggs\n//Milk\n```\n因为`Set`中没有确定顺序，可以通过`sorted(Set)`函数返回一个排序的集合。\n\n## 添加\n- Set.imsert(Item)：将元素`Item`添加到集合`Set`中。\n\n## 删除\n- Set.remove(Item)：删除集合`Set`中的元素`Item`，成功则返回`Item`，如果集合中不包含`Item`则返回`nil`。\n- Set.removeAll()：删除集合`Set`中的所有元素\n\n## 包含\n- Set.contains(Item)：检查集合`Set`是否包含元素`Item`，返回`true`或`false`。\n\n## 比较\n``` swift\nlet s1: Set = [1, 2]\nlet s2: Set = [3, 4, 5, 1, 2]\nlet cityAnimals: Set = [6, 7]\ns1.isSubsetOf(s2)\n// true\ns2.isSuperSetOf(s1)\n// true\ns2.isDisjointWith(s3)\n// true\n```\n- ==：判断两个集合是否相等\n- Set1.isSubsetOf(Set2)：判断`Set1`是否是`Set2`的子集\n- Set1.isSupersetOf(Set2)：判断`Set1`是否是`Set2`的父集\n- Set1.isStrictSubsetOf(Set2)，Set1.isStrictSupersetOf(Set2)：和上面方法相似，不过两个集合不能相等。\n- Set1.isDisjoinWith(Set2)：判断`Set1`和`Set2`是否完成没有一个相同元素\n上述方法都返回`true`或`false`。\n\n## 操作\n``` swift\nlet oddDigits: Set = [1, 3, 5, 7, 9]\nlet evenDigits: Set = [0, 2, 4, 6, 8]\nlet singleDigitPrimeNumbers: Set = [2, 3, 5, 7]\nsorted(oddDigits.union(evenDigits))\n// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nsorted(oddDigits.intersect(evenDigits))\n// []\nsorted(oddDigits.subtract(singleDigitPrimeNumbers))\n// [1, 9]\nsorted(oddDigits.exclusiveOr(singleDigitPrimeNumbers))\n// [1, 2, 9]\n```\n- Set1.intersects(Set2)：返回`Set1`和`Set2`的交集，即两个集合中都有的元素\n- Set1.union(Set2)：返回`Set1`和`Set2`的并集，即两个集合中的所有元素\n- Set1.subtract(Set2)：返回`Set1`和`Set2`的差集，即`Set1`中有的且`Set2`中没有的元素\n- Set1.exclusiverOr(Set2)：返回并集减去并集的集合，即`Set1`中独有的和`Set2`中独有的元素，也就是所有元素减去两个集合中都有的元素。\n\n## 哈希值\nSwift中的所有基本类型默认都是可哈希的，通过`a.hashValue`求得哈希值。哈希值相等可以判断对象相同，如`a == b`即`a.hashValue == b.hashValue`。\n\n# 字典\n字典中每个值（_Value_）都关联唯一的建（_key_）。\n\n## 构造\n在构造过程中，键值对默认用`[key 1: value 1, key 2: value 2, key 3: value 3]`的形式。\n``` swift\nvar airports1 = [\"TYO\": \"Tokyo\", \"DUB\": \"Dublin\"]\t\t\t\t//初始化为[String: String]字典，没有指定数据类型，通过添加数据自动判断\nvar airports2: [String: String] = [\"TYO\": \"Tokyo\", \"DUB\": \"Dublin\"]\t\t//等价于上一句\nvar airports3: Dictionary<Stringr, String> = [\"TYO\": \"Tokyo\", \"DUB\": \"Dublin\"]\t//等价于上一句\n\nvar airports4 = Dictionary<String, Sting>()\t//初始化为[Sting: String]空字典，指定了数据类型[String: String]，只能添加[String:String]数据，没有添加元素\nvar airports5 = [String: String]()\t\t//等价于上一句\n\nvar airports6 = [:]\t//初始化为空字典，没有指定数据类型，通过添加数据自动判断\nairports6[2] = 3\t//通过添加数据自动判断为[Int: Int]字典\n```\n\n## 数量\n- Dictionary.count：属性`count`表示字典`Dictionary`的元素个数。\n- Dictionary.isEmpty：属性`isEmpty`表示字典`Dictionary`的元素是否为0个，结果为`true`或`false`。\n\n## 访问\n- Dictionary[key]：通过下标`[key]`访问字典`Dictionary`的键`key`对应的值，可修改。\n\n## 遍历\n``` swift\nfor (airportCode, airportName) in airports {\n    println(\"\\(airportCode): \\(airportName)\")\n}\n// TYO: Tokyo\n// DUB: Dublin\n\nfor airportCode in airports.keys {\n    println(\"Airport code: \\(airportCode)\")\n}\n// Airport code: TYO\n// Airport code: DUB\n\nfor airportName in airports.values {\n    println(\"Airport name: \\(airportName)\")\n}\n// Airport name: Tokyo\n// Airport name: Dublin\n```\n`for-in`可便利字典，可便利键值对`(key, value)`，也可以通过属性`keys`或`values`只便利键值其中一项。\n字典的属性`keys`和`values`返回数组。\n``` swift\nlet airportCodes = Array(airports.keys)\n// airportCodes is [\"TYO\", \"DUB\"]\n\nlet airportNames = Array(airports.values)\n// airportNames is [\"Tokyo\", \"Dublin\"]\n```\n## 添加\n- Dictionary[key] = value：更新字典`Dictionary`中键`key`对应的值，如果不存在，则将键值对<key, valye>添加到字典`Dictionary`中。\n- Dicitonary.updateValue(value, forkey: key)：更新字典`Dictionary`中键`key`对应的值，如果不存在，则将键值对<key, value>添加到字典`Dictionary`。\n注意：该方法返回**原值**，即执行`updateValue`方法之前键`key`对应的值，如果不存在，则返回`nil`。\n\n## 删除\n- Dictionary[key] = nil：删除字典`Dictionary`中键`key`对应的值。\n- Dictionary.removeValueForKey(key)：删除字典`Dictionary`中键`key`对应的值，返回删除的值，如果不存在，则返回`nil`。\n\n添加操作和删除操作返回值有可能为`nil`，都是可选类型，使用时需要进行判断是否有值。\n","slug":"swift_3","published":1,"updated":"2015-07-21T08:50:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cicflp6jb000ir2o3ovopoajy"},{"title":"Swift基础入门(2)：字符串和字符","date":"2015-07-15T06:09:04.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：字符串和字符。\n\n<!--more-->\n**Title: [Swift基础入门(2)：字符串和字符](https://aidaizyy.github.io/swift_2)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-15](http://aidaizyy.github.io)**\n\n## 字符串和字符\n\n### 空字符串\n``` swift\nvar str1 = \"\"\nvar str2 = String()\n\nif str1.isEmpty {\n\t//空字符串\n}\n```\n两条语句等价，都表示空字符串。\n`String`的`isEmpty`属性表示`String`是否为空，结果为`Bool`值。\n\n### 值传递\n在函数/方法中传递的是字符串的值，不会改变字符串本身。\n\n### 遍历\n``` swift\nfor character in \"Dog!\" {\n    println(character)\n}\n// D\n// o\n// g\n// !\n```\n`for-in`：`for characte in \"Hello World!\"`将会遍历字符串`\"Hello World!\"`的每个字符，并用`character: Character`来表示。\n\n### 长度\n`count(String)`函数，得到字符串的字符数量。\n\n### 连接\n- +, +=：连接字符串\n- String.append(Character)：将字符连接到字符串尾部。\n\n### 比较\n- ==：字符串相等\n- String1.hasPrefix(String2)：是否有特定前缀。如果`String1`包含前缀`String2`返回`true`，否则返回`false`。\n- String1.hasSuffix(String2)：是否有特定后缀。如果`String1`包含后缀`String2`返回`true`，否则返回`false`。\n\n### 大小写\n``` swift\nlet normal = \"Could you help me, please?\"\nlet shouty = normal.uppercaseString\n// shouty 值为 \"COULD YOU HELP ME, PLEASE?\"\nlet whispered = normal.lowercaseString\n// whispered 值为 \"could you help me, please?\"\n```\nString.uppercaseString属性表示字符串的大写，String.lowercaseString属性表示字符串的小写。\n\n## Unicode\n\nUnicode字符用`\\u{n}`表示，其中`n`为任意的一到八位十六进制数。\n\n>String：\n属性：\nString.isEmpty\nString.uppercaseString\nString.lowercaseString\nString.utf8\nString.utf16\nString.unicodeScalars\n方法：\nString.append()\nString.hasPrefix()\nString.hasSuffix()\ncount(String)\n","source":"_posts/swift_2.md","raw":"title: \"Swift基础入门(2)：字符串和字符\"\ndate: 2015-07-15 14:09:04\ntags:\n- swift\ncategories: swift\ntoc: true\n---\n\n本篇介绍Swift的基础知识：字符串和字符。\n\n<!--more-->\n**Title: [Swift基础入门(2)：字符串和字符](https://aidaizyy.github.io/swift_2)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-15](http://aidaizyy.github.io)**\n\n## 字符串和字符\n\n### 空字符串\n``` swift\nvar str1 = \"\"\nvar str2 = String()\n\nif str1.isEmpty {\n\t//空字符串\n}\n```\n两条语句等价，都表示空字符串。\n`String`的`isEmpty`属性表示`String`是否为空，结果为`Bool`值。\n\n### 值传递\n在函数/方法中传递的是字符串的值，不会改变字符串本身。\n\n### 遍历\n``` swift\nfor character in \"Dog!\" {\n    println(character)\n}\n// D\n// o\n// g\n// !\n```\n`for-in`：`for characte in \"Hello World!\"`将会遍历字符串`\"Hello World!\"`的每个字符，并用`character: Character`来表示。\n\n### 长度\n`count(String)`函数，得到字符串的字符数量。\n\n### 连接\n- +, +=：连接字符串\n- String.append(Character)：将字符连接到字符串尾部。\n\n### 比较\n- ==：字符串相等\n- String1.hasPrefix(String2)：是否有特定前缀。如果`String1`包含前缀`String2`返回`true`，否则返回`false`。\n- String1.hasSuffix(String2)：是否有特定后缀。如果`String1`包含后缀`String2`返回`true`，否则返回`false`。\n\n### 大小写\n``` swift\nlet normal = \"Could you help me, please?\"\nlet shouty = normal.uppercaseString\n// shouty 值为 \"COULD YOU HELP ME, PLEASE?\"\nlet whispered = normal.lowercaseString\n// whispered 值为 \"could you help me, please?\"\n```\nString.uppercaseString属性表示字符串的大写，String.lowercaseString属性表示字符串的小写。\n\n## Unicode\n\nUnicode字符用`\\u{n}`表示，其中`n`为任意的一到八位十六进制数。\n\n>String：\n属性：\nString.isEmpty\nString.uppercaseString\nString.lowercaseString\nString.utf8\nString.utf16\nString.unicodeScalars\n方法：\nString.append()\nString.hasPrefix()\nString.hasSuffix()\ncount(String)\n","slug":"swift_2","published":1,"updated":"2015-07-15T09:17:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cicflp6jd000lr2o3xswhyoth"},{"title":"Swift基础入门(1)：常量变量，基本数据类型和基本运算符","date":"2015-07-14T07:23:13.000Z","toc":true,"_content":"\nSwift是苹果公司于2014年推出的用于iOS，OS X和watchOS应用开发的新语言。\n本篇介绍Swift的基础知识：常量变量，基本数据类型和基本运算符。\n\n<!--more-->\n**Title: [Swift基础入门(1)：常量变量，基本数据类型和基本运算符](https://aidaizyy.github.io/swift_1)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-15](http://aidaizyy.github.io)**\n\n## 概要\n\nSwift结合了C和Objectiv-C的特点，基于Cocoa和Cocoa Touch框架。\n本文主要讲述Swift的基本语法。\n\n## 常量变量\n\n### 命名\n\n常量变量命名不能包括数学符号，箭头，保留的Unicode码位，连线和制表符，不能以数字开头。\n\n### 声明\n\n声明常量使用`let`关键字，声明变量使用`var`关键字。\n一般可省略数据类型，通过赋予的第一个值来自动确定数据类型。\n``` swift\nlet maxNumber = 20\nvar currentNumber = 0, item = 0.1\n```\n在swift中，语句结束不需要加分号。（添加分号也没有问题）\n上面两句，声明了常量`maxNumber`，并赋值为20，这个值不能被改变。声明时可以不赋值，但之后只能赋值一次。\n声明了变量`currentNumber`和`item`，并赋值为0和0.1，可赋值多次。\n在一行中可声明多个常量或变量，用逗号隔开。\n`maxNumber`和`currentNumber`第一次赋值了整数，被确定为整数类型`Int`；`item`第一次赋值了小数，被确定为浮点数类型`Double`（未指定数据类型时，小数一定会被确定为`Double`而不是`Float`）。\n\n> 基本数据类型：\n- Int\n- Double\n- Float\n- Bool\n- String\n- Character\n\n声明常量变量时，也可以指定数据类型，通过在常量变量名称后接冒号再接数据类型名称来实现。\n``` swift\nvar currentNumer: Double = 5\nprintln(currentNumber)\t//输出currentNumber的值\n```\n上面两句输出结果为`5.0`，因为`currentNumber`指定为`Double`类型，即使给它赋值了整数5。\n\n### 输出\n\n`println`和`print`函数都是输出函数，区别在于前者在输出末尾加上了换行符。\n\n输出常量变量：\n``` swift\nvar currentNumer: Double = 5\nprintln(\"The current number is \\(currentNumber)\")\n```\n上面两句输出结果为`The current number is 0.5`。\n通过`\\(常量变量)`将常量变量转换为字符串并在`println`语句中输出。\n\n### 注释\n\n和C语言类似，注释分为单行注释`//`和多行注释`/*  */`\n``` swift\nvar single\t//单行注释\n\n/* 多行注释 */\n```\n不一样的地方在于，swift的`/* */`可以嵌套。\n\n## 基本数据类型\n\n### 整数\n\n整数分为`Int8`，`UInt8`，`Int16`，`UInt16`，`Int32`，`UInt32`，`Int64`，`UInt64`，分别对应8，16，32，64位的有符号整数类型和无符号整数类型。\n一般`Int`指`Int32`（32位电脑）或`Int64`（64位电脑）。\n整数类型都有`min`和`max`两个方法。\n``` swift\nvar tmp = Int.max\nprintln(tmp)\n```\n结果为`9223372036854775807`（64位电脑）。\n\n``` swift\nlet decimalInteger = 17\t\t//十进制表示17\nlet binaryInteger = 0b1001\t//二进制表示17\nlet octalInteger = 0o21\t\t//八进制表示17\nlet hexadecimalInteger = 0x11\t//十六进制表示17\n```\n二进制，八进制和十六进制分别加前缀`0b`，`0o`，`0x`表示。\n\n### 浮点数\n\n- Double：64位浮点数，至少15位数字\n- Float：32位浮点数，最少6位数字\n\n``` swift\nlet decimalDouble = 12.1875\t//十进制表示12.1875\nlet exponentDouble = 1.21875e1\t//十进制指数表示12.1875\nlet hexadecimalDouble = 0xC.3p0\t//十六进制指数表示12.1875\n```\n浮点数字面量可以用十进制和十六进制表示，指数分别用`e`和`p`表示。\n\n数值型字面量都可以加0或_，不影响数值，比如`000_1_000.000_000_1`等于`1000.0000001`。\n\n### 布尔值\n\n`Bool`有两个值`true`和`false`。\n\n### 可选类型\n\n>可选类型（_optionals)用来表示值可能丢失的情况：\n- 有值且等于x\n- 没有值\n\n- 有无值判断\n可以通过条件语句判断，`if optional != nil`，结果为`ture`即表示有值，否则表示无值。\n\n- 强制解析\n在名字后面加`!`强制获取可选类型的值，但必须在有值的情况下，否则会报错，`optional!`。\n\n- 可选绑定\n``` swift\nlet optionalValue: Int? = 123\nif let actualValue = optionalValue {\n} else {\n}\n```\n`Int?`在数据类型后面加`?`表示包含该数据类型的可选类型，`optionalValue`表示包含`123`的可选类型，如果包含值，则赋值给`actualValue`，并返回`true`，否则返回`false`。\n\n- 无值：nil\n``` swift\nvar optionalInt: Int? = 123\noptionalInt = nil\n\nvar optionalStr: String?\n```\n可选类型可以被赋值为nil，即表示无值，这表示一个确定的值。\n如果可选类型声明时没有赋值，则自动赋值为nil。\n\n- 隐式解析\n声明时将数据类型后面的`?`改为`!`，表示一个隐式解析可选类型，即每次自动解析，使用时可直接用常量变量名称。\n\n### 断言\n可选类型无值可能会影响程序运行，在某些特定情况下，需要终止程序，我们使用断言。\n断言类似于条件判断语句，不同点在于，结果为`false`时直接终止程序。\n``` swift\nlet age = -3\nassert(age >= 0, \"age cannot be less than zero\")\n```\n`assert`的第二个参数描述信息可以省略。\n\n### 元组\n\n元组（_tuples_）把多个数据类型组合成一个复合的数据类型。\n``` swift\nlet httpStatus1 = (statusCode: 200, description: \"OK\")\nprintln(httpStatus1.statusCode, httpStatus1.description)\n//输出“200OK”\n\nlet httpStatus2 = (200, \"OK\")\nprintln(httpStatus2.0, httpStatus2.1)\n//输出“200OK”\n\nlet (statusCode, statusMessage) = httpStatus2\nprintln(statusCode, statusMessage)\n//输出“200OK”\n\nlet (statusCode, _) = httpStatus2\nprintln(statusCode)\n//输出“200”\n```\n元组用括号`(Int, String)`表示一个整数和一个字符串组合，可以给元组的单个元素命名，比如第1行的`statusCode`和`description`，调用时直接用`httpStatus1.statusCode`和`httpStatus2.description`表示；如果不命名，则用`.0`和`.1`表示。\n也可以把元组内容分解，比如第9行，分别用`statusCode`和`statusMessage`存储元组`httpStatus2`对应的元素。分解过程中忽略的部分可用`_`表示，比如第13行，只使`statusCode`存储元组`httpStatus2`的第一个元素，忽略第二个元素。\n\n### 类型别名\n\n``` swift\ntypealias tmpType = Int\nlet tmpValue: tmpType = 4\n```\n通过`typealias`关键字，给现有的数据类型再起一个新的名字，可替代使用。\n常量`tmpValue`的数据类型就是`Int`。\n\n### 类型转换\n\n- ->String：\n\\\\()的方法可将任意类型转换为字符串，其他类型转换必须通过显示转换。\n比如`String(currentNumber)`，即完成`\\(currentNumber)`一样的转换。\n\n- Int，Double，Float：\n`Int16`与`Int8`不能直接相加，需要通过`Int16(Int8)`转换。\n同样，`Double`与`Int`也不能相加，也需要通过`Double(Int)`转换，如果只需要整数部分，也可以通过`Int(Double)`转换。\n\n- String->Int：\n`种String.toInt()`函数可以把`String`转换成可选类型`Int?`，因为`String`中不一定能转换成`Int`，所以得到可选类型。\n\n## 基本运算符\n\n### 普通运算符\n\n大部分基本运算符和主流语言一致：\n- +：加\n- -：减\n- *：乘\n- /：除\n- =：赋值\n        - 不返回值，将`if a == b`误写成`if a = b`会出现编译错误。\n        - 元组赋值，`let (x, y) = (1, 2)`，表示`x = 1`且`y = 2`。\n- %：求余\n        - 除了整数，也可以对浮点数求余，`8 % 2.5`等于`Double`值`0.5`。\n- ++：自增\n- --：自减\n        - 除了整数，浮点数也可以自增和自减。\n- -：负号\n- +：正号\n- +=, -=, *=, /=, %=：复合赋值\n- ==：等于\n- !=: 不等于\n- \\>, <, >=, <=：比较运算符\n- ===, !===：是否引用同一个对象实例\n- ? : ：三目运算符\n- &&：与\n- ||：或\n- !：非\n- ()：括号，确定运算先后顺序\n\n### 空合运算符（Nil Coalescing Operator）\n\n`a ?? b`：其中`a`必须是可选（_Optional_）类型，`b`的类型与a存储的值的类型一致。\n如果a包含一个值，就返回`a`包含的值；否则返回默认值`b`，等同于`a != nil ? a! : b`。\n\n### 区间运算符（Range Operator）\n\n`a..<b`，闭区间运算符，表示`a`到`b`的区间，包含`a`，不包含`b`；\n`a...b`，半开区间运算符，表示`a`到`b`的区间，包含`a`和`b`。\n","source":"_posts/swift_1.md","raw":"title: \"Swift基础入门(1)：常量变量，基本数据类型和基本运算符\"\ndate: 2015-07-14 15:23:13\ntags:\n- swift\ncategories: swift \ntoc: true\n---\n\nSwift是苹果公司于2014年推出的用于iOS，OS X和watchOS应用开发的新语言。\n本篇介绍Swift的基础知识：常量变量，基本数据类型和基本运算符。\n\n<!--more-->\n**Title: [Swift基础入门(1)：常量变量，基本数据类型和基本运算符](https://aidaizyy.github.io/swift_1)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-15](http://aidaizyy.github.io)**\n\n## 概要\n\nSwift结合了C和Objectiv-C的特点，基于Cocoa和Cocoa Touch框架。\n本文主要讲述Swift的基本语法。\n\n## 常量变量\n\n### 命名\n\n常量变量命名不能包括数学符号，箭头，保留的Unicode码位，连线和制表符，不能以数字开头。\n\n### 声明\n\n声明常量使用`let`关键字，声明变量使用`var`关键字。\n一般可省略数据类型，通过赋予的第一个值来自动确定数据类型。\n``` swift\nlet maxNumber = 20\nvar currentNumber = 0, item = 0.1\n```\n在swift中，语句结束不需要加分号。（添加分号也没有问题）\n上面两句，声明了常量`maxNumber`，并赋值为20，这个值不能被改变。声明时可以不赋值，但之后只能赋值一次。\n声明了变量`currentNumber`和`item`，并赋值为0和0.1，可赋值多次。\n在一行中可声明多个常量或变量，用逗号隔开。\n`maxNumber`和`currentNumber`第一次赋值了整数，被确定为整数类型`Int`；`item`第一次赋值了小数，被确定为浮点数类型`Double`（未指定数据类型时，小数一定会被确定为`Double`而不是`Float`）。\n\n> 基本数据类型：\n- Int\n- Double\n- Float\n- Bool\n- String\n- Character\n\n声明常量变量时，也可以指定数据类型，通过在常量变量名称后接冒号再接数据类型名称来实现。\n``` swift\nvar currentNumer: Double = 5\nprintln(currentNumber)\t//输出currentNumber的值\n```\n上面两句输出结果为`5.0`，因为`currentNumber`指定为`Double`类型，即使给它赋值了整数5。\n\n### 输出\n\n`println`和`print`函数都是输出函数，区别在于前者在输出末尾加上了换行符。\n\n输出常量变量：\n``` swift\nvar currentNumer: Double = 5\nprintln(\"The current number is \\(currentNumber)\")\n```\n上面两句输出结果为`The current number is 0.5`。\n通过`\\(常量变量)`将常量变量转换为字符串并在`println`语句中输出。\n\n### 注释\n\n和C语言类似，注释分为单行注释`//`和多行注释`/*  */`\n``` swift\nvar single\t//单行注释\n\n/* 多行注释 */\n```\n不一样的地方在于，swift的`/* */`可以嵌套。\n\n## 基本数据类型\n\n### 整数\n\n整数分为`Int8`，`UInt8`，`Int16`，`UInt16`，`Int32`，`UInt32`，`Int64`，`UInt64`，分别对应8，16，32，64位的有符号整数类型和无符号整数类型。\n一般`Int`指`Int32`（32位电脑）或`Int64`（64位电脑）。\n整数类型都有`min`和`max`两个方法。\n``` swift\nvar tmp = Int.max\nprintln(tmp)\n```\n结果为`9223372036854775807`（64位电脑）。\n\n``` swift\nlet decimalInteger = 17\t\t//十进制表示17\nlet binaryInteger = 0b1001\t//二进制表示17\nlet octalInteger = 0o21\t\t//八进制表示17\nlet hexadecimalInteger = 0x11\t//十六进制表示17\n```\n二进制，八进制和十六进制分别加前缀`0b`，`0o`，`0x`表示。\n\n### 浮点数\n\n- Double：64位浮点数，至少15位数字\n- Float：32位浮点数，最少6位数字\n\n``` swift\nlet decimalDouble = 12.1875\t//十进制表示12.1875\nlet exponentDouble = 1.21875e1\t//十进制指数表示12.1875\nlet hexadecimalDouble = 0xC.3p0\t//十六进制指数表示12.1875\n```\n浮点数字面量可以用十进制和十六进制表示，指数分别用`e`和`p`表示。\n\n数值型字面量都可以加0或_，不影响数值，比如`000_1_000.000_000_1`等于`1000.0000001`。\n\n### 布尔值\n\n`Bool`有两个值`true`和`false`。\n\n### 可选类型\n\n>可选类型（_optionals)用来表示值可能丢失的情况：\n- 有值且等于x\n- 没有值\n\n- 有无值判断\n可以通过条件语句判断，`if optional != nil`，结果为`ture`即表示有值，否则表示无值。\n\n- 强制解析\n在名字后面加`!`强制获取可选类型的值，但必须在有值的情况下，否则会报错，`optional!`。\n\n- 可选绑定\n``` swift\nlet optionalValue: Int? = 123\nif let actualValue = optionalValue {\n} else {\n}\n```\n`Int?`在数据类型后面加`?`表示包含该数据类型的可选类型，`optionalValue`表示包含`123`的可选类型，如果包含值，则赋值给`actualValue`，并返回`true`，否则返回`false`。\n\n- 无值：nil\n``` swift\nvar optionalInt: Int? = 123\noptionalInt = nil\n\nvar optionalStr: String?\n```\n可选类型可以被赋值为nil，即表示无值，这表示一个确定的值。\n如果可选类型声明时没有赋值，则自动赋值为nil。\n\n- 隐式解析\n声明时将数据类型后面的`?`改为`!`，表示一个隐式解析可选类型，即每次自动解析，使用时可直接用常量变量名称。\n\n### 断言\n可选类型无值可能会影响程序运行，在某些特定情况下，需要终止程序，我们使用断言。\n断言类似于条件判断语句，不同点在于，结果为`false`时直接终止程序。\n``` swift\nlet age = -3\nassert(age >= 0, \"age cannot be less than zero\")\n```\n`assert`的第二个参数描述信息可以省略。\n\n### 元组\n\n元组（_tuples_）把多个数据类型组合成一个复合的数据类型。\n``` swift\nlet httpStatus1 = (statusCode: 200, description: \"OK\")\nprintln(httpStatus1.statusCode, httpStatus1.description)\n//输出“200OK”\n\nlet httpStatus2 = (200, \"OK\")\nprintln(httpStatus2.0, httpStatus2.1)\n//输出“200OK”\n\nlet (statusCode, statusMessage) = httpStatus2\nprintln(statusCode, statusMessage)\n//输出“200OK”\n\nlet (statusCode, _) = httpStatus2\nprintln(statusCode)\n//输出“200”\n```\n元组用括号`(Int, String)`表示一个整数和一个字符串组合，可以给元组的单个元素命名，比如第1行的`statusCode`和`description`，调用时直接用`httpStatus1.statusCode`和`httpStatus2.description`表示；如果不命名，则用`.0`和`.1`表示。\n也可以把元组内容分解，比如第9行，分别用`statusCode`和`statusMessage`存储元组`httpStatus2`对应的元素。分解过程中忽略的部分可用`_`表示，比如第13行，只使`statusCode`存储元组`httpStatus2`的第一个元素，忽略第二个元素。\n\n### 类型别名\n\n``` swift\ntypealias tmpType = Int\nlet tmpValue: tmpType = 4\n```\n通过`typealias`关键字，给现有的数据类型再起一个新的名字，可替代使用。\n常量`tmpValue`的数据类型就是`Int`。\n\n### 类型转换\n\n- ->String：\n\\\\()的方法可将任意类型转换为字符串，其他类型转换必须通过显示转换。\n比如`String(currentNumber)`，即完成`\\(currentNumber)`一样的转换。\n\n- Int，Double，Float：\n`Int16`与`Int8`不能直接相加，需要通过`Int16(Int8)`转换。\n同样，`Double`与`Int`也不能相加，也需要通过`Double(Int)`转换，如果只需要整数部分，也可以通过`Int(Double)`转换。\n\n- String->Int：\n`种String.toInt()`函数可以把`String`转换成可选类型`Int?`，因为`String`中不一定能转换成`Int`，所以得到可选类型。\n\n## 基本运算符\n\n### 普通运算符\n\n大部分基本运算符和主流语言一致：\n- +：加\n- -：减\n- *：乘\n- /：除\n- =：赋值\n        - 不返回值，将`if a == b`误写成`if a = b`会出现编译错误。\n        - 元组赋值，`let (x, y) = (1, 2)`，表示`x = 1`且`y = 2`。\n- %：求余\n        - 除了整数，也可以对浮点数求余，`8 % 2.5`等于`Double`值`0.5`。\n- ++：自增\n- --：自减\n        - 除了整数，浮点数也可以自增和自减。\n- -：负号\n- +：正号\n- +=, -=, *=, /=, %=：复合赋值\n- ==：等于\n- !=: 不等于\n- \\>, <, >=, <=：比较运算符\n- ===, !===：是否引用同一个对象实例\n- ? : ：三目运算符\n- &&：与\n- ||：或\n- !：非\n- ()：括号，确定运算先后顺序\n\n### 空合运算符（Nil Coalescing Operator）\n\n`a ?? b`：其中`a`必须是可选（_Optional_）类型，`b`的类型与a存储的值的类型一致。\n如果a包含一个值，就返回`a`包含的值；否则返回默认值`b`，等同于`a != nil ? a! : b`。\n\n### 区间运算符（Range Operator）\n\n`a..<b`，闭区间运算符，表示`a`到`b`的区间，包含`a`，不包含`b`；\n`a...b`，半开区间运算符，表示`a`到`b`的区间，包含`a`和`b`。\n","slug":"swift_1","published":1,"updated":"2015-07-15T08:20:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cicflp6ji000or2o3mprxa409"},{"title":"dpdk-l2fwd详解","date":"2015-03-31T05:59:13.000Z","toc":true,"_content":"\nL2 forwarding sample application在DPDK（Data Plane Development Kit）的基础上实现了第二层（链路层）的数据包转发。\n\n<!--more-->\n**Title: [dpdk-l2fwd详解](http://aidaizyy.github.io/dpdk_l2fwd)**\n**Author: [Yunyao Zhang（张云尧）](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-04-15](http://aidaizyy.github.io)**\n\n## 概要\n\n版本：DPDK-1.8.0\n\n本例中实现了相邻端口之间的相互转发。\n比如一共4个端口可用，那么端口1收到数据后会转发给端口2，端口2收到数据后会转发给端口1，端口3和端口4也会相互转发。\n\n## 编译\n\n设置环境变量\n``` bash\nexport RTE_SDK=/(RTE_SDK) #DPDK的路径\nexport RTE_TARGET=x86_64-native-linuxapp-gcc #DPDK的编译目标\n```\n\n进入示例目录\n``` bash\ncd /(RTE_SDK)/example/l2wfd\n```\n\n编译\n``` bash\nmake\n```\n\n## 运行\n\n``` bash\n./build/l2wfd [EAL options] -- -p PORTMASK [-q NQ -T t]\n```\n\n- EAL options\n\t- DPDK EAL的默认参数，必须参数为-c COREMASK -n NUM。\n\t- COREMASK：一个十六进制位掩码表示分配的逻辑内核数量。\n\t- NUM：一个十进制整数表示内存通道数量。\n\n- -p PORTMASK\n\tPORTMASK：一个十六进制位掩码表示分配的端口数量。\n\n- -q NQ\n\tNQ：表示分配给每个逻辑内核的收发队列数量。\n\n- -T t\n\tt: 表示打印统计数据到屏幕上的时间间隔，默认为10秒。\n\n``` bash\n./build/l2fwd -c f -n 4 -- -q 4 -p ffff\n```\n表示，分配给4个逻辑内核，每个内核分别有4个收发队列，而一共分配了16个端口。\n\n## 详解\n\n### 初始化EAL(Environment Abstraciton Layer)\n``` C\n\tret = rte_eal_init(argc, argv);\n\tif (ret < 0)\n\t\trte_exit(EXIT_FAILURE, \"Invalid EAL arguments\\n\");\n```\n\n### 参数传递\n``` C\n\tret = l2fwd_parse_args(argc, argv);\n\tif (ret < 0)\n\t\trte_exit(EXIT_FAILURE, \"Invalid L2FWD arguments\\n\");\n```\nEAL参数传递已经在rte_eal_init()函数中完成了，这里主要传递“--”后面的参数。\n传递参数之后，得到三个变量。\n- l2fwd_enabled_port_mask：可用端口位掩码\n- l2fwd_rx_queue_per_lcore：每个逻辑内核的收取队列数量\n- timer_period：打印统计数据的时间间隔\n\n### 创建内存池\n``` C\n\tl2fwd_pktmbuf_pool =\n\t\trte_mempool_create(\"mbuf_pool\", NB_MBUF,\n\t\t\t\t   MBUF_SIZE, 32,\n\t\t\t\t   sizeof(struct rte_pktmbuf_pool_private),\n\t\t\t\t   rte_pktmbuf_pool_init, NULL,\n\t\t\t\t   rte_pktmbuf_init, NULL,\n\t\t\t\t   rte_socket_id(), 0);\n\tif (l2fwd_pktmbuf_pool == NULL)\n\t\trte_exit(EXIT_FAILURE, \"Cannot init mbuf pool\\n\");\n```\n- \"mbuf_pool\"：内存池的名称\n- NB_MBUF：内存池中存储mbuf的数量\n- MBUF_SIZE: mbuf的大小\n- 32：内存池缓存的大小\n\n### 端口处理\n``` C\n\t//rte_eth_dev_count()函数返回端口总数\n\tnb_ports = rte_eth_dev_count();\n\tif (nb_ports == 0)\n\t\trte_exit(EXIT_FAILURE, \"No Ethernet ports - bye\\n\");\n\n\tif (nb_ports > RTE_MAX_ETHPORTS)\n\t\tnb_ports = RTE_MAX_ETHPORTS;\n```\n``` C\n\tfor (portid = 0; portid < nb_ports; portid++) {\n\t\t//跳过未分配或者不可用端口\n\t\tif ((l2fwd_enabled_port_mask & (1 << portid)) == 0)\n\t\t\tcontinue;\n\t}\n```\n可用端口位掩码表示，左数第n位如果为1，表示端口n可用，如果左数第n位如果为0，表示端口n不可用。\n要得到第x位为1还是0，我们的方法是将1左移x位，得到一个只在x位为1，其他位都为0的数，再与位掩码相与。结果为1，那么第x位为1，结果位0，那么第x位为0.\n\n### 设置每个端口的目的端口\n这里设置数据包进入端口后，转发给相邻的端口。\n每两个端口为一对，相互转发。\n``` C\n\tfor (portid = 0; portid < nb_ports; portid++) {\n\t\tif ((l2fwd_enabled_port_mask & (1 << portid)) == 0)\n\t\t\tcontinue;\n\n\t\tif (nb_ports_in_mask % 2) {\n\t\t\tl2fwd_dst_ports[portid] = last_port;\n\t\t\tl2fwd_dst_ports[last_port] = portid;\n\t\t}\n\t\telse\n\t\t\tlast_port = portid;\n\n\t\tnb_ports_in_mask++;\n\n\t\trte_eth_dev_info_get(portid, &dev_info);\n\t}\n\tif (nb_ports_in_mask % 2) {\n\t\tprintf(\"Notice: odd number of ports in portmask.\\n\");\n\t\tl2fwd_dst_ports[last_port] = last_port;\n\t}\n```\n\n### 初始化端口的配置信息\n为每个端口分配到相应的逻辑内核\n每个端口只对应一个逻辑内核\n每个逻辑内核对应l2fwd_rx_queue_per_lcore个端口\n``` C\n\tfor (portid = 0; portid < nb_ports; portid++) {\n\t\tif ((l2fwd_enabled_port_mask & (1 << portid)) == 0)\n\t\t\tcontinue;\n\n\t\t//得到一个收取队列未分配满且可用的逻辑内核\n\t\twhile (rte_lcore_is_enabled(rx_lcore_id) == 0 ||\n\t\t       lcore_queue_conf[rx_lcore_id].n_rx_port ==\n\t\t       l2fwd_rx_queue_per_lcore) {\n\t\t\trx_lcore_id++;\n\t\t\tif (rx_lcore_id >= RTE_MAX_LCORE)\n\t\t\t\trte_exit(EXIT_FAILURE, \"Not enough cores\\n\");\n\t\t}\n\n\t\tif (qconf != &lcore_queue_conf[rx_lcore_id])\n\t\t\t/* Assigned a new logical core in the loop above. */\n\t\t\tqconf = &lcore_queue_conf[rx_lcore_id];\n\n\t\tqconf->rx_port_list[qconf->n_rx_port] = portid;\n\t\tqconf->n_rx_port++;\n\t\tprintf(\"Lcore %u: RX port %u\\n\", rx_lcore_id, (unsigned) portid);\n\t}\n```\n\n### 初始化每个端口\n``` C\n\tfor (portid = 0; portid < nb_ports; portid++) {\n\t\tif ((l2fwd_enabled_port_mask & (1 << portid)) == 0) {\n\t\t\tprintf(\"Skipping disabled port %u\\n\", (unsigned) portid);\n\t\t\tnb_ports_available--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"Initializing port %u... \", (unsigned) portid);\n\t\tfflush(stdout);\n\t\t//初始化端口，第二个参数和第三个参数表示分配收取队列和发送队列的数量\n\t\tret = rte_eth_dev_configure(portid, 1, 1, &port_conf);\n\t\tif (ret < 0)\n\t\t\trte_exit(EXIT_FAILURE, \"Cannot configure device: err=%d, port=%u\\n\",\n\t\t\t\t  ret, (unsigned) portid);\n\n\t\t//得到端口对应的mac地址，存入l2fwd_ports_eth_addr[]数组\n\t\trte_eth_macaddr_get(portid,&l2fwd_ports_eth_addr[portid]);\n\n\t\tfflush(stdout);\n\t\t//初始化一个收取队列，nb_rxd指收取队列的大小，最大能够存储mbuf的数量\n\t\tret = rte_eth_rx_queue_setup(portid, 0, nb_rxd,\n\t\t\t\t\t     rte_eth_dev_socket_id(portid),\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     l2fwd_pktmbuf_pool);\n\t\tif (ret < 0)\n\t\t\trte_exit(EXIT_FAILURE, \"rte_eth_rx_queue_setup:err=%d, port=%u\\n\",\n\t\t\t\t  ret, (unsigned) portid);\n\n\t\tfflush(stdout);\n\t\t//初始化一个发送队列，nb_txd指发送队列的大小，最大能够存储mbuf的数量\n\t\tret = rte_eth_tx_queue_setup(portid, 0, nb_txd,\n\t\t\t\trte_eth_dev_socket_id(portid),\n\t\t\t\tNULL);\n\t\tif (ret < 0)\n\t\t\trte_exit(EXIT_FAILURE, \"rte_eth_tx_queue_setup:err=%d, port=%u\\n\",\n\t\t\t\tret, (unsigned) portid);\n\n\t\t//开始运行该端口\n\t\tret = rte_eth_dev_start(portid);\n\t\tif (ret < 0)\n\t\t\trte_exit(EXIT_FAILURE, \"rte_eth_dev_start:err=%d, port=%u\\n\",\n\t\t\t\t  ret, (unsigned) portid);\n\n\t\tprintf(\"done: \\n\");\n\n\t\trte_eth_promiscuous_enable(portid);\n\n\t\tprintf(\"Port %u, MAC address: %02X:%02X:%02X:%02X:%02X:%02X\\n\\n\",\n\t\t\t\t(unsigned) portid,\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[0],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[1],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[2],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[3],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[4],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[5]);\n\n\t\t//初始化端口的统计数据\n\t\tmemset(&port_statistics, 0, sizeof(port_statistics));\n\t}\n```\n\n### 检查每个端口的连接状态\n``` C\n\tcheck_all_ports_link_status(nb_ports, l2fwd_enabled_port_mask);\n```\n\n### 在每个逻辑内核上启动线程，开始转发\n``` C\n\trte_eal_mp_remote_launch(l2fwd_launch_one_lcore, NULL, CALL_MASTER);\n\tRTE_LCORE_FOREACH_SLAVE(lcore_id) {\n\t\tif (rte_eal_wait_lcore(lcore_id) < 0)\n\t\t\treturn -1;\n\t}\n```\n\n收包\n``` C\n\tfor (i = 0; i < qconf->n_rx_port; i++) {\n\n\t\tportid = qconf->rx_port_list[i];\n\t\t//收包，一次最多收取MAX_PKT_BURST个数据包\n\t\tnb_rx = rte_eth_rx_burst((uint8_t) portid, 0,\n\t\t\t\t\t pkts_burst, MAX_PKT_BURST);\n\t\t\n\t\t//更新统计数据\n\t\tport_statistics[portid].rx += nb_rx;\n\n\t\tfor (j = 0; j < nb_rx; j++) {\n\t\t\tm = pkts_burst[j];\n\t\t\trte_prefetch0(rte_pktmbuf_mtod(m, void *));\n\t\t\t//转发\n\t\t\tl2fwd_simple_forward(m, portid);\n\t\t}\n\t}\n```\n\n转发\n替换源MAC地址和目的MAC地址\n``` C\n\tstatic void\n\tl2fwd_simple_forward(struct rte_mbuf *m, unsigned portid)\n\t{\n\t\tstruct ether_hdr *eth;\n\t\tvoid *tmp;\n\t\tunsigned dst_port;\n\n\t\tdst_port = l2fwd_dst_ports[portid];\n\t\teth = rte_pktmbuf_mtod(m, struct ether_hdr *);\n\n\t\t//目的地址\n\t\t/* 02:00:00:00:00:xx */\n\t\ttmp = &eth->d_addr.addr_bytes[0];\n\t\t*((uint64_t *)tmp) = 0x000000000002 + ((uint64_t)dst_port << 40);\n\n\t\t//源地址\n\t\tether_addr_copy(&l2fwd_ports_eth_addr[dst_port], &eth->s_addr);\n\n\t\tl2fwd_send_packet(m, (uint8_t) dst_port);\n\t}\n```\n\n将数据包推送至发送队列，如果发送队列存够MAX_PKT_BURST，即每次最大收取包的数量，就会发包\n``` C\n\tstatic int\n\tl2fwd_send_packet(struct rte_mbuf *m, uint8_t port)\n\t{\n\t\tunsigned lcore_id, len;\n\t\tstruct lcore_queue_conf *qconf;\n\n\t\tlcore_id = rte_lcore_id();\n\n\t\tqconf = &lcore_queue_conf[lcore_id];\n\t\tlen = qconf->tx_mbufs[port].len;\n\t\tqconf->tx_mbufs[port].m_table[len] = m;\n\t\tlen++;\n\n\t\t//当发包队列存够MAX_PKT_BURST，发包\n\t\tif (unlikely(len == MAX_PKT_BURST)) {\n\t\t\tl2fwd_send_burst(qconf, MAX_PKT_BURST, port);\n\t\t\tlen = 0;\n\t\t}\n\n\t\tqconf->tx_mbufs[port].len = len;\n\t\treturn 0;\n\t}\n```\n\n每隔一定时间也会发包\n``` C\n\t//上次收包时间和这次收包时间差\n\tdiff_tsc = cur_tsc - prev_tsc;\n\t//如果时间差大于我们设定的阈值，这里是100us\n\tif (unlikely(diff_tsc > drain_tsc)) {\n\n\t\tfor (portid = 0; portid < RTE_MAX_ETHPORTS; portid++) {\t\t\t\n\t\t\tif (qconf->tx_mbufs[portid].len == 0)\n\t\t\t\tcontinue;\n\t\t\t//发包\n\t\t\tl2fwd_send_burst(&lcore_queue_conf[lcore_id],\n\t\t\t\t\t qconf->tx_mbufs[portid].len,\n\t\t\t\t\t (uint8_t) portid);\n\t\t\t\t\tqconf->tx_mbufs[portid].len = 0;\n\t\t}\n\t\t\n\t\tif (timer_period > 0) {\n\t\t\t\t\n\t\t\ttimer_tsc += diff_tsc;\n\n\t\t\t//如果累积时间超过我们设定的阈值，就打印出统计数据，默认是10s\n\t\t\tif (unlikely(timer_tsc >= (uint64_t) timer_period)) {\n\n\t\t\t\t//打印数据在发生在主逻辑内核上\n\t\t\t\tif (lcore_id == rte_get_master_lcore()) {\n\t\t\t\t\t//打印统计数据\n\t\t\t\t\tprint_stats();\n\t\t\t\t\t//累积时间置零\n\t\t\t\t\ttimer_tsc = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprev_tsc = cur_tsc;\n\t}\n```\n这两种情况都会产生发包，无论是发送队列存够阈值MAX_PKT_BURST，或者，时间差超过阈值brain_tsc，都会把发送队列上MAX_PKT_BURST个数据包推送出去，如果不足MAX_PKT_BURST，则把发送队列上全部数据包推送出去。\n\n发包函数\n``` C\n\tstatic int\n\tl2fwd_send_burst(struct lcore_queue_conf *qconf, unsigned n, uint8_t port)\n\t{\n\t\tstruct rte_mbuf **m_table;\n\t\tunsigned ret;\n\t\tunsigned queueid =0;\n\n\t\tm_table = (struct rte_mbuf **)qconf->tx_mbufs[port].m_table;\n\t\t//发包\n\t\tret = rte_eth_tx_burst(port, (uint16_t) queueid, m_table, (uint16_t) n);\n\t\t//更新统计数据\n\t\tport_statistics[port].tx += ret;\n\t\t//丢包\n\t\tif (unlikely(ret < n)) {\n\t\t\t//更新统计数据\n\t\t\tport_statistics[port].dropped += (n - ret);\n\t\t\tdo {\n\t\t\t\t//把丢包部分free掉\n\t\t\t\trte_pktmbuf_free(m_table[ret]);\n\t\t\t} while (++ret < n);\n\t\t}\n\n\t\treturn 0;\n\t}\n```\n在函数rte_eth_tx_burst()中：\n- port：端口号。\n- queueid：端口中的发送队列号。本例中每个端口都只有一个发送队列，所以固定为0。\n- m_table：**rte_mbuf数据\n- n：发送包的数量\n\n","source":"_posts/dpdk_l2fwd.md","raw":"title: dpdk-l2fwd详解\ndate: 2015-03-31 13:59:13\ntags: \n- dpdk\ncategories: dpdk\ntoc: true\n---\n\nL2 forwarding sample application在DPDK（Data Plane Development Kit）的基础上实现了第二层（链路层）的数据包转发。\n\n<!--more-->\n**Title: [dpdk-l2fwd详解](http://aidaizyy.github.io/dpdk_l2fwd)**\n**Author: [Yunyao Zhang（张云尧）](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-04-15](http://aidaizyy.github.io)**\n\n## 概要\n\n版本：DPDK-1.8.0\n\n本例中实现了相邻端口之间的相互转发。\n比如一共4个端口可用，那么端口1收到数据后会转发给端口2，端口2收到数据后会转发给端口1，端口3和端口4也会相互转发。\n\n## 编译\n\n设置环境变量\n``` bash\nexport RTE_SDK=/(RTE_SDK) #DPDK的路径\nexport RTE_TARGET=x86_64-native-linuxapp-gcc #DPDK的编译目标\n```\n\n进入示例目录\n``` bash\ncd /(RTE_SDK)/example/l2wfd\n```\n\n编译\n``` bash\nmake\n```\n\n## 运行\n\n``` bash\n./build/l2wfd [EAL options] -- -p PORTMASK [-q NQ -T t]\n```\n\n- EAL options\n\t- DPDK EAL的默认参数，必须参数为-c COREMASK -n NUM。\n\t- COREMASK：一个十六进制位掩码表示分配的逻辑内核数量。\n\t- NUM：一个十进制整数表示内存通道数量。\n\n- -p PORTMASK\n\tPORTMASK：一个十六进制位掩码表示分配的端口数量。\n\n- -q NQ\n\tNQ：表示分配给每个逻辑内核的收发队列数量。\n\n- -T t\n\tt: 表示打印统计数据到屏幕上的时间间隔，默认为10秒。\n\n``` bash\n./build/l2fwd -c f -n 4 -- -q 4 -p ffff\n```\n表示，分配给4个逻辑内核，每个内核分别有4个收发队列，而一共分配了16个端口。\n\n## 详解\n\n### 初始化EAL(Environment Abstraciton Layer)\n``` C\n\tret = rte_eal_init(argc, argv);\n\tif (ret < 0)\n\t\trte_exit(EXIT_FAILURE, \"Invalid EAL arguments\\n\");\n```\n\n### 参数传递\n``` C\n\tret = l2fwd_parse_args(argc, argv);\n\tif (ret < 0)\n\t\trte_exit(EXIT_FAILURE, \"Invalid L2FWD arguments\\n\");\n```\nEAL参数传递已经在rte_eal_init()函数中完成了，这里主要传递“--”后面的参数。\n传递参数之后，得到三个变量。\n- l2fwd_enabled_port_mask：可用端口位掩码\n- l2fwd_rx_queue_per_lcore：每个逻辑内核的收取队列数量\n- timer_period：打印统计数据的时间间隔\n\n### 创建内存池\n``` C\n\tl2fwd_pktmbuf_pool =\n\t\trte_mempool_create(\"mbuf_pool\", NB_MBUF,\n\t\t\t\t   MBUF_SIZE, 32,\n\t\t\t\t   sizeof(struct rte_pktmbuf_pool_private),\n\t\t\t\t   rte_pktmbuf_pool_init, NULL,\n\t\t\t\t   rte_pktmbuf_init, NULL,\n\t\t\t\t   rte_socket_id(), 0);\n\tif (l2fwd_pktmbuf_pool == NULL)\n\t\trte_exit(EXIT_FAILURE, \"Cannot init mbuf pool\\n\");\n```\n- \"mbuf_pool\"：内存池的名称\n- NB_MBUF：内存池中存储mbuf的数量\n- MBUF_SIZE: mbuf的大小\n- 32：内存池缓存的大小\n\n### 端口处理\n``` C\n\t//rte_eth_dev_count()函数返回端口总数\n\tnb_ports = rte_eth_dev_count();\n\tif (nb_ports == 0)\n\t\trte_exit(EXIT_FAILURE, \"No Ethernet ports - bye\\n\");\n\n\tif (nb_ports > RTE_MAX_ETHPORTS)\n\t\tnb_ports = RTE_MAX_ETHPORTS;\n```\n``` C\n\tfor (portid = 0; portid < nb_ports; portid++) {\n\t\t//跳过未分配或者不可用端口\n\t\tif ((l2fwd_enabled_port_mask & (1 << portid)) == 0)\n\t\t\tcontinue;\n\t}\n```\n可用端口位掩码表示，左数第n位如果为1，表示端口n可用，如果左数第n位如果为0，表示端口n不可用。\n要得到第x位为1还是0，我们的方法是将1左移x位，得到一个只在x位为1，其他位都为0的数，再与位掩码相与。结果为1，那么第x位为1，结果位0，那么第x位为0.\n\n### 设置每个端口的目的端口\n这里设置数据包进入端口后，转发给相邻的端口。\n每两个端口为一对，相互转发。\n``` C\n\tfor (portid = 0; portid < nb_ports; portid++) {\n\t\tif ((l2fwd_enabled_port_mask & (1 << portid)) == 0)\n\t\t\tcontinue;\n\n\t\tif (nb_ports_in_mask % 2) {\n\t\t\tl2fwd_dst_ports[portid] = last_port;\n\t\t\tl2fwd_dst_ports[last_port] = portid;\n\t\t}\n\t\telse\n\t\t\tlast_port = portid;\n\n\t\tnb_ports_in_mask++;\n\n\t\trte_eth_dev_info_get(portid, &dev_info);\n\t}\n\tif (nb_ports_in_mask % 2) {\n\t\tprintf(\"Notice: odd number of ports in portmask.\\n\");\n\t\tl2fwd_dst_ports[last_port] = last_port;\n\t}\n```\n\n### 初始化端口的配置信息\n为每个端口分配到相应的逻辑内核\n每个端口只对应一个逻辑内核\n每个逻辑内核对应l2fwd_rx_queue_per_lcore个端口\n``` C\n\tfor (portid = 0; portid < nb_ports; portid++) {\n\t\tif ((l2fwd_enabled_port_mask & (1 << portid)) == 0)\n\t\t\tcontinue;\n\n\t\t//得到一个收取队列未分配满且可用的逻辑内核\n\t\twhile (rte_lcore_is_enabled(rx_lcore_id) == 0 ||\n\t\t       lcore_queue_conf[rx_lcore_id].n_rx_port ==\n\t\t       l2fwd_rx_queue_per_lcore) {\n\t\t\trx_lcore_id++;\n\t\t\tif (rx_lcore_id >= RTE_MAX_LCORE)\n\t\t\t\trte_exit(EXIT_FAILURE, \"Not enough cores\\n\");\n\t\t}\n\n\t\tif (qconf != &lcore_queue_conf[rx_lcore_id])\n\t\t\t/* Assigned a new logical core in the loop above. */\n\t\t\tqconf = &lcore_queue_conf[rx_lcore_id];\n\n\t\tqconf->rx_port_list[qconf->n_rx_port] = portid;\n\t\tqconf->n_rx_port++;\n\t\tprintf(\"Lcore %u: RX port %u\\n\", rx_lcore_id, (unsigned) portid);\n\t}\n```\n\n### 初始化每个端口\n``` C\n\tfor (portid = 0; portid < nb_ports; portid++) {\n\t\tif ((l2fwd_enabled_port_mask & (1 << portid)) == 0) {\n\t\t\tprintf(\"Skipping disabled port %u\\n\", (unsigned) portid);\n\t\t\tnb_ports_available--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"Initializing port %u... \", (unsigned) portid);\n\t\tfflush(stdout);\n\t\t//初始化端口，第二个参数和第三个参数表示分配收取队列和发送队列的数量\n\t\tret = rte_eth_dev_configure(portid, 1, 1, &port_conf);\n\t\tif (ret < 0)\n\t\t\trte_exit(EXIT_FAILURE, \"Cannot configure device: err=%d, port=%u\\n\",\n\t\t\t\t  ret, (unsigned) portid);\n\n\t\t//得到端口对应的mac地址，存入l2fwd_ports_eth_addr[]数组\n\t\trte_eth_macaddr_get(portid,&l2fwd_ports_eth_addr[portid]);\n\n\t\tfflush(stdout);\n\t\t//初始化一个收取队列，nb_rxd指收取队列的大小，最大能够存储mbuf的数量\n\t\tret = rte_eth_rx_queue_setup(portid, 0, nb_rxd,\n\t\t\t\t\t     rte_eth_dev_socket_id(portid),\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     l2fwd_pktmbuf_pool);\n\t\tif (ret < 0)\n\t\t\trte_exit(EXIT_FAILURE, \"rte_eth_rx_queue_setup:err=%d, port=%u\\n\",\n\t\t\t\t  ret, (unsigned) portid);\n\n\t\tfflush(stdout);\n\t\t//初始化一个发送队列，nb_txd指发送队列的大小，最大能够存储mbuf的数量\n\t\tret = rte_eth_tx_queue_setup(portid, 0, nb_txd,\n\t\t\t\trte_eth_dev_socket_id(portid),\n\t\t\t\tNULL);\n\t\tif (ret < 0)\n\t\t\trte_exit(EXIT_FAILURE, \"rte_eth_tx_queue_setup:err=%d, port=%u\\n\",\n\t\t\t\tret, (unsigned) portid);\n\n\t\t//开始运行该端口\n\t\tret = rte_eth_dev_start(portid);\n\t\tif (ret < 0)\n\t\t\trte_exit(EXIT_FAILURE, \"rte_eth_dev_start:err=%d, port=%u\\n\",\n\t\t\t\t  ret, (unsigned) portid);\n\n\t\tprintf(\"done: \\n\");\n\n\t\trte_eth_promiscuous_enable(portid);\n\n\t\tprintf(\"Port %u, MAC address: %02X:%02X:%02X:%02X:%02X:%02X\\n\\n\",\n\t\t\t\t(unsigned) portid,\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[0],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[1],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[2],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[3],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[4],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[5]);\n\n\t\t//初始化端口的统计数据\n\t\tmemset(&port_statistics, 0, sizeof(port_statistics));\n\t}\n```\n\n### 检查每个端口的连接状态\n``` C\n\tcheck_all_ports_link_status(nb_ports, l2fwd_enabled_port_mask);\n```\n\n### 在每个逻辑内核上启动线程，开始转发\n``` C\n\trte_eal_mp_remote_launch(l2fwd_launch_one_lcore, NULL, CALL_MASTER);\n\tRTE_LCORE_FOREACH_SLAVE(lcore_id) {\n\t\tif (rte_eal_wait_lcore(lcore_id) < 0)\n\t\t\treturn -1;\n\t}\n```\n\n收包\n``` C\n\tfor (i = 0; i < qconf->n_rx_port; i++) {\n\n\t\tportid = qconf->rx_port_list[i];\n\t\t//收包，一次最多收取MAX_PKT_BURST个数据包\n\t\tnb_rx = rte_eth_rx_burst((uint8_t) portid, 0,\n\t\t\t\t\t pkts_burst, MAX_PKT_BURST);\n\t\t\n\t\t//更新统计数据\n\t\tport_statistics[portid].rx += nb_rx;\n\n\t\tfor (j = 0; j < nb_rx; j++) {\n\t\t\tm = pkts_burst[j];\n\t\t\trte_prefetch0(rte_pktmbuf_mtod(m, void *));\n\t\t\t//转发\n\t\t\tl2fwd_simple_forward(m, portid);\n\t\t}\n\t}\n```\n\n转发\n替换源MAC地址和目的MAC地址\n``` C\n\tstatic void\n\tl2fwd_simple_forward(struct rte_mbuf *m, unsigned portid)\n\t{\n\t\tstruct ether_hdr *eth;\n\t\tvoid *tmp;\n\t\tunsigned dst_port;\n\n\t\tdst_port = l2fwd_dst_ports[portid];\n\t\teth = rte_pktmbuf_mtod(m, struct ether_hdr *);\n\n\t\t//目的地址\n\t\t/* 02:00:00:00:00:xx */\n\t\ttmp = &eth->d_addr.addr_bytes[0];\n\t\t*((uint64_t *)tmp) = 0x000000000002 + ((uint64_t)dst_port << 40);\n\n\t\t//源地址\n\t\tether_addr_copy(&l2fwd_ports_eth_addr[dst_port], &eth->s_addr);\n\n\t\tl2fwd_send_packet(m, (uint8_t) dst_port);\n\t}\n```\n\n将数据包推送至发送队列，如果发送队列存够MAX_PKT_BURST，即每次最大收取包的数量，就会发包\n``` C\n\tstatic int\n\tl2fwd_send_packet(struct rte_mbuf *m, uint8_t port)\n\t{\n\t\tunsigned lcore_id, len;\n\t\tstruct lcore_queue_conf *qconf;\n\n\t\tlcore_id = rte_lcore_id();\n\n\t\tqconf = &lcore_queue_conf[lcore_id];\n\t\tlen = qconf->tx_mbufs[port].len;\n\t\tqconf->tx_mbufs[port].m_table[len] = m;\n\t\tlen++;\n\n\t\t//当发包队列存够MAX_PKT_BURST，发包\n\t\tif (unlikely(len == MAX_PKT_BURST)) {\n\t\t\tl2fwd_send_burst(qconf, MAX_PKT_BURST, port);\n\t\t\tlen = 0;\n\t\t}\n\n\t\tqconf->tx_mbufs[port].len = len;\n\t\treturn 0;\n\t}\n```\n\n每隔一定时间也会发包\n``` C\n\t//上次收包时间和这次收包时间差\n\tdiff_tsc = cur_tsc - prev_tsc;\n\t//如果时间差大于我们设定的阈值，这里是100us\n\tif (unlikely(diff_tsc > drain_tsc)) {\n\n\t\tfor (portid = 0; portid < RTE_MAX_ETHPORTS; portid++) {\t\t\t\n\t\t\tif (qconf->tx_mbufs[portid].len == 0)\n\t\t\t\tcontinue;\n\t\t\t//发包\n\t\t\tl2fwd_send_burst(&lcore_queue_conf[lcore_id],\n\t\t\t\t\t qconf->tx_mbufs[portid].len,\n\t\t\t\t\t (uint8_t) portid);\n\t\t\t\t\tqconf->tx_mbufs[portid].len = 0;\n\t\t}\n\t\t\n\t\tif (timer_period > 0) {\n\t\t\t\t\n\t\t\ttimer_tsc += diff_tsc;\n\n\t\t\t//如果累积时间超过我们设定的阈值，就打印出统计数据，默认是10s\n\t\t\tif (unlikely(timer_tsc >= (uint64_t) timer_period)) {\n\n\t\t\t\t//打印数据在发生在主逻辑内核上\n\t\t\t\tif (lcore_id == rte_get_master_lcore()) {\n\t\t\t\t\t//打印统计数据\n\t\t\t\t\tprint_stats();\n\t\t\t\t\t//累积时间置零\n\t\t\t\t\ttimer_tsc = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprev_tsc = cur_tsc;\n\t}\n```\n这两种情况都会产生发包，无论是发送队列存够阈值MAX_PKT_BURST，或者，时间差超过阈值brain_tsc，都会把发送队列上MAX_PKT_BURST个数据包推送出去，如果不足MAX_PKT_BURST，则把发送队列上全部数据包推送出去。\n\n发包函数\n``` C\n\tstatic int\n\tl2fwd_send_burst(struct lcore_queue_conf *qconf, unsigned n, uint8_t port)\n\t{\n\t\tstruct rte_mbuf **m_table;\n\t\tunsigned ret;\n\t\tunsigned queueid =0;\n\n\t\tm_table = (struct rte_mbuf **)qconf->tx_mbufs[port].m_table;\n\t\t//发包\n\t\tret = rte_eth_tx_burst(port, (uint16_t) queueid, m_table, (uint16_t) n);\n\t\t//更新统计数据\n\t\tport_statistics[port].tx += ret;\n\t\t//丢包\n\t\tif (unlikely(ret < n)) {\n\t\t\t//更新统计数据\n\t\t\tport_statistics[port].dropped += (n - ret);\n\t\t\tdo {\n\t\t\t\t//把丢包部分free掉\n\t\t\t\trte_pktmbuf_free(m_table[ret]);\n\t\t\t} while (++ret < n);\n\t\t}\n\n\t\treturn 0;\n\t}\n```\n在函数rte_eth_tx_burst()中：\n- port：端口号。\n- queueid：端口中的发送队列号。本例中每个端口都只有一个发送队列，所以固定为0。\n- m_table：**rte_mbuf数据\n- n：发送包的数量\n\n","slug":"dpdk_l2fwd","published":1,"updated":"2015-07-13T10:48:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cicflp6jl000rr2o35cms3x4g"},{"title":"dpdk编译运行","toc":true,"date":"2015-04-28T06:46:52.000Z","_content":"\nDPDK（Data Plane Development kit）是Intel发布的数据包处理转发套件。\n\n<!--more-->\n**Title: [dpdk编译运行](https://aidaizyy.github.io/dpdk)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-04-28](http://aidaizyy.github.io)**\n\n##下载\n\n下载DPDK-2.0.0\n``` bash\nwget http://www.dpdk.org/browse/dpdk/snapshot/dpdk-2.0.0.tar.gz\n```\n或者直接访问http://www.dpdk.org/download/ 下载最新的版本。\n\n解开压缩包\n``` bash\ntar -xvzf dpdk-2.0.0.tar.gz\n```\n\n##准备\n\n### linux kernel header\n\n确保系统是否已安装linux kernel header，未安装则：\n``` bash\nsudo apt-get install linux-header-3.13.0-49-generic\n```\n\nlinux kernel版本号由系统本身决定，以下命令查看：\n``` bash\nuname -r\n```\n\nkernel版本号必须大于2.6.33。\n同时glibc版本号大于2.7。\n\n### libpcap函数库\n\n``` bash\nsudo apt-get install libpcap-dev\n```\n\n### hugepages\n\n查看kernel是否支持hugepapse\n``` bash\ngrep -i huge /boot/config-3.13.0-49-generic\n```\n同样，kernel版本号由系统本身决定。\n如果出现\n``` bash\nCONFIG_HUGETLBFS=y\nCONFIG_HUGETLB_PAGE=y\n```\n则表示支持hugepages。\n\n查看当前系统hugepages信息\n``` bash\ngrep -i huge /proc/meminfo\n```\n\n配置hugepages\n``` bash\nvi /etc/sysctl.conf\n#在文件底部添加\nvm.nr_hugepages=512\n#表示hugepages的页面数量\n\nvi /etc/fstab\n#在文件底部添加\nhuge /mnt/huge hugetlbfs defaults 0 0\n\nmkdir /mnt/huge\nchmod 777 /mnt/huge\n```\n\n重新启动后查看/proc/meminfo 就会发现hugepages已经加载。\n``` bash\nAnonHugePages:     53248 kB\nHugePages_Total:     512\nHugePages_Free:      512\nHugePages_Rsvd:        0\nHugePages_Surp:        0\nHugepagesize:       2048 kB\n```\n\n##编译\n``` bash\ncd dpdk-2.0.0\nmake install T=x86_64-native-linuxapp-gcc\n```\nx86_64指x86构架64位系统。如果是32位系统，将x86_64替换为i686。\n\n官网给出的编译平台规范是ARCH-MACHINE-EXECENV-TOOLCHAIN\nARCH can be: i686, x86_64, ppc_64\nMACHINE can be: native, ivshmem, power8\nEXECENV can be: linuxapp, bsdapp\nTOOLCHAIN can be: gcc, icc\n\n这里在Ubuntu Linux 64位系统本地环境下gcc工具编译\n\n也可以先设置，再编译。\n``` bash\nmake config T=x86_64-native-linuxapp-gcc\nmake\n```\n\nmake install会将编译后的文件放入新建的x86_64-native-linuxapp-gcc目录。\nmake config + make会将编译后的文件放入新建的build目录。\n\n##加载模块\n\n``` bash\nsudo modprobe uio\nsudo insmod kmod/igb_uio.ko\n```\nuio是kernel自带的用户空间IO模块\nigb_uio是dpdk编译的模块，出现在dpdk-2.0.0/build/kmod 或者dpdk-2.0.0/x86_64-native-linuxapp-gcc/kmod 目录中。\n\n##绑定网卡\n\n查看当前网卡信息\n``` bash\ncd dpdk-2.0.0\n./tools/dpdk_nic_bind.py --status\n\nNetwork devices using kernel driver\n===================================\n0000:00:05.0 '82545EM Gigabit Ethernet Controller (Copper)' if=eth0 drv=e1000 unused= *Active*\n0000:00:06.0 '82545EM Gigabit Ethernet Controller (Copper)' if=eth1 drv=e1000 unused= *Active*\n0000:00:07.0 '82545EM Gigabit Ethernet Controller (Copper)' if=eth3 drv=e1000 unused= *Active*\n\nOther network devices\n=====================\n<none>\n\n```\n\n绑定网卡\n``` bash\n./tools/dpdk_nic_bind.py --bind=igb_uio 00:05.0\n``` \n\n绑定之前，保证网卡处于非活跃状态\n``` bash\nifconfig eth0 down\n```\n\n##运行示例\n\n运行helloworld示例\n``` bash\n#添加环境变量\nexport RTE_SDK=$SDK/dpdp-2.0.0\nexport RTE_TARGET=x86_64-native-linuxapp-gcc\n\n#编译\ncd /dpdk-2.0.0/example/helloworld\nmake\n\n#运行\n./build/helloworld -c 3 -n 2\n\nhello from core 1\nhello from core 0\n```\n\n这里的RTE_SDK指dpdk主目录的路径。\n\n-c COREMASK -n NUM为必须参数\nCOREMASK: 一个十六进制位掩码表示分配的逻辑内核数量。\nNUM: 一个十进制整数表示内存通道数量。\n\n运行完成后，显示\nhello from core 1\nhello from core 0。\n\n其他示例程序参数有不同要求，参见官方网站的说明文档。\n\n##脚本安装\n\nDPDK提供了更简单的脚本安装。\n在解开压缩包和设置好环境变量RTE_SDK和RTE_TARGET后，运行setup.sh脚本。\n``` bash\ncd /dpdk-2.0.0\n./tools/setup.sh\n\n----------------------------------------------------------\n Step 1: Select the DPDK environment to build\n----------------------------------------------------------\n[1] i686-native-linuxapp-gcc\n[2] i686-native-linuxapp-icc\n[3] ppc_64-power8-linuxapp-gcc\n[4] x86_64-ivshmem-linuxapp-gcc\n[5] x86_64-ivshmem-linuxapp-icc\n[6] x86_64-native-bsdapp-clang\n[7] x86_64-native-bsdapp-gcc\n[8] x86_64-native-linuxapp-clang\n[9] x86_64-native-linuxapp-gcc\n[10] x86_64-native-linuxapp-icc\n[11] x86_x32-native-linuxapp-gcc\n\n----------------------------------------------------------\n Step 2: Setup linuxapp environment\n----------------------------------------------------------\n[12] Insert IGB UIO module\n[13] Insert VFIO module\n[14] Insert KNI module\n[15] Setup hugepage mappings for non-NUMA systems\n[16] Setup hugepage mappings for NUMA systems\n[17] Display current Ethernet device settings\n[18] Bind Ethernet device to IGB UIO module\n[19] Bind Ethernet device to VFIO module\n[20] Setup VFIO permissions\n\n----------------------------------------------------------\n Step 3: Run test application for linuxapp environment\n----------------------------------------------------------\n[21] Run test application ($RTE_TARGET/app/test)\n[22] Run testpmd application in interactive mode ($RTE_TARGET/app/testpmd)\n\n----------------------------------------------------------\n Step 4: Other tools\n----------------------------------------------------------\n[23] List hugepage info from /proc/meminfo\n\n----------------------------------------------------------\n Step 5: Uninstall and system cleanup\n----------------------------------------------------------\n[24] Uninstall all targets\n[25] Unbind NICs from IGB UIO or VFIO driver\n[26] Remove IGB UIO module\n[27] Remove VFIO module\n[28] Remove KNI module\n[29] Remove hugepage mappings\n\n[30] Exit Script\n\nOption: \n```\n按照脚本指示一步一步运行即可。\n依次执行9-12-15-18就可以达到和上面一样的结果。\n当然不同情况，脚本执行步骤不同。\n\n##示例程序\n\n几个值得关注的示例程序。\n\n- testpmd: 测试程序，可以在setup.sh脚本中运行或者在app/ 目录下。\n\t文档: http://www.dpdk.org/doc/guides/testpmd_app_ug/index.html\n\n- l2fwd: 链路层转发程序，在example/ 目录下。\n\texample /目录下有很多其他值得关注的示例程序。\n\t文档: http://www.dpdk.org/doc/guides/sample_app_ug/index.html\n\n- pktgen-dpdk: 基于DPDK的高速发包程序\n\tDPDK官方网站：http://www.dpdk.org/browse/apps/pktgen-dpdk \n\tGithub：http://github.com/pktgen/Pktgen-DPDK\n\n","source":"_posts/dpdk.md","raw":"title: dpdk编译运行\ntoc: true\ndate: 2015-04-28 14:46:52\ntags: \n- dpdk\ncategories: dpdk\n---\n\nDPDK（Data Plane Development kit）是Intel发布的数据包处理转发套件。\n\n<!--more-->\n**Title: [dpdk编译运行](https://aidaizyy.github.io/dpdk)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-04-28](http://aidaizyy.github.io)**\n\n##下载\n\n下载DPDK-2.0.0\n``` bash\nwget http://www.dpdk.org/browse/dpdk/snapshot/dpdk-2.0.0.tar.gz\n```\n或者直接访问http://www.dpdk.org/download/ 下载最新的版本。\n\n解开压缩包\n``` bash\ntar -xvzf dpdk-2.0.0.tar.gz\n```\n\n##准备\n\n### linux kernel header\n\n确保系统是否已安装linux kernel header，未安装则：\n``` bash\nsudo apt-get install linux-header-3.13.0-49-generic\n```\n\nlinux kernel版本号由系统本身决定，以下命令查看：\n``` bash\nuname -r\n```\n\nkernel版本号必须大于2.6.33。\n同时glibc版本号大于2.7。\n\n### libpcap函数库\n\n``` bash\nsudo apt-get install libpcap-dev\n```\n\n### hugepages\n\n查看kernel是否支持hugepapse\n``` bash\ngrep -i huge /boot/config-3.13.0-49-generic\n```\n同样，kernel版本号由系统本身决定。\n如果出现\n``` bash\nCONFIG_HUGETLBFS=y\nCONFIG_HUGETLB_PAGE=y\n```\n则表示支持hugepages。\n\n查看当前系统hugepages信息\n``` bash\ngrep -i huge /proc/meminfo\n```\n\n配置hugepages\n``` bash\nvi /etc/sysctl.conf\n#在文件底部添加\nvm.nr_hugepages=512\n#表示hugepages的页面数量\n\nvi /etc/fstab\n#在文件底部添加\nhuge /mnt/huge hugetlbfs defaults 0 0\n\nmkdir /mnt/huge\nchmod 777 /mnt/huge\n```\n\n重新启动后查看/proc/meminfo 就会发现hugepages已经加载。\n``` bash\nAnonHugePages:     53248 kB\nHugePages_Total:     512\nHugePages_Free:      512\nHugePages_Rsvd:        0\nHugePages_Surp:        0\nHugepagesize:       2048 kB\n```\n\n##编译\n``` bash\ncd dpdk-2.0.0\nmake install T=x86_64-native-linuxapp-gcc\n```\nx86_64指x86构架64位系统。如果是32位系统，将x86_64替换为i686。\n\n官网给出的编译平台规范是ARCH-MACHINE-EXECENV-TOOLCHAIN\nARCH can be: i686, x86_64, ppc_64\nMACHINE can be: native, ivshmem, power8\nEXECENV can be: linuxapp, bsdapp\nTOOLCHAIN can be: gcc, icc\n\n这里在Ubuntu Linux 64位系统本地环境下gcc工具编译\n\n也可以先设置，再编译。\n``` bash\nmake config T=x86_64-native-linuxapp-gcc\nmake\n```\n\nmake install会将编译后的文件放入新建的x86_64-native-linuxapp-gcc目录。\nmake config + make会将编译后的文件放入新建的build目录。\n\n##加载模块\n\n``` bash\nsudo modprobe uio\nsudo insmod kmod/igb_uio.ko\n```\nuio是kernel自带的用户空间IO模块\nigb_uio是dpdk编译的模块，出现在dpdk-2.0.0/build/kmod 或者dpdk-2.0.0/x86_64-native-linuxapp-gcc/kmod 目录中。\n\n##绑定网卡\n\n查看当前网卡信息\n``` bash\ncd dpdk-2.0.0\n./tools/dpdk_nic_bind.py --status\n\nNetwork devices using kernel driver\n===================================\n0000:00:05.0 '82545EM Gigabit Ethernet Controller (Copper)' if=eth0 drv=e1000 unused= *Active*\n0000:00:06.0 '82545EM Gigabit Ethernet Controller (Copper)' if=eth1 drv=e1000 unused= *Active*\n0000:00:07.0 '82545EM Gigabit Ethernet Controller (Copper)' if=eth3 drv=e1000 unused= *Active*\n\nOther network devices\n=====================\n<none>\n\n```\n\n绑定网卡\n``` bash\n./tools/dpdk_nic_bind.py --bind=igb_uio 00:05.0\n``` \n\n绑定之前，保证网卡处于非活跃状态\n``` bash\nifconfig eth0 down\n```\n\n##运行示例\n\n运行helloworld示例\n``` bash\n#添加环境变量\nexport RTE_SDK=$SDK/dpdp-2.0.0\nexport RTE_TARGET=x86_64-native-linuxapp-gcc\n\n#编译\ncd /dpdk-2.0.0/example/helloworld\nmake\n\n#运行\n./build/helloworld -c 3 -n 2\n\nhello from core 1\nhello from core 0\n```\n\n这里的RTE_SDK指dpdk主目录的路径。\n\n-c COREMASK -n NUM为必须参数\nCOREMASK: 一个十六进制位掩码表示分配的逻辑内核数量。\nNUM: 一个十进制整数表示内存通道数量。\n\n运行完成后，显示\nhello from core 1\nhello from core 0。\n\n其他示例程序参数有不同要求，参见官方网站的说明文档。\n\n##脚本安装\n\nDPDK提供了更简单的脚本安装。\n在解开压缩包和设置好环境变量RTE_SDK和RTE_TARGET后，运行setup.sh脚本。\n``` bash\ncd /dpdk-2.0.0\n./tools/setup.sh\n\n----------------------------------------------------------\n Step 1: Select the DPDK environment to build\n----------------------------------------------------------\n[1] i686-native-linuxapp-gcc\n[2] i686-native-linuxapp-icc\n[3] ppc_64-power8-linuxapp-gcc\n[4] x86_64-ivshmem-linuxapp-gcc\n[5] x86_64-ivshmem-linuxapp-icc\n[6] x86_64-native-bsdapp-clang\n[7] x86_64-native-bsdapp-gcc\n[8] x86_64-native-linuxapp-clang\n[9] x86_64-native-linuxapp-gcc\n[10] x86_64-native-linuxapp-icc\n[11] x86_x32-native-linuxapp-gcc\n\n----------------------------------------------------------\n Step 2: Setup linuxapp environment\n----------------------------------------------------------\n[12] Insert IGB UIO module\n[13] Insert VFIO module\n[14] Insert KNI module\n[15] Setup hugepage mappings for non-NUMA systems\n[16] Setup hugepage mappings for NUMA systems\n[17] Display current Ethernet device settings\n[18] Bind Ethernet device to IGB UIO module\n[19] Bind Ethernet device to VFIO module\n[20] Setup VFIO permissions\n\n----------------------------------------------------------\n Step 3: Run test application for linuxapp environment\n----------------------------------------------------------\n[21] Run test application ($RTE_TARGET/app/test)\n[22] Run testpmd application in interactive mode ($RTE_TARGET/app/testpmd)\n\n----------------------------------------------------------\n Step 4: Other tools\n----------------------------------------------------------\n[23] List hugepage info from /proc/meminfo\n\n----------------------------------------------------------\n Step 5: Uninstall and system cleanup\n----------------------------------------------------------\n[24] Uninstall all targets\n[25] Unbind NICs from IGB UIO or VFIO driver\n[26] Remove IGB UIO module\n[27] Remove VFIO module\n[28] Remove KNI module\n[29] Remove hugepage mappings\n\n[30] Exit Script\n\nOption: \n```\n按照脚本指示一步一步运行即可。\n依次执行9-12-15-18就可以达到和上面一样的结果。\n当然不同情况，脚本执行步骤不同。\n\n##示例程序\n\n几个值得关注的示例程序。\n\n- testpmd: 测试程序，可以在setup.sh脚本中运行或者在app/ 目录下。\n\t文档: http://www.dpdk.org/doc/guides/testpmd_app_ug/index.html\n\n- l2fwd: 链路层转发程序，在example/ 目录下。\n\texample /目录下有很多其他值得关注的示例程序。\n\t文档: http://www.dpdk.org/doc/guides/sample_app_ug/index.html\n\n- pktgen-dpdk: 基于DPDK的高速发包程序\n\tDPDK官方网站：http://www.dpdk.org/browse/apps/pktgen-dpdk \n\tGithub：http://github.com/pktgen/Pktgen-DPDK\n\n","slug":"dpdk","published":1,"updated":"2015-07-13T10:08:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cicflp6jo000wr2o3vd4a99ia"},{"title":"Android代码混淆（Proguard）","date":"2015-07-13T03:42:52.000Z","toc":true,"_content":"\nAndroid采用Java语言，编译成class文件，会很容易被反编译为java源代码。为了代码不被反编译，往往采用代码混淆。Android自带Proguard可以完成这项工作，同时删除没有使用的字段属性等，优化代码。\n\n<!--more-->\n**Title: [Android代码混淆（Proguard）](https://aidaizyy.github.io/android_proguard)**\n**Author: [Yunyao Zhang（张云尧）](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-13](http://aidaizyy.github.io)**\n\n##概要\n\nProguard并没有改变程序结构，只是通过修改名称，调整顺序等措施将代码变得难以阅读，难以理解，但却可以运行。\n在Android项目的主目录里自带proguard-project.txt文件，代码混淆的规则就写在里面。\n\n##配置\n\n主目录的project.properties文件需要加上下面这句话，以告诉项目需要运行Proguard：\n\n_proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt_ \n\n创建好的Android项目一般自带这条语句，不过开头用#注释了，去掉#即可。\n\n##规则\n_摘抄自http://blog.csdn.net/banketree/article/details/41928175_\n\n``` bash\n-include {filename}    从给定的文件中读取配置参数 \n-basedirectory {directoryname}    指定基础目录为以后相对的档案名称 \n-injars {class_path}    指定要处理的应用程序jar,war,ear和目录 \n-outjars {class_path}    指定处理完后要输出的jar,war,ear和目录的名称 \n-libraryjars {classpath}    指定要处理的应用程序jar,war,ear和目录所需要的程序库文件 \n-dontskipnonpubliclibraryclasses    指定不去忽略非公共的库类。 \n-dontskipnonpubliclibraryclassmembers    指定不去忽略包可见的库类的成员。\n\n保留选项 \n-keep {Modifier} {class_specification}    保护指定的类文件和类的成员 \n-keepclassmembers {modifier} {class_specification}    保护指定类的成员，如果此类受到保护他们会保护的更好\n-keepclasseswithmembers {class_specification}    保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。 \n-keepnames {class_specification}    保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除） \n-keepclassmembernames {class_specification}    保护指定的类的成员的名称（如果他们不会压缩步骤中删除） \n-keepclasseswithmembernames {class_specification}    保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后） \n-printseeds {filename}    列出类和类的成员-keep选项的清单，标准输出到给定的文件 \n\n压缩 \n-dontshrink    不压缩输入的类文件 \n-printusage {filename} \n-whyareyoukeeping {class_specification}     \n\n优化 \n-dontoptimize    不优化输入的类文件 \n-assumenosideeffects {class_specification}    优化时假设指定的方法，没有任何副作用 \n-allowaccessmodification    优化时允许访问并修改有修饰符的类和类的成员 \n\n混淆 \n-dontobfuscate    不混淆输入的类文件 \n-printmapping {filename} \n-applymapping {filename}    重用映射增加混淆 \n-obfuscationdictionary {filename}    使用给定文件中的关键字作为要混淆方法的名称 \n-overloadaggressively    混淆时应用侵入式重载 \n-useuniqueclassmembernames    确定统一的混淆类的成员名称来增加混淆 \n-flattenpackagehierarchy {package_name}    重新包装所有重命名的包并放在给定的单一包中 \n-repackageclass {package_name}    重新包装所有重命名的类文件中放在给定的单一包中 \n-dontusemixedcaseclassnames    混淆时不会产生形形色色的类名 \n-keepattributes {attribute_name,...}    保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, Deprecated, Synthetic, Signature, and InnerClasses. \n-renamesourcefileattribute {string}    设置源文件中给定的字符串常量\n```\n\n##实例\n\nproject-proguard.txt中创建混淆规则。\n缺省情况下会混淆所有代码，导致出错，必须保证不能被混淆的代码被保持。\n\n``` java\n-ignorewarnings\t\t\t\t# 忽略警告，避免打包时某些警告出现\n-optimizationpasses 5\t\t\t# 指定代码的压缩级别\n-dontusemixedcaseclassnames\t\t# 是否使用大小写混合\n-dontskipnonpubliclibraryclasses\t# 是否混淆第三方jar\n-dontpreverify                   \t# 混淆时是否做预校验\n-verbose                            \t# 混淆时是否记录日志\n-optimizations !code/simplification/arithmetic,!field/\\*,!class/merging/\\*\t# 混淆时所采用的算法\n\n-keepattributes \\*Annotation\\*\n-keepattributes Signature\n\n-libraryjars   libs/treecore.jar\t# 保持第三方jar包不被混淆\n-libraryjars   libs/android-viewbadger.jar\n-libraryjars   libs/MapApi.jar\n-libraryjars   libs/SinaWeiboSDK.jar\n\n-dontwarn android.support.v4.**     \n-dontwarn android.os.**\n\n-keep class android.support.v4.** { *; } \t\t# 保持哪些类不被混淆\n-keep class com.baidu.** { *; }  \n-keep class vi.com.gdi.bgl.android.**{*;}\n-keep class android.os.**{*;}\n\n-keep interface android.support.v4.app.** { *; }  \n-keep public class * extends android.support.v4.**  \n-keep public class * extends android.app.Fragment\n-keep public class * extends android.app.Activity\n-keep public class * extends android.app.Application\n-keep public class * extends android.app.Service\n-keep public class * extends android.content.BroadcastReceiver\n-keep public class * extends android.content.ContentProvider\n-keep public class * extends android.support.v4.widget\n-keep public class * extends com.sqlcrypt.database\n-keep public class * extends com.sqlcrypt.database.sqlite\n-keep public class * extends com.treecore.**\n-keep public class * extends de.greenrobot.dao.**\n\n\n-keepclasseswithmembernames class * {\t# 保持 native 方法不被混淆\n    native <methods>;\n}\n\n-keepclasseswithmembers class * {\t# 保持自定义控件类不被混淆\n    public <init>(android.content.Context, android.util.AttributeSet);\n}\n\n-keepclasseswithmembers class * {\t# 保持自定义控件类不被混淆\n    public <init>(android.content.Context, android.util.AttributeSet, int);\n}\n\n-keepclassmembers class * extends android.app.Activity {\t#保持类成员\n   public void *(android.view.View);\n}\n\n-keepclassmembers enum * {\t# 保持枚举 enum 类不被混淆\n    public static **[] values();\n    public static ** valueOf(java.lang.String);\n}\n\n-keep class * implements android.os.Parcelable {\t# 保持 Parcelable 不被混淆\n  public static final android.os.Parcelable$Creator *;\n}\n\n-keep class MyClass;\t# 保持自己定义的类不被混淆\n```\n##反编译\n\ndex2jar：将apk转化为class文件\n``` bash\nhttps://github.com/pxb1988/dex2jar \n```\nJD-GUI：将class文件转化为java文件\n``` bash\nhttp://jd.benow.ca/ \n```\n\n通过这个两个工具可以将apk转化为java源文件。\n通过Proguard生成的apk可转化为java源文件来进行比对以检测Proguard是否生效。\n","source":"_posts/android_proguard.md","raw":"title: \"Android代码混淆（Proguard）\"\ndate: 2015-07-13 11:42:52\ntags:\n- android\n- proguard\ncategories: android\ntoc: true\n---\n\nAndroid采用Java语言，编译成class文件，会很容易被反编译为java源代码。为了代码不被反编译，往往采用代码混淆。Android自带Proguard可以完成这项工作，同时删除没有使用的字段属性等，优化代码。\n\n<!--more-->\n**Title: [Android代码混淆（Proguard）](https://aidaizyy.github.io/android_proguard)**\n**Author: [Yunyao Zhang（张云尧）](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-13](http://aidaizyy.github.io)**\n\n##概要\n\nProguard并没有改变程序结构，只是通过修改名称，调整顺序等措施将代码变得难以阅读，难以理解，但却可以运行。\n在Android项目的主目录里自带proguard-project.txt文件，代码混淆的规则就写在里面。\n\n##配置\n\n主目录的project.properties文件需要加上下面这句话，以告诉项目需要运行Proguard：\n\n_proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt_ \n\n创建好的Android项目一般自带这条语句，不过开头用#注释了，去掉#即可。\n\n##规则\n_摘抄自http://blog.csdn.net/banketree/article/details/41928175_\n\n``` bash\n-include {filename}    从给定的文件中读取配置参数 \n-basedirectory {directoryname}    指定基础目录为以后相对的档案名称 \n-injars {class_path}    指定要处理的应用程序jar,war,ear和目录 \n-outjars {class_path}    指定处理完后要输出的jar,war,ear和目录的名称 \n-libraryjars {classpath}    指定要处理的应用程序jar,war,ear和目录所需要的程序库文件 \n-dontskipnonpubliclibraryclasses    指定不去忽略非公共的库类。 \n-dontskipnonpubliclibraryclassmembers    指定不去忽略包可见的库类的成员。\n\n保留选项 \n-keep {Modifier} {class_specification}    保护指定的类文件和类的成员 \n-keepclassmembers {modifier} {class_specification}    保护指定类的成员，如果此类受到保护他们会保护的更好\n-keepclasseswithmembers {class_specification}    保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。 \n-keepnames {class_specification}    保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除） \n-keepclassmembernames {class_specification}    保护指定的类的成员的名称（如果他们不会压缩步骤中删除） \n-keepclasseswithmembernames {class_specification}    保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后） \n-printseeds {filename}    列出类和类的成员-keep选项的清单，标准输出到给定的文件 \n\n压缩 \n-dontshrink    不压缩输入的类文件 \n-printusage {filename} \n-whyareyoukeeping {class_specification}     \n\n优化 \n-dontoptimize    不优化输入的类文件 \n-assumenosideeffects {class_specification}    优化时假设指定的方法，没有任何副作用 \n-allowaccessmodification    优化时允许访问并修改有修饰符的类和类的成员 \n\n混淆 \n-dontobfuscate    不混淆输入的类文件 \n-printmapping {filename} \n-applymapping {filename}    重用映射增加混淆 \n-obfuscationdictionary {filename}    使用给定文件中的关键字作为要混淆方法的名称 \n-overloadaggressively    混淆时应用侵入式重载 \n-useuniqueclassmembernames    确定统一的混淆类的成员名称来增加混淆 \n-flattenpackagehierarchy {package_name}    重新包装所有重命名的包并放在给定的单一包中 \n-repackageclass {package_name}    重新包装所有重命名的类文件中放在给定的单一包中 \n-dontusemixedcaseclassnames    混淆时不会产生形形色色的类名 \n-keepattributes {attribute_name,...}    保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, Deprecated, Synthetic, Signature, and InnerClasses. \n-renamesourcefileattribute {string}    设置源文件中给定的字符串常量\n```\n\n##实例\n\nproject-proguard.txt中创建混淆规则。\n缺省情况下会混淆所有代码，导致出错，必须保证不能被混淆的代码被保持。\n\n``` java\n-ignorewarnings\t\t\t\t# 忽略警告，避免打包时某些警告出现\n-optimizationpasses 5\t\t\t# 指定代码的压缩级别\n-dontusemixedcaseclassnames\t\t# 是否使用大小写混合\n-dontskipnonpubliclibraryclasses\t# 是否混淆第三方jar\n-dontpreverify                   \t# 混淆时是否做预校验\n-verbose                            \t# 混淆时是否记录日志\n-optimizations !code/simplification/arithmetic,!field/\\*,!class/merging/\\*\t# 混淆时所采用的算法\n\n-keepattributes \\*Annotation\\*\n-keepattributes Signature\n\n-libraryjars   libs/treecore.jar\t# 保持第三方jar包不被混淆\n-libraryjars   libs/android-viewbadger.jar\n-libraryjars   libs/MapApi.jar\n-libraryjars   libs/SinaWeiboSDK.jar\n\n-dontwarn android.support.v4.**     \n-dontwarn android.os.**\n\n-keep class android.support.v4.** { *; } \t\t# 保持哪些类不被混淆\n-keep class com.baidu.** { *; }  \n-keep class vi.com.gdi.bgl.android.**{*;}\n-keep class android.os.**{*;}\n\n-keep interface android.support.v4.app.** { *; }  \n-keep public class * extends android.support.v4.**  \n-keep public class * extends android.app.Fragment\n-keep public class * extends android.app.Activity\n-keep public class * extends android.app.Application\n-keep public class * extends android.app.Service\n-keep public class * extends android.content.BroadcastReceiver\n-keep public class * extends android.content.ContentProvider\n-keep public class * extends android.support.v4.widget\n-keep public class * extends com.sqlcrypt.database\n-keep public class * extends com.sqlcrypt.database.sqlite\n-keep public class * extends com.treecore.**\n-keep public class * extends de.greenrobot.dao.**\n\n\n-keepclasseswithmembernames class * {\t# 保持 native 方法不被混淆\n    native <methods>;\n}\n\n-keepclasseswithmembers class * {\t# 保持自定义控件类不被混淆\n    public <init>(android.content.Context, android.util.AttributeSet);\n}\n\n-keepclasseswithmembers class * {\t# 保持自定义控件类不被混淆\n    public <init>(android.content.Context, android.util.AttributeSet, int);\n}\n\n-keepclassmembers class * extends android.app.Activity {\t#保持类成员\n   public void *(android.view.View);\n}\n\n-keepclassmembers enum * {\t# 保持枚举 enum 类不被混淆\n    public static **[] values();\n    public static ** valueOf(java.lang.String);\n}\n\n-keep class * implements android.os.Parcelable {\t# 保持 Parcelable 不被混淆\n  public static final android.os.Parcelable$Creator *;\n}\n\n-keep class MyClass;\t# 保持自己定义的类不被混淆\n```\n##反编译\n\ndex2jar：将apk转化为class文件\n``` bash\nhttps://github.com/pxb1988/dex2jar \n```\nJD-GUI：将class文件转化为java文件\n``` bash\nhttp://jd.benow.ca/ \n```\n\n通过这个两个工具可以将apk转化为java源文件。\n通过Proguard生成的apk可转化为java源文件来进行比对以检测Proguard是否生效。\n","slug":"android_proguard","published":1,"updated":"2015-07-13T10:36:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cicflp6jq000zr2o3w5f9789g"}],"PostAsset":[],"PostCategory":[{"post_id":"cicflp6is0002r2o3tvi7aq5y","category_id":"cicflp6iw0003r2o3tovushb3","_id":"cicflp6iy0006r2o3u8prfvw5"},{"post_id":"cicflp6j50009r2o3ew57eity","category_id":"cicflp6iw0003r2o3tovushb3","_id":"cicflp6j6000ar2o3nrtvrsys"},{"post_id":"cicflp6j7000cr2o3odb1lp7d","category_id":"cicflp6iw0003r2o3tovushb3","_id":"cicflp6j8000dr2o3kfccycmu"},{"post_id":"cicflp6j9000fr2o388lhug9w","category_id":"cicflp6iw0003r2o3tovushb3","_id":"cicflp6j9000gr2o3xxzplj80"},{"post_id":"cicflp6jb000ir2o3ovopoajy","category_id":"cicflp6iw0003r2o3tovushb3","_id":"cicflp6jc000jr2o3wcrvwvc6"},{"post_id":"cicflp6jd000lr2o3xswhyoth","category_id":"cicflp6iw0003r2o3tovushb3","_id":"cicflp6jg000mr2o3zkkii9do"},{"post_id":"cicflp6ji000or2o3mprxa409","category_id":"cicflp6iw0003r2o3tovushb3","_id":"cicflp6jj000pr2o3himuhptk"},{"post_id":"cicflp6jl000rr2o35cms3x4g","category_id":"cicflp6jl000sr2o3q8362x2u","_id":"cicflp6jn000vr2o313wwwij3"},{"post_id":"cicflp6jo000wr2o3vd4a99ia","category_id":"cicflp6jl000sr2o3q8362x2u","_id":"cicflp6jp000xr2o3btkzczxu"},{"post_id":"cicflp6jq000zr2o3w5f9789g","category_id":"cicflp6jr0010r2o3kjwl90kf","_id":"cicflp6js0013r2o378btoh7c"}],"PostTag":[{"post_id":"cicflp6is0002r2o3tvi7aq5y","tag_id":"cicflp6iw0004r2o3erodee7q","_id":"cicflp6iy0005r2o3oypl9evb"},{"post_id":"cicflp6j00007r2o3jhf8q58v","tag_id":"cicflp6iw0004r2o3erodee7q","_id":"cicflp6j30008r2o31u2xr3vj"},{"post_id":"cicflp6j50009r2o3ew57eity","tag_id":"cicflp6iw0004r2o3erodee7q","_id":"cicflp6j6000br2o34re4i3pb"},{"post_id":"cicflp6j7000cr2o3odb1lp7d","tag_id":"cicflp6iw0004r2o3erodee7q","_id":"cicflp6j8000er2o34n5w5wnk"},{"post_id":"cicflp6j9000fr2o388lhug9w","tag_id":"cicflp6iw0004r2o3erodee7q","_id":"cicflp6ja000hr2o3fq0hnvd5"},{"post_id":"cicflp6jb000ir2o3ovopoajy","tag_id":"cicflp6iw0004r2o3erodee7q","_id":"cicflp6jc000kr2o3ifwhxfxp"},{"post_id":"cicflp6jd000lr2o3xswhyoth","tag_id":"cicflp6iw0004r2o3erodee7q","_id":"cicflp6jg000nr2o3xro1a318"},{"post_id":"cicflp6ji000or2o3mprxa409","tag_id":"cicflp6iw0004r2o3erodee7q","_id":"cicflp6jj000qr2o31hmxb2jt"},{"post_id":"cicflp6jl000rr2o35cms3x4g","tag_id":"cicflp6jl000tr2o3le50je6t","_id":"cicflp6jm000ur2o31i68ujzb"},{"post_id":"cicflp6jo000wr2o3vd4a99ia","tag_id":"cicflp6jl000tr2o3le50je6t","_id":"cicflp6jp000yr2o3mdjmpm32"},{"post_id":"cicflp6jq000zr2o3w5f9789g","tag_id":"cicflp6js0011r2o37s9sk7o8","_id":"cicflp6jt0014r2o3g35btp43"},{"post_id":"cicflp6jq000zr2o3w5f9789g","tag_id":"cicflp6js0012r2o3nuyjvca0","_id":"cicflp6jt0015r2o3we0qiqz7"}],"Tag":[{"name":"swift","_id":"cicflp6iw0004r2o3erodee7q"},{"name":"dpdk","_id":"cicflp6jl000tr2o3le50je6t"},{"name":"android","_id":"cicflp6js0011r2o37s9sk7o8"},{"name":"proguard","_id":"cicflp6js0012r2o3nuyjvca0"}]}}