{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/landscape-plus/source/js/script.js","path":"js/script.js","modified":1},{"_id":"source/robots.txt","path":"robots.txt","modified":1},{"_id":"themes/landscape-plus/source/img/scrollup.png","path":"img/scrollup.png","modified":1},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/landscape-plus/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/landscape-plus/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"themes/landscape-plus/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1},{"_id":"themes/landscape-plus/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1},{"_id":"themes/landscape-plus/source/css/bdshare.styl","path":"css/bdshare.styl","modified":1},{"_id":"source/CNAME","path":"CNAME","modified":1}],"Cache":[{"_id":"source/404.html","shasum":"3cb1b23ff4b4b734408dc6f1670046f782a4fc00","modified":1436782474000},{"_id":"source/CNAME","shasum":"f9a607335f7be25feebddb51024d8b6b1b400b68","modified":1430214617000},{"_id":"source/_posts/android_proguard.md","shasum":"921444992a53b2c347a19794fc7155182a0229f3","modified":1436783768000},{"_id":"source/_posts/cache_miss_type.md","shasum":"3bcabcb1eee32ceaf0bacd97f2195ef450d60ed0","modified":1449757561000},{"_id":"source/_posts/dpdk.md","shasum":"5522f12870cc96b7e54046dd8c5a0903d011edfc","modified":1471273803000},{"_id":"source/_posts/dpdk_l2fwd.md","shasum":"86cb9e0b902ed777e1aecbaeb00fa63ca98017b4","modified":1471273848000},{"_id":"source/_posts/hadoop.md","shasum":"bf9f5c12fd3956ec261cebc33700d133ce340438","modified":1464533707000},{"_id":"source/_posts/spdk.md","shasum":"9b87aa9d84f33d45e4293f627952a68e221f3e4a","modified":1471273786000},{"_id":"source/_posts/swift_1.md","shasum":"a1e2458f711d294520bc401d537cd30c97e85c37","modified":1437722531000},{"_id":"source/_posts/swift_10.md","shasum":"b9e36e991568f916a55906412f156ce78c4ad0eb","modified":1437725330000},{"_id":"source/_posts/swift_11.md","shasum":"2a93e5569d813aa70d49d76fd179a7dbe9bab8d3","modified":1438005184000},{"_id":"source/_posts/swift_12.md","shasum":"bdd4de13484aa10bd8a51d9c9721a795e6ab5ad7","modified":1438140722000},{"_id":"source/_posts/swift_13.md","shasum":"9e99eb60dae4f7b0a21cb7180295a53cc55ce0d4","modified":1438140730000},{"_id":"source/_posts/swift_14.md","shasum":"68f80bd63d10ab9e3f23a30e86701ccdb7fd17b4","modified":1438141560000},{"_id":"source/_posts/swift_2.md","shasum":"048ea3523f8dc58d8fb4250f80fbff4c6827f062","modified":1436951824000},{"_id":"source/_posts/swift_3.md","shasum":"0cb8591f637a8823a09712696e18826bab9e5d39","modified":1437468640000},{"_id":"source/_posts/swift_4.md","shasum":"f7729da23039c4788339168f41799660fed019f0","modified":1437468720000},{"_id":"source/_posts/swift_5.md","shasum":"0a893e2a9a5b87d8eb65bcbd25445a8fb4c3fe04","modified":1437578101000},{"_id":"source/_posts/swift_6.md","shasum":"5ac9195d913925ae87ccecf6ff10188144ea21a3","modified":1437728574000},{"_id":"source/_posts/swift_7.md","shasum":"282e6e5f685c578f03b374b09f60216a85d3fcbf","modified":1438310866000},{"_id":"source/_posts/swift_8.md","shasum":"ebe488fa7d2e3f05ce15a2be152ac62bcf73bb1f","modified":1437728699000},{"_id":"source/_posts/swift_9.md","shasum":"11bae333e33c6c7f1ec352106bb72f87b7dcb3c5","modified":1438310855000},{"_id":"source/about/index.md","shasum":"9e582f3bbe7c95508f5f3ac8dfa697fff1e7a931","modified":1438489112000},{"_id":"source/robots.txt","shasum":"4b51c1160118132f8dd0f20d783fc45f40871a32","modified":1430486746000},{"_id":"source/search/index.md","shasum":"22a4054ef7ab92389189ebe7ecb0f7b01e42a850","modified":1471420320000},{"_id":"source/favicon.ico","shasum":"7678474d9b5b54af16295a6b6c0dbe9c3ecd07fc","modified":1430475428000},{"_id":"themes/landscape-plus/Gruntfile.js","shasum":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1430473844000},{"_id":"themes/landscape-plus/LICENSE","shasum":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1430473844000},{"_id":"themes/landscape-plus/README.md","shasum":"04a1227d8fc5a019884fe7f2149d8a3ac9f1a689","modified":1430473844000},{"_id":"themes/landscape-plus/_config.yml","shasum":"7c0e8ea5f05e706e53d639d6fd49648a321fe4ee","modified":1471420265000},{"_id":"themes/landscape-plus/languages/default.yml","shasum":"06f4e3aaa695b5d5a8fb7087e66fdab9749d2527","modified":1430493999000},{"_id":"themes/landscape-plus/languages/zh-CN.yml","shasum":"c7f273107b09217fa10f3e1dd9f4c3e9aae660f2","modified":1430493975000},{"_id":"themes/landscape-plus/layout/_partial/after-footer.ejs","shasum":"937a5053de5ef6333d2230696958798bfd43f7dc","modified":1471508278000},{"_id":"themes/landscape-plus/layout/_partial/archive-post.ejs","shasum":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/archive.ejs","shasum":"d7de6421497ffaf65e4f5fe4bed71fcea51fde80","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/article.ejs","shasum":"011291497daeda65916240eabf5e9eea5a644e2c","modified":1430489727000},{"_id":"themes/landscape-plus/layout/_partial/footer.ejs","shasum":"a02150682b09f3aebe7ae12deef7fa65de2d5af2","modified":1471446005000},{"_id":"themes/landscape-plus/layout/_partial/google-analytics.ejs","shasum":"78823298e9e47d8e6556fc2bb4598fc2814f2d52","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/head.ejs","shasum":"93eb99cadcece8c1428d8287e3a508fb434f7fb3","modified":1471445750000},{"_id":"themes/landscape-plus/layout/_partial/header.ejs","shasum":"0fe2a252f5aed058fc3692ba19bcb4020125a753","modified":1471441384000},{"_id":"themes/landscape-plus/layout/_partial/mathjax.ejs","shasum":"7b3d1a8d27ea674c373022a8f95898b5f1bf4a33","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/mobile-nav.ejs","shasum":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/post/category.ejs","shasum":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/post/date.ejs","shasum":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/post/gallery.ejs","shasum":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/post/nav.ejs","shasum":"16a904de7bceccbb36b4267565f2215704db2880","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/post/tag.ejs","shasum":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/post/title.ejs","shasum":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/search.ejs","shasum":"ac1a98ac1d9aaa98b8ca207b01e66efae40b3234","modified":1471420518000},{"_id":"themes/landscape-plus/layout/_partial/sidebar.ejs","shasum":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_partial/totop.ejs","shasum":"aa3a3eadf31d9b3e4d3081cd3ca61860e55ef553","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_widget/archive.ejs","shasum":"bbb86beab343e08e689a372ddb60bfa782e93bc4","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_widget/category.ejs","shasum":"ae96217d072f637925c907f5f467450083863f50","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_widget/links.ejs","shasum":"231e8caa63e8ab4c12215915e8fa66541a666dab","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_widget/recent_posts.ejs","shasum":"bb4b99b49fb0b647f6c9d8ebb06fc94bbca6b7f7","modified":1437530264000},{"_id":"themes/landscape-plus/layout/_widget/tag.ejs","shasum":"b461390feb5ef82df7aef9677a31d5137c352f61","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_widget/tagcloud.ejs","shasum":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1430473844000},{"_id":"themes/landscape-plus/layout/_widget/weibo.ejs","shasum":"6d8b422e8b2cb4bcd1505ee95db42d17de5cb0e8","modified":1430490483000},{"_id":"themes/landscape-plus/layout/archive.ejs","shasum":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1430473844000},{"_id":"themes/landscape-plus/layout/category.ejs","shasum":"765426a9c8236828dc34759e604cc2c52292835a","modified":1430473844000},{"_id":"themes/landscape-plus/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1430473844000},{"_id":"themes/landscape-plus/layout/layout.ejs","shasum":"3626a74826657529bea744fb014dd9607e9834d0","modified":1430473844000},{"_id":"themes/landscape-plus/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1430473844000},{"_id":"themes/landscape-plus/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1430473844000},{"_id":"themes/landscape-plus/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1430473844000},{"_id":"themes/landscape-plus/package.json","shasum":"b2bc52ea54ee3e5798de96d8f16f55b74af1ab4b","modified":1430475178000},{"_id":"themes/landscape-plus/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_extend.styl","shasum":"3f8a9e4e63b7249408ac54559a5f9633d703e132","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_partial/archive.styl","shasum":"19b5af4e0969d93fb757577bd6ff380ef2224eb9","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_partial/article.styl","shasum":"d7869c19e796c4a59042665576af13fd0c5ba90f","modified":1430489697000},{"_id":"themes/landscape-plus/source/css/_partial/comment.styl","shasum":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_partial/footer.styl","shasum":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_partial/header.styl","shasum":"f8d63b45dcfb9ab343199d6774db9875623f311a","modified":1437365562000},{"_id":"themes/landscape-plus/source/css/_partial/highlight.styl","shasum":"a3c2f696d9477223bd45b49e5f996d7998ae52e5","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_partial/mobile.styl","shasum":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1430651020000},{"_id":"themes/landscape-plus/source/css/_partial/sidebar-aside.styl","shasum":"c9ea5b3956b73418dc8b1572e32eb65dc68ca0e5","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_partial/sidebar-bottom.styl","shasum":"bc5487b9a0bfe5f745423331824d3f3637ccd430","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_partial/sidebar.styl","shasum":"b7bdc11effa98c6d88850eff75634e2ea9207c14","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_partial/totop.styl","shasum":"817f36dd591d6beef9d41011ae8490d31d5e2e50","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_util/grid.styl","shasum":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_util/mixin.styl","shasum":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/_variables.styl","shasum":"7d8a3ff6f9864a0aee94b41db1f0f49e6fd7345d","modified":1430474355000},{"_id":"themes/landscape-plus/source/css/bdshare.styl","shasum":"efb757d9aa21c35f75601dec49533d81b2d9fd08","modified":1471506461000},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.eot","shasum":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.woff","shasum":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/style.styl","shasum":"30fdb982f5324d0023f38c28e83238b9518f2756","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1430473844000},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1430473844000},{"_id":"themes/landscape-plus/source/img/scrollup.png","shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1430473844000},{"_id":"themes/landscape-plus/source/js/script.js","shasum":"f3bc4ff3fb41918a6b58f9b86bf4249ecc6bbb0c","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/fonts/FontAwesome.otf","shasum":"6270a4a561a69fef5f5cc18cdf9efc256ec2ccbe","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.ttf","shasum":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.svg","shasum":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1430473844000},{"_id":"themes/landscape-plus/source/css/images/banner.jpg","shasum":"28bde0491ed558215efe7d4c6f5a9e73ea397ccd","modified":1430651894000},{"_id":"public/js/script.js","modified":1471508300715,"shasum":"f3bc4ff3fb41918a6b58f9b86bf4249ecc6bbb0c"},{"_id":"public/robots.txt","modified":1471508300722,"shasum":"4b51c1160118132f8dd0f20d783fc45f40871a32"},{"_id":"public/img/scrollup.png","modified":1471508300726,"shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3"},{"_id":"public/favicon.ico","modified":1471508300728,"shasum":"7678474d9b5b54af16295a6b6c0dbe9c3ecd07fc"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1471508300735,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1471508300737,"shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1471508300740,"shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1471508300743,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1471508300745,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1471508300747,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1471508300749,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1471508300750,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1471508300752,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1471508300754,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1471508300757,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1471508300760,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1471508300763,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1471508300765,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1471508300768,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1471508301409,"shasum":"70ac490e248ac515ed036ed5c0355b7ab9001f4b"},{"_id":"public/css/images/banner.jpg","modified":1471508301576,"shasum":"28bde0491ed558215efe7d4c6f5a9e73ea397ccd"},{"_id":"public/css/fonts/fontawesome-webfont.woff","modified":1471508301580,"shasum":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c"},{"_id":"public/css/fonts/fontawesome-webfont.ttf","modified":1471508301583,"shasum":"6225ccc4ec94d060f19efab97ca42d842845b949"},{"_id":"public/css/fonts/fontawesome-webfont.svg","modified":1471508301588,"shasum":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9"},{"_id":"public/css/fonts/fontawesome-webfont.eot","modified":1471508301592,"shasum":"0183979056f0b87616cd99d5c54a48f3b771eee6"},{"_id":"public/css/fonts/FontAwesome.otf","modified":1471508301595,"shasum":"6270a4a561a69fef5f5cc18cdf9efc256ec2ccbe"},{"_id":"public/css/bdshare.css","modified":1471508301651,"shasum":"382b2417dc7aa054bb796e084f38fcd2f7c9a15f"},{"_id":"public/CNAME","modified":1471508301696,"shasum":"f9a607335f7be25feebddb51024d8b6b1b400b68"},{"_id":"public/404.html","modified":1471508301722,"shasum":"d1af91416e220b2d038f28210b14b6b8cb855099"},{"_id":"public/search/index.html","modified":1471508301773,"shasum":"00524f16bd27c02a178e2433203505d275e30667"},{"_id":"public/about/index.html","modified":1471508301802,"shasum":"ad2a0c5f3f7bc22397da414a5fe6890f28af6a0b"},{"_id":"public/spdk/index.html","modified":1471508301824,"shasum":"caaa2c529dcc1a2310c1e99bb1c4db2ad4ba4878"},{"_id":"public/hadoop/index.html","modified":1471508301843,"shasum":"40d1fc166d86260cff44d648a8b79a1639e769cd"},{"_id":"public/cache_miss_type/index.html","modified":1471508301851,"shasum":"5db28022a208309720d859d5bd79aec1a1b2e522"},{"_id":"public/swift_14/index.html","modified":1471508301864,"shasum":"4dc37839e7f143c465f01d8f81fe6e525dcdcfce"},{"_id":"public/swift_13/index.html","modified":1471508301884,"shasum":"80faa7696367be81ab3ed8dbd765f5ee6b680eb1"},{"_id":"public/swift_12/index.html","modified":1471508301902,"shasum":"5400e2446f042851ca3fd7440ccdb7f164470d26"},{"_id":"public/swift_11/index.html","modified":1471508301945,"shasum":"3d452410a90b6f145590c84ddf2c0e5bb8434304"},{"_id":"public/swift_10/index.html","modified":1471508301959,"shasum":"4741b98b405f839352f73553a7fe4d6fa7df38cd"},{"_id":"public/swift_9/index.html","modified":1471508301986,"shasum":"dea85631a3e137a7beec68b1690b3adf1cf7a82b"},{"_id":"public/swift_8/index.html","modified":1471508302031,"shasum":"adb684062092a097a39155548be2c393b11478b8"},{"_id":"public/swift_7/index.html","modified":1471508302057,"shasum":"0bee455f9938c2e5ca805ccf0edfee286ff0e301"},{"_id":"public/swift_6/index.html","modified":1471508302073,"shasum":"820332fc0431313e76af7fe166ff935863728468"},{"_id":"public/swift_5/index.html","modified":1471508302091,"shasum":"5cae907b5359e284867c821a766ca523337a04ec"},{"_id":"public/swift_4/index.html","modified":1471508302118,"shasum":"45637d4482cc28eb23e1dff317d284ca6c5a2ee3"},{"_id":"public/swift_3/index.html","modified":1471508302140,"shasum":"45bb1b2468053dcb1189d9b381a2cf63b4b29b39"},{"_id":"public/swift_2/index.html","modified":1471508302151,"shasum":"96007743989ac3cab38b8cd1692bcd1508e0d542"},{"_id":"public/swift_1/index.html","modified":1471508302169,"shasum":"5fe61b46f7e6b4064dbf9b0f2a212550e5e481fe"},{"_id":"public/android_proguard/index.html","modified":1471508302184,"shasum":"702f3d4aafe23786e0346ab1310e0d00ffa5c65c"},{"_id":"public/dpdk/index.html","modified":1471508302209,"shasum":"c437e4a2049382b428635637e930e2aa6d211274"},{"_id":"public/dpdk_l2fwd/index.html","modified":1471508302236,"shasum":"75eda363791d84658aff6cadb2e11d7c120d002f"},{"_id":"public/archives/index.html","modified":1471508302290,"shasum":"950ca4fe768b526b973c95f914e6fbd412bd9d78"},{"_id":"public/archives/2015/index.html","modified":1471508302340,"shasum":"5dc2522c7b140efc4c32b58ba2ab9c6b4fcda70b"},{"_id":"public/archives/2015/03/index.html","modified":1471508302346,"shasum":"a1e82d202ecf20d69de025584033ab77dbe1d8fe"},{"_id":"public/archives/2015/04/index.html","modified":1471508302354,"shasum":"a21c7792ceb935e238a0f0f117568ceb14d8eb5c"},{"_id":"public/archives/2015/07/index.html","modified":1471508302407,"shasum":"ff11fff06fbd8d6e2bc4f84c9b01223462f5759a"},{"_id":"public/archives/2015/12/index.html","modified":1471508302414,"shasum":"839743771c454f243576dac8799adc2496de6032"},{"_id":"public/archives/2016/index.html","modified":1471508302426,"shasum":"00d2fd1802624a4c4a0f798b4218b3d71b658ec0"},{"_id":"public/archives/2016/05/index.html","modified":1471508302435,"shasum":"effcb128ffae8bf4b801e2f1bb8b4fcd474a5a19"},{"_id":"public/archives/2016/08/index.html","modified":1471508302442,"shasum":"e4632bf789ed941eace43de573a91bd99715f9b0"},{"_id":"public/baidusitemap.xml","modified":1471508302444,"shasum":"4b4c41e8bb2ac4ede1c70661a690e5bbfb4cfaac"},{"_id":"public/categories/swift/index.html","modified":1471508302475,"shasum":"e35e31577ab7c37b7b69c4228717da218f10db48"},{"_id":"public/categories/spdk/index.html","modified":1471508302488,"shasum":"e0438c4b2ccd2bc8fb094e74e63b5e5bdd4d951f"},{"_id":"public/categories/hadoop/index.html","modified":1471508302495,"shasum":"f3028e2fe2e9a432756d4f1b4bfa447bfd99f177"},{"_id":"public/categories/dpdk/index.html","modified":1471508302505,"shasum":"d5aba314ae1397cccd7ee6e64a53152edbaf4a91"},{"_id":"public/categories/computer-architecture/index.html","modified":1471508302511,"shasum":"3e9531efe4aa25d28f91bf46f1fe0955f5e60b3e"},{"_id":"public/categories/android/index.html","modified":1471508302520,"shasum":"d9162550d2e8d6cb9fbc72128542be4eb05b9230"},{"_id":"public/atom.xml","modified":1471508302526,"shasum":"25f87be7e5bf4b197282c2c47e192552355ba184"},{"_id":"public/index.html","modified":1471508302567,"shasum":"48c2e26c525a0b2e4ebe58b19d4240f98a192548"},{"_id":"public/page/2/index.html","modified":1471508302608,"shasum":"f3223661fbcde397e4fa38c4ac390e5aef851066"},{"_id":"public/sitemap.xml","modified":1471508302610,"shasum":"8a9097c31a2ced8ed1cb9bcf9b99582ec81455a9"},{"_id":"public/tags/swift/index.html","modified":1471508302647,"shasum":"103ba97a0240554aaef40b19ed4fcf3a605716e6"},{"_id":"public/tags/spdk/index.html","modified":1471508302654,"shasum":"5fde767787a6cfe27f78c7dc2b3427e815210f1a"},{"_id":"public/tags/hadoop/index.html","modified":1471508302660,"shasum":"2531ac2eb262fc151a4bbd04658f1ae45bb56415"},{"_id":"public/tags/java/index.html","modified":1471508302669,"shasum":"04c056438aeffc017d312bcccd9293bcd9a9b7ff"},{"_id":"public/tags/dpdk/index.html","modified":1471508302683,"shasum":"6af9a88c2bb86a3383855ecd6c74f9ab735afc1b"},{"_id":"public/tags/cache/index.html","modified":1471508302690,"shasum":"2454495d067d66b7e876d744ae14fff4f0c9ea9e"},{"_id":"public/tags/computer-architecture/index.html","modified":1471508302696,"shasum":"4f53de8632c09bb23111de87dd4f43a79e9c9fce"},{"_id":"public/tags/android/index.html","modified":1471508302705,"shasum":"0411457f5ebee6fa9067a6d03990378b8b1e5efd"},{"_id":"public/tags/proguard/index.html","modified":1471508302715,"shasum":"8ffbdcd9017989bb5b41f4192ba68554ecf33bba"}],"Category":[{"name":"swift","_id":"cis021qrc0004meo32sqvdj52"},{"name":"spdk","_id":"cis021qsd001cmeo3omq4g5ra"},{"name":"hadoop","_id":"cis021qsf001hmeo3orj0yjdy"},{"name":"dpdk","_id":"cis021qsi001omeo3cs8f5uwg"},{"name":"computer architecture","_id":"cis021qsn001wmeo3qxv7o6br"},{"name":"android","_id":"cis021qsq0023meo3y60ppywd"}],"Data":[],"Page":[{"yout":false,"_content":"<!DOCTYPE html>\n<html>\n  <head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n    <title>404</title>\n    <link rel=\"icon\" href=\"/favicon.ico\">\n  </head>\n  <body>\n    <div align=\"center\">\n      <p>出错啦~！</p>\n      <p>邮箱联系: aidaizyy@gmail.com</p>\n    </div>\n  </body>\n</html>\n","source":"404.html","raw":"yout: false\n--------\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n    <title>404</title>\n    <link rel=\"icon\" href=\"/favicon.ico\">\n  </head>\n  <body>\n    <div align=\"center\">\n      <p>出错啦~！</p>\n      <p>邮箱联系: aidaizyy@gmail.com</p>\n    </div>\n  </body>\n</html>\n","date":"2016-02-01T08:41:10.000Z","updated":"2015-07-13T10:14:34.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cis021qqk0000meo3s9gptjp3"},{"layout":"search","title":"search","_content":"","source":"search/index.md","raw":"layout: search\ntitle: search\n----\n","date":"2016-08-17T07:52:00.000Z","updated":"2016-08-17T07:52:00.000Z","path":"search/index.html","comments":1,"_id":"cis021qqo0001meo3lgrtttry"},{"title":"About Me","toc":false,"_content":"\n[Yunyao Zhang（张云尧）](http://aidaiz.com)\n\nBirthday: December 25, 1992\n\nEmail Address: <aidaizyy@gmail.com>\n\nResearch Area: Computer Architecture & High Performance Computer\n\nLaboratory: [High Performance Computer Research Center](http://www.ncic.ac.cn)\n\nEducation: \n- [Institute of Computing Technology](http://www.ict.ac.cn), [University of Chinese Academy of Sciences](http://www.ucas.ac.cn), since 2015 \n\n- [College of Software Engineering](http://sw.scu.edu.cn), [Sichuan University](http://www.scu.edu.cn), 2011 - 2015\n\n- [Mianzhu High School](http://www.scmzzx.com), Sichuan Province, 2008 - 2011\n\nWeibo: [@张云尧](http://weibo.com/aidaiz)\n\nGithub: [aidaizyy](https:///github.com/aidaizyy)\n\n![](http://7xivk7.com1.z0.glb.clouddn.com/about.jpg-about)\n","source":"about/index.md","raw":"title: About Me\ntoc: false\n---\n\n[Yunyao Zhang（张云尧）](http://aidaiz.com)\n\nBirthday: December 25, 1992\n\nEmail Address: <aidaizyy@gmail.com>\n\nResearch Area: Computer Architecture & High Performance Computer\n\nLaboratory: [High Performance Computer Research Center](http://www.ncic.ac.cn)\n\nEducation: \n- [Institute of Computing Technology](http://www.ict.ac.cn), [University of Chinese Academy of Sciences](http://www.ucas.ac.cn), since 2015 \n\n- [College of Software Engineering](http://sw.scu.edu.cn), [Sichuan University](http://www.scu.edu.cn), 2011 - 2015\n\n- [Mianzhu High School](http://www.scmzzx.com), Sichuan Province, 2008 - 2011\n\nWeibo: [@张云尧](http://weibo.com/aidaiz)\n\nGithub: [aidaizyy](https:///github.com/aidaizyy)\n\n![](http://7xivk7.com1.z0.glb.clouddn.com/about.jpg-about)\n","date":"2016-02-01T08:41:10.000Z","updated":"2015-08-02T04:18:32.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cis021qr50002meo3qryohzmg"}],"Post":[{"title":"Swift基础入门(9)：可选链和自动引用计数","date":"2015-07-23T07:43:48.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：通过可选链（_optional chaining_）调用属性，方法和下标；自动引用计数（_automatic reference counting_）的工作机制；循环强引用的解决方案。\n\n<!--more-->\n**Title: [Swift基础入门(9)：可选链自动引用计数](https://aidaizyy.github.io/swift_9)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-24](http://aidaizyy.github.io)**\n\n# 可选链\n如果请求和调用属性，方法和下标的目标可能为空`nil`，这样的多次请求或调用就可以被链接起来，称为可选链。\n如果任何一个节点为空`nil`，整个可选链失效。\n``` swift\nclass Person { //人\n    var residence: Residence? //每个人可能有住所\n}\n\nclass Residence { //住所\n    var id: String? //住所可能有ID\n    var address: Address? //住所可能有地址\n    var rooms = [Room]() //住所的房间\n    var numberOfRooms: Int { //返回住所的房间数量\n        return rooms.count\n    }\n    subscript(i: Int) -> Room { //下标地址访问住所的一个房间\n        return rooms[i]\n    }\n    func printNumberOfRooms() { //打印房间的数量\n        println(\"The number of rooms is \\(numberOfRooms)\")\n    }\n    func getId() -> String? { //返回住所的ID\n        if id != nil {\n            return id\n        } else {\n            return nil\n        }\n    }\n}\n\nclass Room { //房间\n    let name: String //房间的名字\n    init(name: String) { self.name = name } //房间的构造器\n}\n\nclass Address { //地址\n    var street: String? //地址可能有街道\n}\n\nlet john = Person()\n\n//属性\nif let roomCount = john.residence?.numberOfRooms {\n    println(\"John's residence has \\(roomCount) room(s).\")\n} else {\n    println(\"Unable to retrieve the number of rooms.\")\n}\n// 打印 \"Unable to retrieve the number of rooms。\n\n//无返回值方法\nif john.residence?.printNumberOfRooms() != nil{\n    println(\"It was possible to print the number of rooms.\")\n} else {\n    println(\"It was not possible to print the number of rooms.\")\n}\n// 打印 \"It was not possible to print the number of rooms.\"。\n\n//有返回值方法\nif let buildingId = john.residence?.getId() {\n    println(\"John's building identifier is \\(buildingId).\")\n} else {\n    println(\"Unable to retrieve the ID of building.\")\n}\n// 打印 \"John's building identifier is The Larches.\"。\n\n//下标\nif let firstRoomName = john.residence?[0].name {\n    println(\"The first room name is \\(firstRoomName).\")\n} else {\n    println(\"Unable to retrieve the first room name.\")\n}\n// 打印 \"Unable to retrieve the first room name.\"。\n\n//多层链接\nif let johnsStreet = john.residence?.address?.street {\n    println(\"John's street name is \\(johnsStreet).\")\n} else {\n    println(\"Unable to retrieve the address.\")\n}\n// 打印 \"Unable to retrieve the address.”。\n```\n创建了`Person`的实例`john`，`john`中包含类`Residence`的实例`resindence`。\n`resindence`包含了可选类型的属性和方法，值可能为`nil`，所以访问它的属性，方法和下标时都应该加上`?`。\n可选链中只要有一个节点为可选类型，可选链的结果就一定为可选类型。\n第39行，`john.residence?.numberOfRooms`的结果类型为`Int?`。\n第47行，`john.residence?.printNumberOfRooms()`的结果类型为`void?`。这里不能直接用函数结构作为布尔型去判断，而是与`nil`比较。\n第55行，`john.residence?.getId()`的结果类型为`String?`。\n第63行，`john.residence?[0].name`的结果类型为`String?`。这里的`?`放在`[0]`前，因为确保数组有值，才能通过下标去访问。\n第71行，`john.reidence?.address?.street`的结果类型为`String?`。多层的可选链接链接到一起，`residence`和`address`都是可选类型，所以使用了两个`?`。如果给`john.residence.address`中的`address`分配实例，应该写作`john.residence!.address`，强制解析确保`residence`有值，才能对其中的`address`分配实例。\n\n# 自动引用计数\n自动引用计数（_ARC_）跟踪和管理内存，会自动释放不再使用的实例占用的内存。\nARC会跟踪和计算每一个实例被多少属性，常量和变量引用，这样的引用称为对实例的强引用。不存在强引用，实例会被销毁，否则实例会被保留。\n\n## 类实例的循环强引用\n两个类中相互引用，相互保持对方的强引用，这样无法销毁，形成了循环强引用。\n\n### 强引用\n``` swift\nclass Person {\n    let name: String\n    init(name: String) { self.name = name }\n    var apartment: Apartment?\n    deinit { println(\"\\(name) is being deinitialized\") }dd\n}\n\nclass Apartment {\n    let number: Int\n    init(number: Int) { self.number = number }\n    var tenant: Person?\n    deinit { println(\"Apartment #\\(number) is being deinitialized\") }\n}\n\nvar john: Person?\nvar number73: Apartment?\n\njohn = Person(name: \"John Appleseed\")\nnumber73 = Apartment(number: 73)\n\njohn!.apartment = number73\nnumber73!.tenant = john\n\njohn = nil\nnumber73 = nil\n```\n上面的代码展示了类实例的循环强引用。\n类`Person`中有属性是`Apartment`类型，类`Apartment`中有属性是`Person`类型。\n声明了实例`john`和实例`number73`，并赋值。\n最后两行把两个实例都设为`nil`，但是析构函数并没有被调用，因为两个实例还有循环强引用联系，并没有自动销魂，而且造成了内存泄露。\n\n### 弱引用\n为了解决循环强引用问题，有两种办法：弱引用（_weak reference_）和无主引用（_unowned reference_）。\n一个实例对另一个实例弱引用或者无主引用，不产生强引用，反过来，另一个实例对一个实例强引用，这样能够相互引用而不产生循环强引用。如果实例的值可能为`nil`使用弱引用；如果实例的值不可能为`nil`使用无主引用。\n\n声明时在属性或常量变量前加上`weak`关键字表示弱引用。\n两个实例的值都可能为`nil`，使用弱引用。\n``` swift\nlass Person {\n    let name: String\n    init(name: String) { self.name = name }\n    var apartment: Apartment?\n    deinit { println(\"\\(name) is being deinitialized\") }\n}\n\nclass Apartment {\n    let number: Int\n    init(number: Int) { self.number = number }\n    weak var tenant: Person?\n    deinit { println(\"Apartment #\\(number) is being deinitialized\") }\n}\n\nvar john: Person?\nvar number73: Apartment?\n\njohn = Person(name: \"John Appleseed\")\nnumber73 = Apartment(number: 73)\n\njohn!.apartment = number73\nnumber73!.tenant = john\n\njohn = nil\n// prints \"John Appleseed is being deinitialized\"\nnumber73 = nil\n// prints \"Apartment #73 is being deinitialized\"\n```\n上面的代码和循环强引用代码基本一致，只是在类`Apartment`的类型为`Person?`的属性`tenant`前加上了`weak。因为`Person?`是可选类型，`tenant`值可能为`nil`，所以使用弱引用。\n最后一句，赋值`nil`给`john`后，因为`number73`对`john`不是强引用，`john`这时没有强引用，可以销毁，调用了析构函数。`john`销毁后，`number73`没有强引用，也可以被销毁。\n如果把`number73 = nil`和`john = nil`语句顺序交换，打印顺序不会变，因为没有强引用的`john`一定是先销毁。\n\n### 无主引用\n声明时在属性或常量变量前加上`unowned`关键字表示无主引用。\n- 一个实例的值可能为`nil`，另一个实例的值不可能为`nil`。\n``` swift\nclass Customer {\n    let name: String\n    var card: CreditCard?\n    init(name: String) {\n        self.name = name\n    }\n    deinit { println(\"\\(name) is being deinitialized\") }\n}\n\nclass CreditCard {\n    let number: Int\n    unowned let customer: Customer\n    init(number: Int, customer: Customer) {\n        self.number = number\n        self.customer = customer\n    }\n    deinit { println(\"Card #\\(number) is being deinitialized\") }\n}\n\nvar john: Customer?\n\njohn = Customer(name: \"John Appleseed\")\njohn!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)\n\njohn = nil\n// prints \"John Appleseed is being deinitialized\"\n// prints \"Card #1234567890123456 is being deinitialized\"\n```\n类`CreditCard`的类型为`Customer`的属性`customer`前加上了`unowned`。因为`customer`在构造函数中就会赋予初始值，值不会为`nil`，所以使用无主引用。\n最后一句，赋值`nil`给`john`后，因为类`CreditCard`的实例对`john`不是强引用，`john`这时没有强引用，可以销毁，调用了析构函数。`john`销毁后，类`Creditcard`的实例也没有强引用了，跟着被销毁了。\n- 两个实例的值都不可能为`nil`。\n这种场景一个类使用无主属性，另一个类使用隐式解析可选类型。\n``` swift\nclass Country {\n    let name: String\n    let capitalCity: City!\n    init(name: String, capitalName: String) {\n        self.name = name\n        self.capitalCity = City(name: capitalName, country: self)\n    }\n}\n\nclass City {\n    let name: String\n    unowned let country: Country\n    init(name: String, country: Country) {\n        self.name = name\n        self.country = country\n    }\n}\n\nvar country = Country(name: \"Canada\", capitalName: \"Ottawa\")\nprintln(\"\\(country.name)'s capital city is called \\(country.capitalCity.name)\")\n// prints \"Canada's capital city is called Ottawa\"\n```\n类`City`的类型为`Country`的属性`country`前加上了`unowned`表示无主属性。\n类`Country`的类型为`City!`的属性`capitalCity`在类型后加上了`!`表示隐式解析可选类型。\n类`Country`的实例的`country`创建时，调用构造器，为`name`和`capiptalCity`赋值。因为`self`属性必须在构造的第二阶段使用，也就是类中所有存储型属性全部有初始值之后才能使用。如果`Country`的值可以为`nil`，先给`capitalCity`赋值`nil`就可以调用构造器为`capitalCity`赋予新值。但是这里不可以赋值`nil`，所以加上了`!`隐私解析可选类型，默认初始值为`nil`，可以调用构造器赋予新值。\n属性`capitalCity`在调用时可以直接使用，不再需要加`!`访问。\n\n## 闭包的循环强引用\n除了两个类实例的循环强引用，类实例和闭包也可能引起循环强引用，比如把闭包赋值给类的一个属性，而闭包中又通过`self`访问类的一个属性，这就引起了循环强引用，实例不会被销毁。\n\n### 闭包占用列表\n闭包占用列表（_closuer capture list_）可以解决闭包引起的循环强引用问题。\n> 闭包调用类属性，必须加上`self.`，不能直接通过属性名调用。\n``` swift\nlazy var someClosure: (Int, String) -> String = {\n    [unowned self] (index: Int, stringToProcess: String) -> String in\n    // closure body goes here\n}\n```\n定义占用列表，使用`weak`或`unowned`，视值是否能为`nil`而定。\n``` swift\nclass HTMLElement {\n\n    let name: String\n    let text: String?\n\n    lazy var asHTML: () -> String = {\n        [unowned self] in\n        if let text = self.text {\n            return \"<\\(self.name)>\\(text)</\\(self.name)>\"\n        } else {\n            return \"<\\(self.name) />\"\n        }\n    }\n\n    init(name: String, text: String? = nil) {\n        self.name = name\n        self.text = text\n    }\n\n    deinit {\n        println(\"\\(name) is being deinitialized\")\n    }\n\n}\n\nvar paragraph: HTMLElement? = HTMLElement(name: \"p\", text: \"hello, world\")\nprintln(paragraph!.asHTML())\n// prints \"<p>hello, world</p>\"\n\nparagraph = nil\n// prints \"p is being deinitialized\"\n```\n上面的例子中，闭包的指定参数列表和返回类型可以通过上下文推断，所以省略。`in`放在占用列表之后。\n这里使用了无主引用，闭包通过`unowned self`对类`HTMLELement`无主引用。\n最后一句，赋值`nil`给`paragraph`，没有了闭包对它的强引用，可以销毁并调用析构函数。\n","source":"_posts/swift_9.md","raw":"title: \"Swift基础入门(9)：可选链和自动引用计数\"\ndate: 2015-07-23 15:43:48\ntags:\n- swift\ncategories: swift\ntoc: true\n---\n\n本篇介绍Swift的基础知识：通过可选链（_optional chaining_）调用属性，方法和下标；自动引用计数（_automatic reference counting_）的工作机制；循环强引用的解决方案。\n\n<!--more-->\n**Title: [Swift基础入门(9)：可选链自动引用计数](https://aidaizyy.github.io/swift_9)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-24](http://aidaizyy.github.io)**\n\n# 可选链\n如果请求和调用属性，方法和下标的目标可能为空`nil`，这样的多次请求或调用就可以被链接起来，称为可选链。\n如果任何一个节点为空`nil`，整个可选链失效。\n``` swift\nclass Person { //人\n    var residence: Residence? //每个人可能有住所\n}\n\nclass Residence { //住所\n    var id: String? //住所可能有ID\n    var address: Address? //住所可能有地址\n    var rooms = [Room]() //住所的房间\n    var numberOfRooms: Int { //返回住所的房间数量\n        return rooms.count\n    }\n    subscript(i: Int) -> Room { //下标地址访问住所的一个房间\n        return rooms[i]\n    }\n    func printNumberOfRooms() { //打印房间的数量\n        println(\"The number of rooms is \\(numberOfRooms)\")\n    }\n    func getId() -> String? { //返回住所的ID\n        if id != nil {\n            return id\n        } else {\n            return nil\n        }\n    }\n}\n\nclass Room { //房间\n    let name: String //房间的名字\n    init(name: String) { self.name = name } //房间的构造器\n}\n\nclass Address { //地址\n    var street: String? //地址可能有街道\n}\n\nlet john = Person()\n\n//属性\nif let roomCount = john.residence?.numberOfRooms {\n    println(\"John's residence has \\(roomCount) room(s).\")\n} else {\n    println(\"Unable to retrieve the number of rooms.\")\n}\n// 打印 \"Unable to retrieve the number of rooms。\n\n//无返回值方法\nif john.residence?.printNumberOfRooms() != nil{\n    println(\"It was possible to print the number of rooms.\")\n} else {\n    println(\"It was not possible to print the number of rooms.\")\n}\n// 打印 \"It was not possible to print the number of rooms.\"。\n\n//有返回值方法\nif let buildingId = john.residence?.getId() {\n    println(\"John's building identifier is \\(buildingId).\")\n} else {\n    println(\"Unable to retrieve the ID of building.\")\n}\n// 打印 \"John's building identifier is The Larches.\"。\n\n//下标\nif let firstRoomName = john.residence?[0].name {\n    println(\"The first room name is \\(firstRoomName).\")\n} else {\n    println(\"Unable to retrieve the first room name.\")\n}\n// 打印 \"Unable to retrieve the first room name.\"。\n\n//多层链接\nif let johnsStreet = john.residence?.address?.street {\n    println(\"John's street name is \\(johnsStreet).\")\n} else {\n    println(\"Unable to retrieve the address.\")\n}\n// 打印 \"Unable to retrieve the address.”。\n```\n创建了`Person`的实例`john`，`john`中包含类`Residence`的实例`resindence`。\n`resindence`包含了可选类型的属性和方法，值可能为`nil`，所以访问它的属性，方法和下标时都应该加上`?`。\n可选链中只要有一个节点为可选类型，可选链的结果就一定为可选类型。\n第39行，`john.residence?.numberOfRooms`的结果类型为`Int?`。\n第47行，`john.residence?.printNumberOfRooms()`的结果类型为`void?`。这里不能直接用函数结构作为布尔型去判断，而是与`nil`比较。\n第55行，`john.residence?.getId()`的结果类型为`String?`。\n第63行，`john.residence?[0].name`的结果类型为`String?`。这里的`?`放在`[0]`前，因为确保数组有值，才能通过下标去访问。\n第71行，`john.reidence?.address?.street`的结果类型为`String?`。多层的可选链接链接到一起，`residence`和`address`都是可选类型，所以使用了两个`?`。如果给`john.residence.address`中的`address`分配实例，应该写作`john.residence!.address`，强制解析确保`residence`有值，才能对其中的`address`分配实例。\n\n# 自动引用计数\n自动引用计数（_ARC_）跟踪和管理内存，会自动释放不再使用的实例占用的内存。\nARC会跟踪和计算每一个实例被多少属性，常量和变量引用，这样的引用称为对实例的强引用。不存在强引用，实例会被销毁，否则实例会被保留。\n\n## 类实例的循环强引用\n两个类中相互引用，相互保持对方的强引用，这样无法销毁，形成了循环强引用。\n\n### 强引用\n``` swift\nclass Person {\n    let name: String\n    init(name: String) { self.name = name }\n    var apartment: Apartment?\n    deinit { println(\"\\(name) is being deinitialized\") }dd\n}\n\nclass Apartment {\n    let number: Int\n    init(number: Int) { self.number = number }\n    var tenant: Person?\n    deinit { println(\"Apartment #\\(number) is being deinitialized\") }\n}\n\nvar john: Person?\nvar number73: Apartment?\n\njohn = Person(name: \"John Appleseed\")\nnumber73 = Apartment(number: 73)\n\njohn!.apartment = number73\nnumber73!.tenant = john\n\njohn = nil\nnumber73 = nil\n```\n上面的代码展示了类实例的循环强引用。\n类`Person`中有属性是`Apartment`类型，类`Apartment`中有属性是`Person`类型。\n声明了实例`john`和实例`number73`，并赋值。\n最后两行把两个实例都设为`nil`，但是析构函数并没有被调用，因为两个实例还有循环强引用联系，并没有自动销魂，而且造成了内存泄露。\n\n### 弱引用\n为了解决循环强引用问题，有两种办法：弱引用（_weak reference_）和无主引用（_unowned reference_）。\n一个实例对另一个实例弱引用或者无主引用，不产生强引用，反过来，另一个实例对一个实例强引用，这样能够相互引用而不产生循环强引用。如果实例的值可能为`nil`使用弱引用；如果实例的值不可能为`nil`使用无主引用。\n\n声明时在属性或常量变量前加上`weak`关键字表示弱引用。\n两个实例的值都可能为`nil`，使用弱引用。\n``` swift\nlass Person {\n    let name: String\n    init(name: String) { self.name = name }\n    var apartment: Apartment?\n    deinit { println(\"\\(name) is being deinitialized\") }\n}\n\nclass Apartment {\n    let number: Int\n    init(number: Int) { self.number = number }\n    weak var tenant: Person?\n    deinit { println(\"Apartment #\\(number) is being deinitialized\") }\n}\n\nvar john: Person?\nvar number73: Apartment?\n\njohn = Person(name: \"John Appleseed\")\nnumber73 = Apartment(number: 73)\n\njohn!.apartment = number73\nnumber73!.tenant = john\n\njohn = nil\n// prints \"John Appleseed is being deinitialized\"\nnumber73 = nil\n// prints \"Apartment #73 is being deinitialized\"\n```\n上面的代码和循环强引用代码基本一致，只是在类`Apartment`的类型为`Person?`的属性`tenant`前加上了`weak。因为`Person?`是可选类型，`tenant`值可能为`nil`，所以使用弱引用。\n最后一句，赋值`nil`给`john`后，因为`number73`对`john`不是强引用，`john`这时没有强引用，可以销毁，调用了析构函数。`john`销毁后，`number73`没有强引用，也可以被销毁。\n如果把`number73 = nil`和`john = nil`语句顺序交换，打印顺序不会变，因为没有强引用的`john`一定是先销毁。\n\n### 无主引用\n声明时在属性或常量变量前加上`unowned`关键字表示无主引用。\n- 一个实例的值可能为`nil`，另一个实例的值不可能为`nil`。\n``` swift\nclass Customer {\n    let name: String\n    var card: CreditCard?\n    init(name: String) {\n        self.name = name\n    }\n    deinit { println(\"\\(name) is being deinitialized\") }\n}\n\nclass CreditCard {\n    let number: Int\n    unowned let customer: Customer\n    init(number: Int, customer: Customer) {\n        self.number = number\n        self.customer = customer\n    }\n    deinit { println(\"Card #\\(number) is being deinitialized\") }\n}\n\nvar john: Customer?\n\njohn = Customer(name: \"John Appleseed\")\njohn!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)\n\njohn = nil\n// prints \"John Appleseed is being deinitialized\"\n// prints \"Card #1234567890123456 is being deinitialized\"\n```\n类`CreditCard`的类型为`Customer`的属性`customer`前加上了`unowned`。因为`customer`在构造函数中就会赋予初始值，值不会为`nil`，所以使用无主引用。\n最后一句，赋值`nil`给`john`后，因为类`CreditCard`的实例对`john`不是强引用，`john`这时没有强引用，可以销毁，调用了析构函数。`john`销毁后，类`Creditcard`的实例也没有强引用了，跟着被销毁了。\n- 两个实例的值都不可能为`nil`。\n这种场景一个类使用无主属性，另一个类使用隐式解析可选类型。\n``` swift\nclass Country {\n    let name: String\n    let capitalCity: City!\n    init(name: String, capitalName: String) {\n        self.name = name\n        self.capitalCity = City(name: capitalName, country: self)\n    }\n}\n\nclass City {\n    let name: String\n    unowned let country: Country\n    init(name: String, country: Country) {\n        self.name = name\n        self.country = country\n    }\n}\n\nvar country = Country(name: \"Canada\", capitalName: \"Ottawa\")\nprintln(\"\\(country.name)'s capital city is called \\(country.capitalCity.name)\")\n// prints \"Canada's capital city is called Ottawa\"\n```\n类`City`的类型为`Country`的属性`country`前加上了`unowned`表示无主属性。\n类`Country`的类型为`City!`的属性`capitalCity`在类型后加上了`!`表示隐式解析可选类型。\n类`Country`的实例的`country`创建时，调用构造器，为`name`和`capiptalCity`赋值。因为`self`属性必须在构造的第二阶段使用，也就是类中所有存储型属性全部有初始值之后才能使用。如果`Country`的值可以为`nil`，先给`capitalCity`赋值`nil`就可以调用构造器为`capitalCity`赋予新值。但是这里不可以赋值`nil`，所以加上了`!`隐私解析可选类型，默认初始值为`nil`，可以调用构造器赋予新值。\n属性`capitalCity`在调用时可以直接使用，不再需要加`!`访问。\n\n## 闭包的循环强引用\n除了两个类实例的循环强引用，类实例和闭包也可能引起循环强引用，比如把闭包赋值给类的一个属性，而闭包中又通过`self`访问类的一个属性，这就引起了循环强引用，实例不会被销毁。\n\n### 闭包占用列表\n闭包占用列表（_closuer capture list_）可以解决闭包引起的循环强引用问题。\n> 闭包调用类属性，必须加上`self.`，不能直接通过属性名调用。\n``` swift\nlazy var someClosure: (Int, String) -> String = {\n    [unowned self] (index: Int, stringToProcess: String) -> String in\n    // closure body goes here\n}\n```\n定义占用列表，使用`weak`或`unowned`，视值是否能为`nil`而定。\n``` swift\nclass HTMLElement {\n\n    let name: String\n    let text: String?\n\n    lazy var asHTML: () -> String = {\n        [unowned self] in\n        if let text = self.text {\n            return \"<\\(self.name)>\\(text)</\\(self.name)>\"\n        } else {\n            return \"<\\(self.name) />\"\n        }\n    }\n\n    init(name: String, text: String? = nil) {\n        self.name = name\n        self.text = text\n    }\n\n    deinit {\n        println(\"\\(name) is being deinitialized\")\n    }\n\n}\n\nvar paragraph: HTMLElement? = HTMLElement(name: \"p\", text: \"hello, world\")\nprintln(paragraph!.asHTML())\n// prints \"<p>hello, world</p>\"\n\nparagraph = nil\n// prints \"p is being deinitialized\"\n```\n上面的例子中，闭包的指定参数列表和返回类型可以通过上下文推断，所以省略。`in`放在占用列表之后。\n这里使用了无主引用，闭包通过`unowned self`对类`HTMLELement`无主引用。\n最后一句，赋值`nil`给`paragraph`，没有了闭包对它的强引用，可以销毁并调用析构函数。\n","slug":"swift_9","published":1,"updated":"2015-07-31T02:47:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qr80003meo34pns638v"},{"title":"Swift基础入门(8)：继承，构造，析构和嵌套类型","date":"2015-07-21T09:17:02.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：类的继承；枚举，结构体和类的构造过程，析构过程和嵌套类型。\n\n<!--more-->\n**Title: [Swift基础入门(8)：继承，构造，析构和嵌套类型](https://aidaizyy.github.io/swift_8)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-24](http://aidaizyy.github.io)**\n\n# 继承\n\n## 基本语法\n子类（_subclass_）继承（_inherit_）继承超类/父类（_superclass_）的属性，方法，下标和其他特性。\n声明子类时，将超类名写在子类名的后面，用冒号分割：\n``` swift\nclass Vehicle {\n    var currentSpeed = 0.0\n    var description: String {\n        return \"traveling at \\(currentSpeed) miles per hour\"\n    }\n    func makeNoise() {\n        // 什么也不做-因为车辆不一定会有噪音\n    }\n}\n\nclass Bicycle: Vehicle {\n    var hasBasket = false\n}\n\nclass Tandem: Bicycle {\n    var currentNumberOfPassengers = 0\n}\n\nlet tandem = Tandem()\ntandem.hasBasket = true\ntandem.currentNumberOfPassengers = 2\ntandem.currentSpeed = 22.0\nprintln(\"Tandem: \\(tandem.description)\")\n// Tandem: traveling at 22.0 miles per hour\n```\n\n## 重写\n重写（_overriding_）指子类把父类的实例方法，类方法，实例属性和下表脚本等提供自己定制的实现。\n在重写定义的前面加上关键字`override`。\n使用`super`前缀可以访问超类的属性，方法和下表脚本。\n\n### 重写方法\n``` swift\nclass Train: Vehicle {\n    override func makeNoise() {\n        println(\"Choo Choo\")\n    }\n}\n\nclass Car: Vehicle {\n    var gear = 1\n    override var description: String {\n        return super.description + \" in gear \\(gear)\"\n    }\n}\n\nlet train = Train()\ntrain.makeNoise()\n// prints \"Choo Choo\"\n```\n\n### 重写属性\n- 超类的只读属性在子类中可以重写为读写属性，但是读写属性不能重写为只读属性。\n- 超类的重写属性在子类中必须完整实现setter和getter，可以用`super.someProperty`返回超类的getter。\n``` swift\nclass Car: Vehicle {\n    var gear = 1\n    override var description: String {\n        return super.description + \" in gear \\(gear)\"\n    }\n}\n\nlet car = Car()\ncar.currentSpeed = 25.0\ncar.gear = 3\nprintln(\"Car: \\(car.description)\")\n// Car: traveling at 25.0 miles per hour in gear 3\n```\n\n### 重写属性观察器\nsetter和属性观察器不能同时存在，setter中可以观察到值的变化。\n``` swift\nclass AutomaticCar: Car {\n    override var currentSpeed: Double {\n        didSet {\n            gear = Int(currentSpeed / 10.0) + 1\n        }\n    }\n}\n\nlet automatic = AutomaticCar()\nautomatic.currentSpeed = 35.0\nprintln(\"AutomaticCar: \\(automatic.description)\")\n// AutomaticCar: traveling at 35.0 miles per hour in gear 4\n```\n\n## 防止重写\n属性，方法和下标前面加上`final`关键字可以防止它们被重写。\n`final var`，`final func`，`final class func`，`final subscript`。\n\n# 构造过程\n构造过程（_Inititalization_）为实例的每个属性设置初始值和为其执行必要的准备和初始化任务。\n\n## 构造器\n### 属性默认值\n属性声明时，可以为其设置默认值。\n``` swift\nstruct Fahrenheit {\n    var temperature = 32.0\n}\n\nvar f = Fahrenheit()\nprintln(\"The default temperature is \\(f.temperature)° Fahrenheit\")\n// 输出 \"The default temperature is 32.0° Fahrenheit”\n```\n构造器，也可以为属性赋初始值，关键字`init`。\n``` swift\nstruct Fahrenheit {\n    var temperature: Double\n    init() {\n        temperature = 32.0\n    }\n}\n\nvar f = Fahrenheit()\nprintln(\"The default temperature is \\(f.temperature)° Fahrenheit\")\n// 输出 \"The default temperature is 32.0° Fahrenheit”\n```\n\n### 构造器参数\n构造器可以传入参数。\n传入参数默认具有和内部参数名一致的外部参数名，相当于默认在参数名前加上了`#`。\n用`_`替代外部参数名，可以取消默认的外部参数名。\n``` swift\nstruct Color {\n    let red, green, blue: Double\n    init(red: Double, g green: Double, _ blue: Double) {\n        self.red   = red\n        self.green = green\n        self.blue  = blue\n    }\n    init(white: Double) {\n        red   = white\n        green = white\n        blue  = white\n    }\n}\n\nlet magenta = Color(red: 1.0, g: 0.0, 1.0)\nlet halfGray = Color(white: 0.5)\n```\n\n### 可选类型属性\n如果属性为可选类型，构造器自动初始化为`nil`。\n\n### 常量属性\n构造器中可以修改常量`let`属性的值，在构造过程中结束后，常量的值不能被修改。\n\n### 默认构造器\n所有属性已提供默认值且没有定义构造器的结构体或基类，具有一个默认的构造器，把默认值赋值给属性作为初始值。\n\n前面讲过，结构体的逐一成员构造器，算是一个默认的构造器。\n``` swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nlet twoByTwo = Size(width: 2.0, height: 2.0)\n```\n这里`Size`获得了一个逐一成员构造器`init(width: height: )`。\n\n## 值类型的构造器代理\n构造器可以通过调用其他构造器来完成构造过程，称为构造器代理。\n值类型比较简单，只能调用本身提供的其他构造器，而类可以继承构造器。\n``` swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Point {\n    var x = 0.0, y = 0.0\n}\n\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    init() {}\n    init(origin: Point, size: Size) {\n        self.origin = origin\n        self.size = size\n    }\n    init(center: Point, size: Size) {\n        let originX = center.x - (size.width / 2)\n        let originY = center.y - (size.height / 2)\n        self.init(origin: Point(x: originX, y: originY), size: size)\n    }\n}\n```\n结构体`Rect`中实现了三个构造器。\n第一个构造器功能和默认构造器类似，把默认值赋值给属性。\n第二个构造器功能和逐一成员构造器类似，逐一把值赋值给属性。\n第三个构造器调用了第二个构造器，完成了部分构造过程。\n\n## 类的构造器代理\n\n### 指定构造器和便利构造器\n类类型的构造器要确保所有存储型属性获得初始值，包括继承来的属性，分为指定构造器和便利构造器。\n- 指定构造器\n主要的类构造器，根据父类链依次往上调用父类的构造器，每个类都必须拥有至少一个指定构造器。\n写法和值类型的构造器一样：\n``` swift\ninit(parameters) {\n    statements\n}\n```\n- 便利构造器\n次要的类构造器，调用同一个类中的指定构造器，也可以创建一个特殊用途或特定输入的实例，只在必要时提供便利构造器。\n写法和值类型的构造器也基本一样，在`init`前加上`convenience`关键字：\n``` swift\nconvenience init(parameters) {\n    statements\n}\n```\n\n+ 指定构造器必须调用其直接父类的指定构造器。\n+ 便利构造器必须调用同一类中定义的其他构器。\n+ 便利构造器必须最终以调用一个指定构造器结束。\n\n也就是说：\n- 指定构造器必须总是向上代理\n- 便利构造器必须总是横向代理\n\n### 构造器继承和重写\n重写（_Override_）指定构造器，在子类中重写实现并调用父类构造器。\n重写便利构造器，必须通过调用同一类提供的其他指定构造器来实现。\n\n子类不会默认继承父类的构造器。\n如果特定条件满足，父类构造器也会被自动继承：\n- 子类的任意新属性都有默认值，且没有定义任何指定构造器，它将自动继承所有父类的指定构造器。\n- 子类提供了所有父类指定构造器的实现，它将自动继承所有父类的便利构造器。\n\n### 构造过程\n构造过程分为两个阶段。\n第一个阶段：\n沿着构造器链先初始化子类的属性，再代理给父类构造器，初始化父类的属性。\n当到达构造器链最顶部时，所有的存储型属性都已经赋值。\n这个阶段不能调用任何实例方法，不能读取任何实例属性的值，不能引用`self`的值。\n\n第二个阶段：\n沿着构造器链沿相反方向，从顶部向下，进一步定制实例，可以为任意属性赋新值。\n这个阶段可以调用实例方法，修改实例属性，并访问`self`。\n\n### 实例\n``` swift\nclass Food {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n    convenience init() {\n        self.init(name: \"[Unnamed]\")\n    }\n}\n\nlet namedMeat = Food(name: \"Bacon\")\n// namedMeat 的名字是 \"Bacon”\n\nlet mysteryMeat = Food()\n// mysteryMeat 的名字是 [Unnamed]\n```\n类`Food`提供了一个指定构造器`init(name: String)`和一个便利构造器`init()`。\n第11行：指定构造器，初始化属性`name`，因为`Food`没有父类，所以结束构造过程。\n第14行：便利构造器，调用了同一个类的指定构造器并给参数`name`传入值`[Unnamed]`。\n``` swift\nclass RecipeIngredient: Food {\n    var quantity: Int\n    init(name: String, quantity: Int) {\n        self.quantity = quantity\n        super.init(name: name)\n    }\n    override convenience init(name: String) {\n        self.init(name: name, quantity: 1)\n    }\n}\n\nlet sixEggs = RecipeIngredient(name: \"Eggs\", quantity: 6)\nlet oneBacon = RecipeIngredient(name: \"Bacon\")\nlet oneMysteryItem = RecipeIngredient()\n```\n类`RecipeIngredient`继承类`Food`，提供了一个指定构造器`init(name: String, quantity: Int)`和一个便利构造器`init(name: String)。\n第12行：指定构造器，先初始化子类的属性`quantity`，再代理给父类`Food`的`init(name: String)`。\n第13行：便利构造器，调用了同一个类的指定构造器并给参数`name`和`quantity`传入了值。\n因为`init(name: String)`和父类的`init(name: String)`使用了相同的参数，所以在前面使用`override`标识。\n第14行：父类的`init()`被子类继承了，但是它其中调用的`init(name: String)`替换成子类`RecipeIngredient`重写过后的便利构造器。\n``` swift\nclass ShoppingListItem: RecipeIngredient {\n    var purchased = false\n    var description: String {\n    var output = \"\\(quantity) x \\(name.lowercaseString)\"\n        output += purchased ? \" ✔\" : \" ✘\"\n        return output\n    }\n}\n\nvar breakfastList = [\n    ShoppingListItem(),\n    ShoppingListItem(name: \"Bacon\"),\n    ShoppingListItem(name: \"Eggs\", quantity: 6),\n]\nbreakfastList[0].name = \"Orange juice\"\nbreakfastList[0].purchased = true\nfor item in breakfastList {\n    println(item.description)\n}\n// 1 x orange juice ✔\n// 1 x bacon ✘\n// 6 x eggs ✘\n```\n类`ShoppingListItem`继承类`RecipeIngredient`。\n因为子类的新属性`purchased`有默认值，而且自己没有定义任何构造器，所以继承了父类的所有指定构造器。\n这时就满足上面提到继承父类构造器的第二个条件：子类提供了所有父类指定构造器的实现。\n所以子类也继承了父类的所有便利构造器。\n类`shoppingListItem`就继承了`init()`，`init(name: String)`和`init(name: String, quantity: Int)`三种构造器。\n\n## 可失败构造器\n构造过程中可能因为传入无效参数值，缺少资源，不满足必要条件等原因构造失败的构造器，称为可失败构造器。\n\n### 基本语法\n可失败构造器在`init`关键字后面加上`?`，即`init?`。\n并在失败的情况下加上`return nil`使构造器返回`nil`，非可失败构造器中不能使用`return`返回值。\n可失败构造器的参数名和参数类型不能与其他非可失败构造器完全相同。\n``` swift\nstruct Animal {\n    let species: String\n    init?(species: String) {\n        if species.isEmpty { return nil }\n        self.species = species\n    }\n}\n\nlet someCreature = Animal(species: \"Giraffe\")\n// someCreature 的类型是 Animal? 而不是 Animal\n\nif let giraffe = someCreature {\n    println(\"An animal was initialized with a species of \\(giraffe.species)\")\n}\n// 打印 \"An animal was initialized with a species of Giraffe\"\n\nlet anonymousCreature = Animal(species: \"\")\n// anonymousCreature 的类型是 Animal?, 而不是 Animal\n\nif anonymousCreature == nil {\n    println(\"The anonymous creature could not be initialized\")\n}\n// 打印 \"The anonymous creature could not be initialized\"\n```\n\n### 枚举类型的可失败构造器\n``` swift\nenum TemperatureUnit {\n    case Kelvin, Celsius, Fahrenheit\n    init?(symbol: Character) {\n        switch symbol {\n        case \"K\":\n            self = .Kelvin\n        case \"C\":\n            self = .Celsius\n        case \"F\":\n            self = .Fahrenheit\n        default:\n            return nil\n        }\n    }\n}\n\nlet fahrenheitUnit = TemperatureUnit(symbol: \"F\")\nif fahrenheitUnit != nil {\n    println(\"This is a defined temperature unit, so initialization succeeded.\")\n}\n// 打印 \"This is a defined temperature unit, so initialization succeeded.\"\n\nlet unknownUnit = TemperatureUnit(symbol: \"X\")\nif unknownUnit == nil {\n    println(\"This is not a defined temperature unit, so initialization failed.\")\n}\n// 打印 \"This is not a defined temperature unit, so initialization failed.\"\n```\n当参数值不能与任意一枚举成员相匹配时，该枚举类型的构建过程失败。\n\n带原始值的枚举类型会自带一个可失败构造器`init?(rawValue: )`，`rawValue`是一个默认参数，和枚举类型的原始值类型一致。\n如果该参数的值能和枚举类型成员所带的原始值匹配，则构建器构造一个带此原始值的枚举成员，否则构造失败。\n上面的例子可以重写为：\n``` swift\nenum TemperatureUnit: Character {\n    case Kelvin = \"K\", Celsius = \"C\", Fahrenheit = \"F\"\n}\n\nlet fahrenheitUnit = TemperatureUnit(rawValue: \"F\")\nif fahrenheitUnit != nil {\n    println(\"This is a defined temperature unit, so initialization succeeded.\")\n}\n// prints \"This is a defined temperature unit, so initialization succeeded.\"\n\nlet unknownUnit = TemperatureUnit(rawValue: \"X\")\nif unknownUnit == nil {\n    println(\"This is not a defined temperature unit, so initialization failed.\")\n}\n// prints \"This is not a defined temperature unit, so initialization failed.\"\n```\n\n### 类的可失败构造器\n类的可失败构造器只能在所有类属性被初始化和所有类之间的构造代理之间的代理调用发生完后触发失败行为。\n而值类型的可失败构造器可以随时随地触发。\n``` swift\nclass Product {\n    let name: String!\n    init?(name: String) {\n        self.name = name\n        if name.isEmpty { return nil }\n    }\n}\n\nif let bowTie = Product(name: \"bow tie\") {\n    // 不需要检查 bowTie.name == nil\n    println(\"The product's name is \\(bowTie.name)\")\n}\n// 打印 \"The product's name is bow tie\"\n```\n类`Product`的可失败构造器必须建立在`name`被赋值的情况下。\n所以`name`被声明为隐式解析可选类型（`String!`）保证触发失败条件时，`name`一定有值。\n类`Prodcut`构建成功时，`name`一定有一个非`nil`值，可以直接访问`name`。\n\n### 可失败构造器的代理\n可失败构造器的代理规则和构造器基本一致，只是一旦触发构造失败，整个构造过程就会被立即终止。\n可失败构造器可以在同一类中代理调用其他非可失败构造器，这样可以为已有的构造器添加构造失败的条件。\n``` swift\nclass Product {\n    let name: String!\n    init?(name: String) {\n        if name.isEmpty { return nil }\n        self.name = name\n    }\n}\n\nclass CartItem: Product {\n    let quantity: Int!\n    init?(name: String, quantity: Int) {\n        super.init(name: name)\n        if quantity < 1 { return nil }\n        self.quantity = quantity\n    }\n}\n\nif let twoSocks = CartItem(name: \"sock\", quantity: 2) {\n    println(\"Item: \\(twoSocks.name), quantity: \\(twoSocks.quantity)\")\n}\n// 打印 \"Item: sock, quantity: 2\"\n\nif let zeroShirts = CartItem(name: \"shirt\", quantity: 0) {\n    println(\"Item: \\(zeroShirts.name), quantity: \\(zeroShirts.quantity)\")\n} else {\n    println(\"Unable to initialize zero shirts\")\n}\n// 打印 \"Unable to initialize zero shirts\"\n\nif let oneUnnamed = CartItem(name: \"\", quantity: 1) {\n    println(\"Item: \\(oneUnnamed.name), quantity: \\(oneUnnamed.quantity)\")\n} else {\n    println(\"Unable to initialize one unnamed product\")\n}\n// 打印 \"Unable to initialize one unnamed product\"\n```\n第18行：构造成功。\n第23行：`quantiry`的值小于`1`，不满足条件，构造失败。\n第30行：`name`为空，父类`Product`可失败构造器触发构造失败，整个构造过程停止并失败。\n\n### 可失败构造器的重写\n父类的可失败构造器可以被子类的可失败构造器或者非可失败构造器重写。\n但是父类的非可失败构造器不可以被子类的可失败构造器重写。\n如果用非可失败构造器重写可失败构造器时，不再向上代理父类的可失败构造器，非可失败构造器不不会代理调用可失败构造器。\n``` swift\nclass Document {\n    var name: String?\n    // 该构造器构建了一个name属性值为nil的document对象\n    init() {}\n    // 该构造器构建了一个name属性值为非空字符串的document对象\n    init?(name: String) {\n        if name.isEmpty { return nil }\n        self.name = name\n    }\n}\n\nclass AutomaticallyNamedDocument: Document {\n    override init() {\n        super.init()\n        self.name = \"[Untitled]\"\n    }\n    override init(name: String) {\n        super.init()\n        if name.isEmpty {\n            self.name = \"[Untitled]\"\n        } else {\n            self.name = name\n        }\n    }\n}\n```\n\n### 隐私解析可选类型的可失败构造器\n`init!`同`init?`一样都是可失败构造器，该可失败构造器就会构造一个特定类型的隐私解析可选类型的对象。\n`init?`和`init!`可以相互代理调用，相互重写。\n`init`也可以代理调用`init!`，但这会触发一个断言：`init!`是否会触发构造失败。\n\n### 必要构造器\n在类的构造器前添加`required`关键字表示该类的子类都必须实现该构造器。\n子类重写父类的`required`必要构造器时，也要加上`required`关键字，也是必要构造器。\n覆盖基类的必要构造器时，不需要添加`override`关键字。\n``` swift\nclass SomeClass {\n    required init() {\n        // 在这里添加该必要构造器的实现代码\n    }\n}\n\nclass SomeSubclass: SomeClass {\n    required init() {\n        // 在这里添加子类必要构造器的实现代码\n    }\n}\n```\n不一定需要显示的实现父类的必要构造器，只要满足父类的必要构造器需求即可。\n\n## 闭包设置属性默认值\n闭包可以用来为属性提供定制的默认值，返回和属性类型相同类型的默认值。\n在闭包中不能使用其他属性，不能访问其他实例方法，不能使用`self`属性。\n``` swift\nclass SomeClass {\n    let someProperty: SomeType = {\n        // 在这个闭包中给 someProperty 创建一个默认值\n        // someValue 必须和 SomeType 类型相同\n        return someValue\n        }()\n}\n```\n闭包后面接`()`表示闭包立刻执行，否则会把闭包赋值给`someProperty`。\n``` swift\nstruct Checkerboard {\n    let boardColors: [Bool] = {\n        var temporaryBoard = [Bool]()\n        var isBlack = false\n        for i in 1...10 {\n            for j in 1...10 {\n                temporaryBoard.append(isBlack)\n                isBlack = !isBlack\n            }\n            isBlack = !isBlack\n        }\n        return temporaryBoard\n        }()\n    func squareIsBlackAtRow(row: Int, column: Int) -> Bool {\n        return boardColors[(row * 10) + column]\n    }\n}\n\nlet board = Checkerboard()\nprintln(board.squareIsBlackAtRow(0, column: 1))\n// 输出 \"true\"\nprintln(board.squareIsBlackAtRow(9, column: 9))\n// 输出 \"false\"\n```\n这里的闭包把类`Checkerboard`的布尔型数组`boardColors`初始化为`true`和`false`交替的数组，可以用来标识国际象棋的棋盘。\n\n# 析构过程\nSwift会自动释放不再需要的实例以释放资源。如果我们需要进行一些额外的清理，就需要使用析构函数。\n每个类最多只能有一个析构函数。\n析构函数使用关键字`deinit`，不带任何参数，在写法上不带括号：\n``` swift\nclass ClassName {\n    deinit { \n\t//some action\n    }\n}\n```\n析构函数是在实例释放前被自动调用，不允许自己主动调用。\n子类的析构函数先调用，父类的析构函数后调用。子类没有提供析构函数，也会调用父类的析构函数。\n\n# 嵌套类型\n枚举，类和结构体可以想换嵌套，将需要嵌套的类型定义写在被嵌套类型的区域{}内，可以实现多级嵌套。\n\n``` swift\nstruct BlackjackCard {\n    // 嵌套定义枚举型Suit\n    enum Suit: Character {\n       case Spades = \"♠\", Hearts = \"♡\", Diamonds = \"♢\", Clubs = \"♣\"\n    }\n\n    // 嵌套定义枚举型Rank\n    enum Rank: Int {\n       case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten\n       case Jack, Queen, King, Ace\n       struct Values {\n           let first: Int, second: Int?\n       }\n       var values: Values {\n        switch self {\n        case .Ace:\n            return Values(first: 1, second: 11)\n        case .Jack, .Queen, .King:\n            return Values(first: 10, second: nil)\n        default:\n            return Values(first: self.toRaw(), second: nil)\n            }\n       }\n    }\n\n    // BlackjackCard 的属性和方法\n    let rank: Rank, suit: Suit\n    var description: String {\n    var output = \"suit is \\(suit.toRaw()),\"\n        output += \" value is \\(rank.values.first)\"\n        if let second = rank.values.second {\n            output += \" or \\(second)\"\n        }\n        return output\n    }\n}\n```\n结构体`BlackjackCard`用来存储“二十一点游戏”中的扑克牌，嵌套了枚举类型`Suit`表示花色，嵌套了枚举类型`Rank`表示点数。而且`Rank`中又定义了结构体`Values`准确描述牌的大小：数字牌表示本身数字的大小，`Ace`表示1或者11，`Jack`，`Queen`和`King`表示10。\n结构体有默认的成员构造函数，这里的默认构造函数为：\n``` swift\nlet theAceOfSpades = BlackjackCard(rank: .Ace, suit: .Spades)\nprintln(\"theAceOfSpades: \\(theAceOfSpades.description)\")\n// 打印出 \"theAceOfSpades: suit is ♠, value is 1 or 11\"\n\nlet heartsSymbol = BlackjackCard.Suit.Hearts.toRaw()\n// 红心的符号 为 \"♡\"\n```\n","source":"_posts/swift_8.md","raw":"title: \"Swift基础入门(8)：继承，构造，析构和嵌套类型\"\ndate: 2015-07-21 17:17:02\ntags:\n- swift\ncategories: swift\ntoc: true\n---\n\n本篇介绍Swift的基础知识：类的继承；枚举，结构体和类的构造过程，析构过程和嵌套类型。\n\n<!--more-->\n**Title: [Swift基础入门(8)：继承，构造，析构和嵌套类型](https://aidaizyy.github.io/swift_8)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-24](http://aidaizyy.github.io)**\n\n# 继承\n\n## 基本语法\n子类（_subclass_）继承（_inherit_）继承超类/父类（_superclass_）的属性，方法，下标和其他特性。\n声明子类时，将超类名写在子类名的后面，用冒号分割：\n``` swift\nclass Vehicle {\n    var currentSpeed = 0.0\n    var description: String {\n        return \"traveling at \\(currentSpeed) miles per hour\"\n    }\n    func makeNoise() {\n        // 什么也不做-因为车辆不一定会有噪音\n    }\n}\n\nclass Bicycle: Vehicle {\n    var hasBasket = false\n}\n\nclass Tandem: Bicycle {\n    var currentNumberOfPassengers = 0\n}\n\nlet tandem = Tandem()\ntandem.hasBasket = true\ntandem.currentNumberOfPassengers = 2\ntandem.currentSpeed = 22.0\nprintln(\"Tandem: \\(tandem.description)\")\n// Tandem: traveling at 22.0 miles per hour\n```\n\n## 重写\n重写（_overriding_）指子类把父类的实例方法，类方法，实例属性和下表脚本等提供自己定制的实现。\n在重写定义的前面加上关键字`override`。\n使用`super`前缀可以访问超类的属性，方法和下表脚本。\n\n### 重写方法\n``` swift\nclass Train: Vehicle {\n    override func makeNoise() {\n        println(\"Choo Choo\")\n    }\n}\n\nclass Car: Vehicle {\n    var gear = 1\n    override var description: String {\n        return super.description + \" in gear \\(gear)\"\n    }\n}\n\nlet train = Train()\ntrain.makeNoise()\n// prints \"Choo Choo\"\n```\n\n### 重写属性\n- 超类的只读属性在子类中可以重写为读写属性，但是读写属性不能重写为只读属性。\n- 超类的重写属性在子类中必须完整实现setter和getter，可以用`super.someProperty`返回超类的getter。\n``` swift\nclass Car: Vehicle {\n    var gear = 1\n    override var description: String {\n        return super.description + \" in gear \\(gear)\"\n    }\n}\n\nlet car = Car()\ncar.currentSpeed = 25.0\ncar.gear = 3\nprintln(\"Car: \\(car.description)\")\n// Car: traveling at 25.0 miles per hour in gear 3\n```\n\n### 重写属性观察器\nsetter和属性观察器不能同时存在，setter中可以观察到值的变化。\n``` swift\nclass AutomaticCar: Car {\n    override var currentSpeed: Double {\n        didSet {\n            gear = Int(currentSpeed / 10.0) + 1\n        }\n    }\n}\n\nlet automatic = AutomaticCar()\nautomatic.currentSpeed = 35.0\nprintln(\"AutomaticCar: \\(automatic.description)\")\n// AutomaticCar: traveling at 35.0 miles per hour in gear 4\n```\n\n## 防止重写\n属性，方法和下标前面加上`final`关键字可以防止它们被重写。\n`final var`，`final func`，`final class func`，`final subscript`。\n\n# 构造过程\n构造过程（_Inititalization_）为实例的每个属性设置初始值和为其执行必要的准备和初始化任务。\n\n## 构造器\n### 属性默认值\n属性声明时，可以为其设置默认值。\n``` swift\nstruct Fahrenheit {\n    var temperature = 32.0\n}\n\nvar f = Fahrenheit()\nprintln(\"The default temperature is \\(f.temperature)° Fahrenheit\")\n// 输出 \"The default temperature is 32.0° Fahrenheit”\n```\n构造器，也可以为属性赋初始值，关键字`init`。\n``` swift\nstruct Fahrenheit {\n    var temperature: Double\n    init() {\n        temperature = 32.0\n    }\n}\n\nvar f = Fahrenheit()\nprintln(\"The default temperature is \\(f.temperature)° Fahrenheit\")\n// 输出 \"The default temperature is 32.0° Fahrenheit”\n```\n\n### 构造器参数\n构造器可以传入参数。\n传入参数默认具有和内部参数名一致的外部参数名，相当于默认在参数名前加上了`#`。\n用`_`替代外部参数名，可以取消默认的外部参数名。\n``` swift\nstruct Color {\n    let red, green, blue: Double\n    init(red: Double, g green: Double, _ blue: Double) {\n        self.red   = red\n        self.green = green\n        self.blue  = blue\n    }\n    init(white: Double) {\n        red   = white\n        green = white\n        blue  = white\n    }\n}\n\nlet magenta = Color(red: 1.0, g: 0.0, 1.0)\nlet halfGray = Color(white: 0.5)\n```\n\n### 可选类型属性\n如果属性为可选类型，构造器自动初始化为`nil`。\n\n### 常量属性\n构造器中可以修改常量`let`属性的值，在构造过程中结束后，常量的值不能被修改。\n\n### 默认构造器\n所有属性已提供默认值且没有定义构造器的结构体或基类，具有一个默认的构造器，把默认值赋值给属性作为初始值。\n\n前面讲过，结构体的逐一成员构造器，算是一个默认的构造器。\n``` swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nlet twoByTwo = Size(width: 2.0, height: 2.0)\n```\n这里`Size`获得了一个逐一成员构造器`init(width: height: )`。\n\n## 值类型的构造器代理\n构造器可以通过调用其他构造器来完成构造过程，称为构造器代理。\n值类型比较简单，只能调用本身提供的其他构造器，而类可以继承构造器。\n``` swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Point {\n    var x = 0.0, y = 0.0\n}\n\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    init() {}\n    init(origin: Point, size: Size) {\n        self.origin = origin\n        self.size = size\n    }\n    init(center: Point, size: Size) {\n        let originX = center.x - (size.width / 2)\n        let originY = center.y - (size.height / 2)\n        self.init(origin: Point(x: originX, y: originY), size: size)\n    }\n}\n```\n结构体`Rect`中实现了三个构造器。\n第一个构造器功能和默认构造器类似，把默认值赋值给属性。\n第二个构造器功能和逐一成员构造器类似，逐一把值赋值给属性。\n第三个构造器调用了第二个构造器，完成了部分构造过程。\n\n## 类的构造器代理\n\n### 指定构造器和便利构造器\n类类型的构造器要确保所有存储型属性获得初始值，包括继承来的属性，分为指定构造器和便利构造器。\n- 指定构造器\n主要的类构造器，根据父类链依次往上调用父类的构造器，每个类都必须拥有至少一个指定构造器。\n写法和值类型的构造器一样：\n``` swift\ninit(parameters) {\n    statements\n}\n```\n- 便利构造器\n次要的类构造器，调用同一个类中的指定构造器，也可以创建一个特殊用途或特定输入的实例，只在必要时提供便利构造器。\n写法和值类型的构造器也基本一样，在`init`前加上`convenience`关键字：\n``` swift\nconvenience init(parameters) {\n    statements\n}\n```\n\n+ 指定构造器必须调用其直接父类的指定构造器。\n+ 便利构造器必须调用同一类中定义的其他构器。\n+ 便利构造器必须最终以调用一个指定构造器结束。\n\n也就是说：\n- 指定构造器必须总是向上代理\n- 便利构造器必须总是横向代理\n\n### 构造器继承和重写\n重写（_Override_）指定构造器，在子类中重写实现并调用父类构造器。\n重写便利构造器，必须通过调用同一类提供的其他指定构造器来实现。\n\n子类不会默认继承父类的构造器。\n如果特定条件满足，父类构造器也会被自动继承：\n- 子类的任意新属性都有默认值，且没有定义任何指定构造器，它将自动继承所有父类的指定构造器。\n- 子类提供了所有父类指定构造器的实现，它将自动继承所有父类的便利构造器。\n\n### 构造过程\n构造过程分为两个阶段。\n第一个阶段：\n沿着构造器链先初始化子类的属性，再代理给父类构造器，初始化父类的属性。\n当到达构造器链最顶部时，所有的存储型属性都已经赋值。\n这个阶段不能调用任何实例方法，不能读取任何实例属性的值，不能引用`self`的值。\n\n第二个阶段：\n沿着构造器链沿相反方向，从顶部向下，进一步定制实例，可以为任意属性赋新值。\n这个阶段可以调用实例方法，修改实例属性，并访问`self`。\n\n### 实例\n``` swift\nclass Food {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n    convenience init() {\n        self.init(name: \"[Unnamed]\")\n    }\n}\n\nlet namedMeat = Food(name: \"Bacon\")\n// namedMeat 的名字是 \"Bacon”\n\nlet mysteryMeat = Food()\n// mysteryMeat 的名字是 [Unnamed]\n```\n类`Food`提供了一个指定构造器`init(name: String)`和一个便利构造器`init()`。\n第11行：指定构造器，初始化属性`name`，因为`Food`没有父类，所以结束构造过程。\n第14行：便利构造器，调用了同一个类的指定构造器并给参数`name`传入值`[Unnamed]`。\n``` swift\nclass RecipeIngredient: Food {\n    var quantity: Int\n    init(name: String, quantity: Int) {\n        self.quantity = quantity\n        super.init(name: name)\n    }\n    override convenience init(name: String) {\n        self.init(name: name, quantity: 1)\n    }\n}\n\nlet sixEggs = RecipeIngredient(name: \"Eggs\", quantity: 6)\nlet oneBacon = RecipeIngredient(name: \"Bacon\")\nlet oneMysteryItem = RecipeIngredient()\n```\n类`RecipeIngredient`继承类`Food`，提供了一个指定构造器`init(name: String, quantity: Int)`和一个便利构造器`init(name: String)。\n第12行：指定构造器，先初始化子类的属性`quantity`，再代理给父类`Food`的`init(name: String)`。\n第13行：便利构造器，调用了同一个类的指定构造器并给参数`name`和`quantity`传入了值。\n因为`init(name: String)`和父类的`init(name: String)`使用了相同的参数，所以在前面使用`override`标识。\n第14行：父类的`init()`被子类继承了，但是它其中调用的`init(name: String)`替换成子类`RecipeIngredient`重写过后的便利构造器。\n``` swift\nclass ShoppingListItem: RecipeIngredient {\n    var purchased = false\n    var description: String {\n    var output = \"\\(quantity) x \\(name.lowercaseString)\"\n        output += purchased ? \" ✔\" : \" ✘\"\n        return output\n    }\n}\n\nvar breakfastList = [\n    ShoppingListItem(),\n    ShoppingListItem(name: \"Bacon\"),\n    ShoppingListItem(name: \"Eggs\", quantity: 6),\n]\nbreakfastList[0].name = \"Orange juice\"\nbreakfastList[0].purchased = true\nfor item in breakfastList {\n    println(item.description)\n}\n// 1 x orange juice ✔\n// 1 x bacon ✘\n// 6 x eggs ✘\n```\n类`ShoppingListItem`继承类`RecipeIngredient`。\n因为子类的新属性`purchased`有默认值，而且自己没有定义任何构造器，所以继承了父类的所有指定构造器。\n这时就满足上面提到继承父类构造器的第二个条件：子类提供了所有父类指定构造器的实现。\n所以子类也继承了父类的所有便利构造器。\n类`shoppingListItem`就继承了`init()`，`init(name: String)`和`init(name: String, quantity: Int)`三种构造器。\n\n## 可失败构造器\n构造过程中可能因为传入无效参数值，缺少资源，不满足必要条件等原因构造失败的构造器，称为可失败构造器。\n\n### 基本语法\n可失败构造器在`init`关键字后面加上`?`，即`init?`。\n并在失败的情况下加上`return nil`使构造器返回`nil`，非可失败构造器中不能使用`return`返回值。\n可失败构造器的参数名和参数类型不能与其他非可失败构造器完全相同。\n``` swift\nstruct Animal {\n    let species: String\n    init?(species: String) {\n        if species.isEmpty { return nil }\n        self.species = species\n    }\n}\n\nlet someCreature = Animal(species: \"Giraffe\")\n// someCreature 的类型是 Animal? 而不是 Animal\n\nif let giraffe = someCreature {\n    println(\"An animal was initialized with a species of \\(giraffe.species)\")\n}\n// 打印 \"An animal was initialized with a species of Giraffe\"\n\nlet anonymousCreature = Animal(species: \"\")\n// anonymousCreature 的类型是 Animal?, 而不是 Animal\n\nif anonymousCreature == nil {\n    println(\"The anonymous creature could not be initialized\")\n}\n// 打印 \"The anonymous creature could not be initialized\"\n```\n\n### 枚举类型的可失败构造器\n``` swift\nenum TemperatureUnit {\n    case Kelvin, Celsius, Fahrenheit\n    init?(symbol: Character) {\n        switch symbol {\n        case \"K\":\n            self = .Kelvin\n        case \"C\":\n            self = .Celsius\n        case \"F\":\n            self = .Fahrenheit\n        default:\n            return nil\n        }\n    }\n}\n\nlet fahrenheitUnit = TemperatureUnit(symbol: \"F\")\nif fahrenheitUnit != nil {\n    println(\"This is a defined temperature unit, so initialization succeeded.\")\n}\n// 打印 \"This is a defined temperature unit, so initialization succeeded.\"\n\nlet unknownUnit = TemperatureUnit(symbol: \"X\")\nif unknownUnit == nil {\n    println(\"This is not a defined temperature unit, so initialization failed.\")\n}\n// 打印 \"This is not a defined temperature unit, so initialization failed.\"\n```\n当参数值不能与任意一枚举成员相匹配时，该枚举类型的构建过程失败。\n\n带原始值的枚举类型会自带一个可失败构造器`init?(rawValue: )`，`rawValue`是一个默认参数，和枚举类型的原始值类型一致。\n如果该参数的值能和枚举类型成员所带的原始值匹配，则构建器构造一个带此原始值的枚举成员，否则构造失败。\n上面的例子可以重写为：\n``` swift\nenum TemperatureUnit: Character {\n    case Kelvin = \"K\", Celsius = \"C\", Fahrenheit = \"F\"\n}\n\nlet fahrenheitUnit = TemperatureUnit(rawValue: \"F\")\nif fahrenheitUnit != nil {\n    println(\"This is a defined temperature unit, so initialization succeeded.\")\n}\n// prints \"This is a defined temperature unit, so initialization succeeded.\"\n\nlet unknownUnit = TemperatureUnit(rawValue: \"X\")\nif unknownUnit == nil {\n    println(\"This is not a defined temperature unit, so initialization failed.\")\n}\n// prints \"This is not a defined temperature unit, so initialization failed.\"\n```\n\n### 类的可失败构造器\n类的可失败构造器只能在所有类属性被初始化和所有类之间的构造代理之间的代理调用发生完后触发失败行为。\n而值类型的可失败构造器可以随时随地触发。\n``` swift\nclass Product {\n    let name: String!\n    init?(name: String) {\n        self.name = name\n        if name.isEmpty { return nil }\n    }\n}\n\nif let bowTie = Product(name: \"bow tie\") {\n    // 不需要检查 bowTie.name == nil\n    println(\"The product's name is \\(bowTie.name)\")\n}\n// 打印 \"The product's name is bow tie\"\n```\n类`Product`的可失败构造器必须建立在`name`被赋值的情况下。\n所以`name`被声明为隐式解析可选类型（`String!`）保证触发失败条件时，`name`一定有值。\n类`Prodcut`构建成功时，`name`一定有一个非`nil`值，可以直接访问`name`。\n\n### 可失败构造器的代理\n可失败构造器的代理规则和构造器基本一致，只是一旦触发构造失败，整个构造过程就会被立即终止。\n可失败构造器可以在同一类中代理调用其他非可失败构造器，这样可以为已有的构造器添加构造失败的条件。\n``` swift\nclass Product {\n    let name: String!\n    init?(name: String) {\n        if name.isEmpty { return nil }\n        self.name = name\n    }\n}\n\nclass CartItem: Product {\n    let quantity: Int!\n    init?(name: String, quantity: Int) {\n        super.init(name: name)\n        if quantity < 1 { return nil }\n        self.quantity = quantity\n    }\n}\n\nif let twoSocks = CartItem(name: \"sock\", quantity: 2) {\n    println(\"Item: \\(twoSocks.name), quantity: \\(twoSocks.quantity)\")\n}\n// 打印 \"Item: sock, quantity: 2\"\n\nif let zeroShirts = CartItem(name: \"shirt\", quantity: 0) {\n    println(\"Item: \\(zeroShirts.name), quantity: \\(zeroShirts.quantity)\")\n} else {\n    println(\"Unable to initialize zero shirts\")\n}\n// 打印 \"Unable to initialize zero shirts\"\n\nif let oneUnnamed = CartItem(name: \"\", quantity: 1) {\n    println(\"Item: \\(oneUnnamed.name), quantity: \\(oneUnnamed.quantity)\")\n} else {\n    println(\"Unable to initialize one unnamed product\")\n}\n// 打印 \"Unable to initialize one unnamed product\"\n```\n第18行：构造成功。\n第23行：`quantiry`的值小于`1`，不满足条件，构造失败。\n第30行：`name`为空，父类`Product`可失败构造器触发构造失败，整个构造过程停止并失败。\n\n### 可失败构造器的重写\n父类的可失败构造器可以被子类的可失败构造器或者非可失败构造器重写。\n但是父类的非可失败构造器不可以被子类的可失败构造器重写。\n如果用非可失败构造器重写可失败构造器时，不再向上代理父类的可失败构造器，非可失败构造器不不会代理调用可失败构造器。\n``` swift\nclass Document {\n    var name: String?\n    // 该构造器构建了一个name属性值为nil的document对象\n    init() {}\n    // 该构造器构建了一个name属性值为非空字符串的document对象\n    init?(name: String) {\n        if name.isEmpty { return nil }\n        self.name = name\n    }\n}\n\nclass AutomaticallyNamedDocument: Document {\n    override init() {\n        super.init()\n        self.name = \"[Untitled]\"\n    }\n    override init(name: String) {\n        super.init()\n        if name.isEmpty {\n            self.name = \"[Untitled]\"\n        } else {\n            self.name = name\n        }\n    }\n}\n```\n\n### 隐私解析可选类型的可失败构造器\n`init!`同`init?`一样都是可失败构造器，该可失败构造器就会构造一个特定类型的隐私解析可选类型的对象。\n`init?`和`init!`可以相互代理调用，相互重写。\n`init`也可以代理调用`init!`，但这会触发一个断言：`init!`是否会触发构造失败。\n\n### 必要构造器\n在类的构造器前添加`required`关键字表示该类的子类都必须实现该构造器。\n子类重写父类的`required`必要构造器时，也要加上`required`关键字，也是必要构造器。\n覆盖基类的必要构造器时，不需要添加`override`关键字。\n``` swift\nclass SomeClass {\n    required init() {\n        // 在这里添加该必要构造器的实现代码\n    }\n}\n\nclass SomeSubclass: SomeClass {\n    required init() {\n        // 在这里添加子类必要构造器的实现代码\n    }\n}\n```\n不一定需要显示的实现父类的必要构造器，只要满足父类的必要构造器需求即可。\n\n## 闭包设置属性默认值\n闭包可以用来为属性提供定制的默认值，返回和属性类型相同类型的默认值。\n在闭包中不能使用其他属性，不能访问其他实例方法，不能使用`self`属性。\n``` swift\nclass SomeClass {\n    let someProperty: SomeType = {\n        // 在这个闭包中给 someProperty 创建一个默认值\n        // someValue 必须和 SomeType 类型相同\n        return someValue\n        }()\n}\n```\n闭包后面接`()`表示闭包立刻执行，否则会把闭包赋值给`someProperty`。\n``` swift\nstruct Checkerboard {\n    let boardColors: [Bool] = {\n        var temporaryBoard = [Bool]()\n        var isBlack = false\n        for i in 1...10 {\n            for j in 1...10 {\n                temporaryBoard.append(isBlack)\n                isBlack = !isBlack\n            }\n            isBlack = !isBlack\n        }\n        return temporaryBoard\n        }()\n    func squareIsBlackAtRow(row: Int, column: Int) -> Bool {\n        return boardColors[(row * 10) + column]\n    }\n}\n\nlet board = Checkerboard()\nprintln(board.squareIsBlackAtRow(0, column: 1))\n// 输出 \"true\"\nprintln(board.squareIsBlackAtRow(9, column: 9))\n// 输出 \"false\"\n```\n这里的闭包把类`Checkerboard`的布尔型数组`boardColors`初始化为`true`和`false`交替的数组，可以用来标识国际象棋的棋盘。\n\n# 析构过程\nSwift会自动释放不再需要的实例以释放资源。如果我们需要进行一些额外的清理，就需要使用析构函数。\n每个类最多只能有一个析构函数。\n析构函数使用关键字`deinit`，不带任何参数，在写法上不带括号：\n``` swift\nclass ClassName {\n    deinit { \n\t//some action\n    }\n}\n```\n析构函数是在实例释放前被自动调用，不允许自己主动调用。\n子类的析构函数先调用，父类的析构函数后调用。子类没有提供析构函数，也会调用父类的析构函数。\n\n# 嵌套类型\n枚举，类和结构体可以想换嵌套，将需要嵌套的类型定义写在被嵌套类型的区域{}内，可以实现多级嵌套。\n\n``` swift\nstruct BlackjackCard {\n    // 嵌套定义枚举型Suit\n    enum Suit: Character {\n       case Spades = \"♠\", Hearts = \"♡\", Diamonds = \"♢\", Clubs = \"♣\"\n    }\n\n    // 嵌套定义枚举型Rank\n    enum Rank: Int {\n       case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten\n       case Jack, Queen, King, Ace\n       struct Values {\n           let first: Int, second: Int?\n       }\n       var values: Values {\n        switch self {\n        case .Ace:\n            return Values(first: 1, second: 11)\n        case .Jack, .Queen, .King:\n            return Values(first: 10, second: nil)\n        default:\n            return Values(first: self.toRaw(), second: nil)\n            }\n       }\n    }\n\n    // BlackjackCard 的属性和方法\n    let rank: Rank, suit: Suit\n    var description: String {\n    var output = \"suit is \\(suit.toRaw()),\"\n        output += \" value is \\(rank.values.first)\"\n        if let second = rank.values.second {\n            output += \" or \\(second)\"\n        }\n        return output\n    }\n}\n```\n结构体`BlackjackCard`用来存储“二十一点游戏”中的扑克牌，嵌套了枚举类型`Suit`表示花色，嵌套了枚举类型`Rank`表示点数。而且`Rank`中又定义了结构体`Values`准确描述牌的大小：数字牌表示本身数字的大小，`Ace`表示1或者11，`Jack`，`Queen`和`King`表示10。\n结构体有默认的成员构造函数，这里的默认构造函数为：\n``` swift\nlet theAceOfSpades = BlackjackCard(rank: .Ace, suit: .Spades)\nprintln(\"theAceOfSpades: \\(theAceOfSpades.description)\")\n// 打印出 \"theAceOfSpades: suit is ♠, value is 1 or 11\"\n\nlet heartsSymbol = BlackjackCard.Suit.Hearts.toRaw()\n// 红心的符号 为 \"♡\"\n```\n","slug":"swift_8","published":1,"updated":"2015-07-24T09:04:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qrg0008meo3f0coo0k9"},{"title":"Swift基础入门(7)：属性，方法和下标","date":"2015-07-20T02:10:20.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：枚举，结构体和类的属性，方法和下标。\n\n<!--more-->\n**Title: [Swift基础入门(7)：属性，方法和下标](https://aidaizyy.github.io/swift_7)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-27](http://aidaizyy.github.io)**\n\n# 属性\n属性分为存储属性（只能用于类和结构体）和计算属性（可用于类，结构体和枚举）。\n\n## 存储属性\n存储属性可用`var`或`let`修饰。\n结构体用`let`修饰，属性不可以更改，因为结构体是值类型。\n类用`let`修饰，属性可以更改，因为类是引用类型。\n结构体可以在构造时逐一初始化属性，而类不可以，参见[类和结构体](http://aidaizyy.github.io/swift_6/#类和结构体)。\n- 延迟属性\n延迟属性用`lazy`标示，且必须使用`var`关键字，只有在第一次被调用时才会计算其初始值，在构造时不会计算初始值。\n``` swift\nclass DataImporter {\n    /*\n    DataImporter 是一个将外部文件中的数据导入的类。\n    这个类的初始化会消耗不少时间。\n    */\n    var fileName = \"data.txt\"\n    // 这是提供数据导入功能\n}\n\nclass DataManager {\n    lazy var importer = DataImporter()\n    var data = [String]()\n    // 这是提供数据管理功能\n}\n\nlet manager = DataManager()\nmanager.data.append(\"Some data\")\nmanager.data.append(\"Some more data\")\n// DataImporter 实例的 importer 属性还没有被创建\n\nprintln(manager.importer.fileName)\n// DataImporter 实例的 importer 属性现在被创建了\n// 输出 \"data.txt”\n```\n以上并未给出全部代码，类`DataManager`中声明了延迟属性`importer`。\n类`DataImporter`实现数据导入功能，会消耗不少时间。\n初始化类`DataManager`时，延迟属性并不会创建。\n只有在`println(manager.importer.fileName)`时，属性`importer`第一次被调用时，才会创建延迟属性`importer`，完成数据导入功能。\n\n## 计算属性\n计算属性不直接存储值，提供getter获取值和可选的setter来间接设置其他属性的值，必须用`var`修饰。\n``` swift\nstruct Point {\n    var x = 0.0, y = 0.0\n}\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n    get {\n        let centerX = origin.x + (size.width / 2)\n        let centerY = origin.y + (size.height / 2)\n        return Point(x: centerX, y: centerY)\n    }\n    set(newCenter) {\n        origin.x = newCenter.x - (size.width / 2)\n        origin.y = newCenter.y - (size.height / 2)\n    }\n    }\n}\nvar square = Rect(origin: Point(x: 0.0, y: 0.0),\n    size: Size(width: 10.0, height: 10.0))\nlet initialSquareCenter = square.center\nsquare.center = Point(x: 15.0, y: 15.0)\nprintln(\"square.origin is now at (\\(square.origin.x), \\(square.origin.y))\")\n// 输出 \"square.origin is now at (10.0, 10.0)”\n```\n在结构体`Rect`中，属性`center`是计算属性，分别设置了`get`方法和`set`方法。\n`set`方法可以不指定新值的参数名称，比如`newCenter`，在方法中直接使用默认名称`newValue`，上面可写作：\n``` swift\nset {\n        origin.x = newValue.x - (size.width / 2)\n        origin.y = newValue.y - (size.height / 2)\n    }\n```\n- 只读计算属性\n不设置setter，只设置getter的计算属性称为只读计算属性。\n``` swift\nstruct Cuboid {\n    var width = 0.0, height = 0.0, depth = 0.0\n    var volume: Double {\n    return width * height * depth\n    }\n}\nlet fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)\nprintln(\"the volume of fourByFiveByTwo is \\(fourByFiveByTwo.volume)\")\n// 输出 \"the volume of fourByFiveByTwo is 40.0\"\n```\n只读计算属性可省略`get`关键字。\n\n## 属性观察器\n属性观察器可以监控和响应属性值的变化。\n- willSet 在设置新值之前调用\n- didSet 在设置新值之后调用\n``` swift\nclass StepCounter {\n    var totalSteps: Int = 0 {\n    willSet(newTotalSteps) {\n        println(\"About to set totalSteps to \\(newTotalSteps)\")\n    }\n    didSet(oldTotalSteps) {\n        if totalSteps > oldTotalSteps  {\n            println(\"Added \\(totalSteps - oldTotalSteps) steps\")\n        }\n    }\n    }\n}\nlet stepCounter = StepCounter()\nstepCounter.totalSteps = 200\n// About to set totalSteps to 200\n// Added 200 steps\nstepCounter.totalSteps = 360\n// About to set totalSteps to 360\n// Added 160 steps\nstepCounter.totalSteps = 896\n// About to set totalSteps to 896\n// Added 536 steps\n```\n`willSet`如果不指定新值参数名，可用`newValue`替代。\n`didSet`如果不指定旧值参数名，可用`oldValue`替代。\n通过重写的方式可以为继承来的存储属性和计算属性添加属性观察器。\n\n计算属性和属性观察器也可以用于全局变量和局部变量。\n全局的常量变量都是延迟计算的，不需要标记`lazy`。而局部的常量变量不会延迟计算。\n\n## 类型属性\n类型属性指所有类型实例公用的属性，类似于其他语言中的静态属性（_static_）。\n值类型（枚举和结构体）可以定义存储型和计算型的类型属性。\n引用类型（类）只能定义计算型的类型属性。\n存储型的类型属性必须指定默认值。\n\n值类型（枚举和结构体）中在类型属性前加上关键字`static`，而引用类型（类）中在类型属性前加上关键字`class`。\n``` swift\nstruct SomeStructure {\n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n    // 这里返回一个 Int 值\n    }\n}\nenum SomeEnumeration {\n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n    // 这里返回一个 Int 值\n    }\n}\nclass SomeClass {\n    class var computedTypeProperty: Int {\n    // 这里返回一个 Int 值\n    }\n}\n\nprintln(SomeClass.computedTypeProperty)\n// 输出 \"42\"\n\nprintln(SomeStructure.storedTypeProperty)\n// 输出 \"Some value.\"\nSomeStructure.storedTypeProperty = \"Another value.\"\nprintln(SomeStructure.storedTypeProperty)\n// 输出 \"Another value.”\n```\n这里计算型类型属性都是只读型，也可以定义为可读可写。\n\n# 方法\n\n## 实例方法\n方法是定义在类，结构体和枚举中的方法，和函数类似。\n类，结构体和枚举创建实例后，其中的方法被称为实例方法，只属于当前实例。\n``` swift\nclass Counter {\n  var count = 0\n  func increment() {\n    count++\n  }\n  func incrementBy(amount: Int) {\n    count += amount\n  }\n  func reset() {\n    count = 0\n  }\n}\n\nlet counter = Counter()\n// 初始计数值是0\ncounter.increment()\n// 计数值现在是1\ncounter.incrementBy(5)\n// 计数值现在是6\ncounter.reset()\n// 计数值现在是0\n```\n### 外部参数名\n方法默认第一个参数没有外部参数名，第二个及以后参数默认有外部参数名，和参数名一致，相当于默认在参数前加上了`#`。\n``` swift\nclass Counter {\n  var count: Int = 0\n  func incrementBy(amount: Int, numberOfTimes: Int) {\n    count += amount * numberOfTimes\n  }\n}\n\nlet counter = Counter()\ncounter.incrementBy(5, numberOfTimes: 3)\n// counter value is now 15\n```\n也可以在第一个参数名添加外部参数名，也可以用_放在第二个及以后的参数名前取消默认的外部参数名。\n``` swift\nclass Counter {\n    var count: Int = 0\n    func incrementBy(#amount: Int, _ numberOfTimes: Int) {\n        count += amount * numberOfTimes\n    }\n}\n\nlet counter = Counter()\ncounter.incrementBy(amount: 5, 3)\nprintln(counter.count)\n// counter value is now 15\n```\n关于外部参数名，参见[函数的外部参数名](http://aidaizyy.github.io/swift_5/#外部参数名)。\n\n### self属性\n在每个实例中，都有一个隐藏属性`self`，指代实例变身，以便方法调用实例本身。\n``` swift\nfunc increment() {\n  self.count++\n}\n```\n\n### 变异方法\n结构体和枚举是值类型。值类型的属性不可以在实例方法中被修改。\n变异方法可以完成对属性的修改，在`func`前加上`mutating`关键字。\n``` swift\nstruct Point {\n  var x = 0.0, y = 0.0\n  mutating func moveByX(deltaX: Double, y deltaY: Double) {\n    x += deltaX\n    y += deltaY\n  }\n}\nvar somePoint = Point(x: 1.0, y: 1.0)\nsomePoint.moveByX(2.0, y: 3.0)\nprintln(\"The point is now at (\\(somePoint.x), \\(somePoint.y))\")\n// 输出 \"The point is now at (3.0, 4.0)\"\n```\n变异方法也可以给`self`赋值，即新建一个实例替代旧的实例。\n``` swift\nstruct Point {\n  var x = 0.0, y = 0.0\n  mutating func moveByX(deltaX: Double, y deltaY: Double) {\n    self = Point(x: x + deltaX, y: y + deltaY)\n  }\n}\n```\n``` swift\nenum TriStateSwitch {\n  case Off, Low, High\n  mutating func next() {\n    switch self {\n    case Off:\n      self = Low\n    case Low:\n      self = High\n    case High:\n      self = Off\n    }\n  }\n}\nvar ovenLight = TriStateSwitch.Low\novenLight.next()\n// ovenLight 现在等于 .High\novenLight.next()\n// ovenLight 现在等于 .Off\n```\n类是引用类型，实例方法可以直接修改属性。\n\n## 类型方法\n类型方法和类型属性类似，都是指所有类型实例公共的方法，类似于其他语言中的静态方法（_static_）。\n类型方法在类型前加上`class`关键字。\n类型方法能够直接通过静态属性的名称访问静态属性。\n``` swift\nclass SomeClass {\n  class func someTypeMethod() {\n    // type method implementation goes here\n  }\n}\nSomeClass.someTypeMethod()\n```\n\n# 下标\n下标（_subscripts_）可以定义在类，结构体和枚举中，是访问对象，集合和序列的快捷方式。比如[数组的访问](http://aidaizyy.github.io/swift_3/#访问)：Array[index]，[字典的访问](http://aidaizyy.github.io/swift_3/#访问-1)：Dictionary[key]。\n下标的定义类似于实例方法和计算性属性的混合。\n使用`subscript`关键字，定义了传入参数数量和类型和返回类型，定义了getter和setter。\n``` swift\nsubscript(index: Int) -> Int {\n    get {\n      // 返回与入参匹配的Int类型的值\n    }\n\n    set(newValue) {\n      // 执行赋值操作\n    }\n}\n```\ngetter和setter的定义和计算型属性一样。\nsetter中可以使用`newValue`默认值，可以省略setter定义成只读类型。\n``` swift\nstruct TimesTable {\n    let multiplier: Int\n    subscript(index: Int) -> Int {\n      return multiplier * index\n    }\n}\nlet threeTimesTable = TimesTable(multiplier: 3)\nprintln(\"3的6倍是\\(threeTimesTable[6])\")\n// 输出 \"3的6倍是18\"\n```\n下标允许任意数量的传入参数，任意类型的传入参数和任意类型的返回值。\n可以使用[变量参数](http://aidaizyy.github.io/swift_5/#变量参数)和[可变参数](http://aidaizyy.github.io/swift_5/#可变参数)，但是不能使用[输入输出参数（inout）](http://aidaizyy.github.io/swift_5/#输入输出参数)和[默认参数值](http://aidaizyy.github.io/swift_5/#默认参数值)。\n``` swift\nstruct Matrix {\n    let rows: Int, columns: Int\n    var grid: [Double]\n    init(rows: Int, columns: Int) {\n      self.rows = rows\n      self.columns = columns\n      grid = Array(count: rows * columns, repeatedValue: 0.0)\n    }\n    func indexIsValidForRow(row: Int, column: Int) -> Bool {\n        return row >= 0 && row < rows && column >= 0 && column < columns\n    }\n    subscript(row: Int, column: Int) -> Double {\n        get {\n            assert(indexIsValidForRow(row, column: column), \"Index out of range\")\n            return grid[(row * columns) + column]\n        }\n        set {\n            assert(indexIsValidForRow(row, column: column), \"Index out of range\")\n            grid[(row * columns) + column] = newValue\n        }\n    }\n}\n\nvar matrix = Matrix(rows: 2, columns: 2)\nprintln(matrix[0, 1])\n//0.0\nmatrix[0, 1] = 1.5\nprintln(matrix[0, 1])\n//1.5\n```\n","source":"_posts/swift_7.md","raw":"title: \"Swift基础入门(7)：属性，方法和下标\"\ndate: 2015-07-20 10:10:20\ntags:\n- swift\ncategories: swift\ntoc: true\n---\n\n本篇介绍Swift的基础知识：枚举，结构体和类的属性，方法和下标。\n\n<!--more-->\n**Title: [Swift基础入门(7)：属性，方法和下标](https://aidaizyy.github.io/swift_7)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-27](http://aidaizyy.github.io)**\n\n# 属性\n属性分为存储属性（只能用于类和结构体）和计算属性（可用于类，结构体和枚举）。\n\n## 存储属性\n存储属性可用`var`或`let`修饰。\n结构体用`let`修饰，属性不可以更改，因为结构体是值类型。\n类用`let`修饰，属性可以更改，因为类是引用类型。\n结构体可以在构造时逐一初始化属性，而类不可以，参见[类和结构体](http://aidaizyy.github.io/swift_6/#类和结构体)。\n- 延迟属性\n延迟属性用`lazy`标示，且必须使用`var`关键字，只有在第一次被调用时才会计算其初始值，在构造时不会计算初始值。\n``` swift\nclass DataImporter {\n    /*\n    DataImporter 是一个将外部文件中的数据导入的类。\n    这个类的初始化会消耗不少时间。\n    */\n    var fileName = \"data.txt\"\n    // 这是提供数据导入功能\n}\n\nclass DataManager {\n    lazy var importer = DataImporter()\n    var data = [String]()\n    // 这是提供数据管理功能\n}\n\nlet manager = DataManager()\nmanager.data.append(\"Some data\")\nmanager.data.append(\"Some more data\")\n// DataImporter 实例的 importer 属性还没有被创建\n\nprintln(manager.importer.fileName)\n// DataImporter 实例的 importer 属性现在被创建了\n// 输出 \"data.txt”\n```\n以上并未给出全部代码，类`DataManager`中声明了延迟属性`importer`。\n类`DataImporter`实现数据导入功能，会消耗不少时间。\n初始化类`DataManager`时，延迟属性并不会创建。\n只有在`println(manager.importer.fileName)`时，属性`importer`第一次被调用时，才会创建延迟属性`importer`，完成数据导入功能。\n\n## 计算属性\n计算属性不直接存储值，提供getter获取值和可选的setter来间接设置其他属性的值，必须用`var`修饰。\n``` swift\nstruct Point {\n    var x = 0.0, y = 0.0\n}\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n    get {\n        let centerX = origin.x + (size.width / 2)\n        let centerY = origin.y + (size.height / 2)\n        return Point(x: centerX, y: centerY)\n    }\n    set(newCenter) {\n        origin.x = newCenter.x - (size.width / 2)\n        origin.y = newCenter.y - (size.height / 2)\n    }\n    }\n}\nvar square = Rect(origin: Point(x: 0.0, y: 0.0),\n    size: Size(width: 10.0, height: 10.0))\nlet initialSquareCenter = square.center\nsquare.center = Point(x: 15.0, y: 15.0)\nprintln(\"square.origin is now at (\\(square.origin.x), \\(square.origin.y))\")\n// 输出 \"square.origin is now at (10.0, 10.0)”\n```\n在结构体`Rect`中，属性`center`是计算属性，分别设置了`get`方法和`set`方法。\n`set`方法可以不指定新值的参数名称，比如`newCenter`，在方法中直接使用默认名称`newValue`，上面可写作：\n``` swift\nset {\n        origin.x = newValue.x - (size.width / 2)\n        origin.y = newValue.y - (size.height / 2)\n    }\n```\n- 只读计算属性\n不设置setter，只设置getter的计算属性称为只读计算属性。\n``` swift\nstruct Cuboid {\n    var width = 0.0, height = 0.0, depth = 0.0\n    var volume: Double {\n    return width * height * depth\n    }\n}\nlet fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)\nprintln(\"the volume of fourByFiveByTwo is \\(fourByFiveByTwo.volume)\")\n// 输出 \"the volume of fourByFiveByTwo is 40.0\"\n```\n只读计算属性可省略`get`关键字。\n\n## 属性观察器\n属性观察器可以监控和响应属性值的变化。\n- willSet 在设置新值之前调用\n- didSet 在设置新值之后调用\n``` swift\nclass StepCounter {\n    var totalSteps: Int = 0 {\n    willSet(newTotalSteps) {\n        println(\"About to set totalSteps to \\(newTotalSteps)\")\n    }\n    didSet(oldTotalSteps) {\n        if totalSteps > oldTotalSteps  {\n            println(\"Added \\(totalSteps - oldTotalSteps) steps\")\n        }\n    }\n    }\n}\nlet stepCounter = StepCounter()\nstepCounter.totalSteps = 200\n// About to set totalSteps to 200\n// Added 200 steps\nstepCounter.totalSteps = 360\n// About to set totalSteps to 360\n// Added 160 steps\nstepCounter.totalSteps = 896\n// About to set totalSteps to 896\n// Added 536 steps\n```\n`willSet`如果不指定新值参数名，可用`newValue`替代。\n`didSet`如果不指定旧值参数名，可用`oldValue`替代。\n通过重写的方式可以为继承来的存储属性和计算属性添加属性观察器。\n\n计算属性和属性观察器也可以用于全局变量和局部变量。\n全局的常量变量都是延迟计算的，不需要标记`lazy`。而局部的常量变量不会延迟计算。\n\n## 类型属性\n类型属性指所有类型实例公用的属性，类似于其他语言中的静态属性（_static_）。\n值类型（枚举和结构体）可以定义存储型和计算型的类型属性。\n引用类型（类）只能定义计算型的类型属性。\n存储型的类型属性必须指定默认值。\n\n值类型（枚举和结构体）中在类型属性前加上关键字`static`，而引用类型（类）中在类型属性前加上关键字`class`。\n``` swift\nstruct SomeStructure {\n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n    // 这里返回一个 Int 值\n    }\n}\nenum SomeEnumeration {\n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n    // 这里返回一个 Int 值\n    }\n}\nclass SomeClass {\n    class var computedTypeProperty: Int {\n    // 这里返回一个 Int 值\n    }\n}\n\nprintln(SomeClass.computedTypeProperty)\n// 输出 \"42\"\n\nprintln(SomeStructure.storedTypeProperty)\n// 输出 \"Some value.\"\nSomeStructure.storedTypeProperty = \"Another value.\"\nprintln(SomeStructure.storedTypeProperty)\n// 输出 \"Another value.”\n```\n这里计算型类型属性都是只读型，也可以定义为可读可写。\n\n# 方法\n\n## 实例方法\n方法是定义在类，结构体和枚举中的方法，和函数类似。\n类，结构体和枚举创建实例后，其中的方法被称为实例方法，只属于当前实例。\n``` swift\nclass Counter {\n  var count = 0\n  func increment() {\n    count++\n  }\n  func incrementBy(amount: Int) {\n    count += amount\n  }\n  func reset() {\n    count = 0\n  }\n}\n\nlet counter = Counter()\n// 初始计数值是0\ncounter.increment()\n// 计数值现在是1\ncounter.incrementBy(5)\n// 计数值现在是6\ncounter.reset()\n// 计数值现在是0\n```\n### 外部参数名\n方法默认第一个参数没有外部参数名，第二个及以后参数默认有外部参数名，和参数名一致，相当于默认在参数前加上了`#`。\n``` swift\nclass Counter {\n  var count: Int = 0\n  func incrementBy(amount: Int, numberOfTimes: Int) {\n    count += amount * numberOfTimes\n  }\n}\n\nlet counter = Counter()\ncounter.incrementBy(5, numberOfTimes: 3)\n// counter value is now 15\n```\n也可以在第一个参数名添加外部参数名，也可以用_放在第二个及以后的参数名前取消默认的外部参数名。\n``` swift\nclass Counter {\n    var count: Int = 0\n    func incrementBy(#amount: Int, _ numberOfTimes: Int) {\n        count += amount * numberOfTimes\n    }\n}\n\nlet counter = Counter()\ncounter.incrementBy(amount: 5, 3)\nprintln(counter.count)\n// counter value is now 15\n```\n关于外部参数名，参见[函数的外部参数名](http://aidaizyy.github.io/swift_5/#外部参数名)。\n\n### self属性\n在每个实例中，都有一个隐藏属性`self`，指代实例变身，以便方法调用实例本身。\n``` swift\nfunc increment() {\n  self.count++\n}\n```\n\n### 变异方法\n结构体和枚举是值类型。值类型的属性不可以在实例方法中被修改。\n变异方法可以完成对属性的修改，在`func`前加上`mutating`关键字。\n``` swift\nstruct Point {\n  var x = 0.0, y = 0.0\n  mutating func moveByX(deltaX: Double, y deltaY: Double) {\n    x += deltaX\n    y += deltaY\n  }\n}\nvar somePoint = Point(x: 1.0, y: 1.0)\nsomePoint.moveByX(2.0, y: 3.0)\nprintln(\"The point is now at (\\(somePoint.x), \\(somePoint.y))\")\n// 输出 \"The point is now at (3.0, 4.0)\"\n```\n变异方法也可以给`self`赋值，即新建一个实例替代旧的实例。\n``` swift\nstruct Point {\n  var x = 0.0, y = 0.0\n  mutating func moveByX(deltaX: Double, y deltaY: Double) {\n    self = Point(x: x + deltaX, y: y + deltaY)\n  }\n}\n```\n``` swift\nenum TriStateSwitch {\n  case Off, Low, High\n  mutating func next() {\n    switch self {\n    case Off:\n      self = Low\n    case Low:\n      self = High\n    case High:\n      self = Off\n    }\n  }\n}\nvar ovenLight = TriStateSwitch.Low\novenLight.next()\n// ovenLight 现在等于 .High\novenLight.next()\n// ovenLight 现在等于 .Off\n```\n类是引用类型，实例方法可以直接修改属性。\n\n## 类型方法\n类型方法和类型属性类似，都是指所有类型实例公共的方法，类似于其他语言中的静态方法（_static_）。\n类型方法在类型前加上`class`关键字。\n类型方法能够直接通过静态属性的名称访问静态属性。\n``` swift\nclass SomeClass {\n  class func someTypeMethod() {\n    // type method implementation goes here\n  }\n}\nSomeClass.someTypeMethod()\n```\n\n# 下标\n下标（_subscripts_）可以定义在类，结构体和枚举中，是访问对象，集合和序列的快捷方式。比如[数组的访问](http://aidaizyy.github.io/swift_3/#访问)：Array[index]，[字典的访问](http://aidaizyy.github.io/swift_3/#访问-1)：Dictionary[key]。\n下标的定义类似于实例方法和计算性属性的混合。\n使用`subscript`关键字，定义了传入参数数量和类型和返回类型，定义了getter和setter。\n``` swift\nsubscript(index: Int) -> Int {\n    get {\n      // 返回与入参匹配的Int类型的值\n    }\n\n    set(newValue) {\n      // 执行赋值操作\n    }\n}\n```\ngetter和setter的定义和计算型属性一样。\nsetter中可以使用`newValue`默认值，可以省略setter定义成只读类型。\n``` swift\nstruct TimesTable {\n    let multiplier: Int\n    subscript(index: Int) -> Int {\n      return multiplier * index\n    }\n}\nlet threeTimesTable = TimesTable(multiplier: 3)\nprintln(\"3的6倍是\\(threeTimesTable[6])\")\n// 输出 \"3的6倍是18\"\n```\n下标允许任意数量的传入参数，任意类型的传入参数和任意类型的返回值。\n可以使用[变量参数](http://aidaizyy.github.io/swift_5/#变量参数)和[可变参数](http://aidaizyy.github.io/swift_5/#可变参数)，但是不能使用[输入输出参数（inout）](http://aidaizyy.github.io/swift_5/#输入输出参数)和[默认参数值](http://aidaizyy.github.io/swift_5/#默认参数值)。\n``` swift\nstruct Matrix {\n    let rows: Int, columns: Int\n    var grid: [Double]\n    init(rows: Int, columns: Int) {\n      self.rows = rows\n      self.columns = columns\n      grid = Array(count: rows * columns, repeatedValue: 0.0)\n    }\n    func indexIsValidForRow(row: Int, column: Int) -> Bool {\n        return row >= 0 && row < rows && column >= 0 && column < columns\n    }\n    subscript(row: Int, column: Int) -> Double {\n        get {\n            assert(indexIsValidForRow(row, column: column), \"Index out of range\")\n            return grid[(row * columns) + column]\n        }\n        set {\n            assert(indexIsValidForRow(row, column: column), \"Index out of range\")\n            grid[(row * columns) + column] = newValue\n        }\n    }\n}\n\nvar matrix = Matrix(rows: 2, columns: 2)\nprintln(matrix[0, 1])\n//0.0\nmatrix[0, 1] = 1.5\nprintln(matrix[0, 1])\n//1.5\n```\n","slug":"swift_7","published":1,"updated":"2015-07-31T02:47:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qrj000bmeo3jn5fla5g"},{"title":"Swift基础入门(6)：枚举，类和结构体","date":"2015-07-19T14:47:43.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：枚举，类和结构体的基本概念和语法。\n\n<!--more-->\n**Title: [Swift基础入门(6)：枚举，类和结构体](https://aidaizyy.github.io/swift_6)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-24](http://aidaizyy.github.io)**\n\n# 枚举\n\n## 枚举语法\n枚举定义了一个通用来兴的一组相关的值。\n``` swift\nenum CompassPoint {\n    case North, South\n    case East\n    case West\n}\n```\n`enum`关键字把枚举的整个定义放在大括号中，`CompassPoint`是它的名称。`case`表明新的一行成员值被定义，同一行中可以定义多个成员值，用`,`隔开，这里的成员值为`North`，`South`，`East`，`West`。\n``` swift\nvar directionToHead = CompassPoint.West\ndirectionToHead = .East\n```\n变量的类型经过第一次赋值确定后，再次赋值可省略枚举类型名称，这里`directionToHead`已经被确定为`CompassPoint`的成员值，再次赋值用`.East`的形式就可以了。\n定义的枚举成员是没有值的，不会自动分配值。后面会介绍存储原始值，不仅可以存储整数，也可以存储浮点数字符串等其他类型。\n\n## 成员值\n枚举类型用`switch`匹配时，必须每个成员值都考虑到，否则编译无法通过，可用`default`替代其他成员值。\n``` swift\ndirectionToHead = .South\nswitch directionToHead {\ncase .North:\n    println(\"Lots of planets have a north\")\ncase .South:\n    println(\"Watch out for penguins\")\ncase .East:\n    println(\"Where the sun rises\")\ncase .West:\n    println(\"Where the skies are blue\")\n}\n// 输出 \"Watch out for penguins”\n```\n\n## 相关值\n枚举类型的用法比较像C语言中的联合体（_union_），可以为成员值提供其他类型的相关值，即成员值之外的自定义信息。\n相关值可以是任何类型，每个成员的数据类型也可以不一样。\n``` swift\nenum Barcode {\n  case UPCA(Int, Int, Int)\n  case QRCode(String)\n}\n```\n枚举类型`Barcode`有两个成员值，一个是`UPCA`，它的相关值是`(Int, Int, int)`，一个是`QRCode`，它的相关值是`(String)`\n``` swift\nvar productBarcode = Barcode.UPCA(8, 85909_51226, 3)\nproductBarcode = .QRCode(\"ABCDEFGHIJKLMNOP\")\n```\n\n# 类和结构体\n\n类（_Class_）和结构体（_Struct_）的用法和其他语言类似。\n主要区别在于，类允许继承，而结构体不行；类是引用传递，而结构体是值传递。\n\n``` swift\nstruct Resolution {\n    var width = 0\n    var height = 0\n}\nclass VideoMode {\n    var resolution = Resolution()\n    var interlaced = false\n    var frameRate = 0.0\n    var name: String?\n}\n\nvar someResolution = Resolution(width: 1920, height: 1080)\nlet someVideoMode = VideoMode()\nsomeVideoMode.resolution = someResolution;\nsomeVideoMode.interlaced = true;\nsomeVideoMode.name = \"1080i\"\nsomeVideoMode.frameRate = 25.0\n\nvar otherResolution = someResolution;\nlet otherVideoMode = someVideoMode;\n\nsomeResolution.width = 2048\nprintln(\"someResolution is now  \\(someResolution.width) pixels wide\")\n// 输出 \"someResolution is now 2048 pixels wide\"\nprintln(\"otherResolution is now  \\(otherResolution.width) pixels wide\")\n// 输出 \"otherResolution is now 1920 pixels wide\"\n\nsomeVideoMode.resolution.width = 1280\nprintln(\"The width of someVideoMode is now \\(someVideoMode.resolution.width)\")\n// 输出 \"The width of someVideoMode is now 1280\"\nprintln(\"The width of otherVideoMode is now \\(otherVideoMode.resolution.width)\")\n// 输出 \"The width of otherVideoMode is now 1280\"\n\nif someVideoMode === otherVideoMode {\n    println(\"someVideoMode and otherVideoMode refer to the same VideoMode instance.\")\n}\n//输出 \"someVideoMode and otherVideoMode refer to the same VideoMode instance.\"\n```\n第1-10行是类和结构体的定义，分别用`class`和`struct`表示。\n\n第12-17行是给类和结构体创建实例，并赋值。\n结构体可以在构造时逐一初始化成员，`(width: 1920, height: 1080)`，而类不可以。\n\n第19-20行，分别用类和结构体的实例去赋值变量或常量。\n\n第22-26行，变量`otherResolution`被结构体`someResolution`赋值时采用的是值传递，因此相互是独立的，只是成员值一样。\n改变了`someResolutin`的属性`width`的值后，`otherResolution`并未受到影响。\n\n第28-32行，常量`otherVideoMode`被类`otherVideoMode`赋值时采用的是引用传递，指向的是同一个对象。\n改变了`someVideoMode`的属性`reoulution.width`的值后，`otherVideoMode`的相应属性也随之变化。\n`someVideoMode`和`otherVideoMode`被声明为常量,也可以改变其中的成员属性：\n因为他们都不存储实例，只存储了引用对象，没有改变引用对象，只改变了被引用的基础`VideoMode`的成员属性。\nSwift中，几乎所有的基本类型，包括字符串，数组和字典等都是值传递。\n\n第34-37行，因为两者指向同一对象，不仅仅是成员值相等的关系了，`==`等于符号并不足以描述这样的关系。\n`====`恒等运算符用来形容两者指向同一对象，表示两个实例等价。\n\n枚举，类和结构体的其他特性，参见：\n[Swift基础入门(7)：属性，方法和下标](http://aidaizyy.github.io/swift_7)\n[Swift基础入门(8)：继承，构造，析构和嵌套类型](http://aidaizyy.github.io/swift_8)\n","source":"_posts/swift_6.md","raw":"title: \"Swift基础入门(6)：枚举，类和结构体\"\ndate: 2015-07-19 22:47:43\ntags:\n- swift\ncategories: swift \ntoc: true\n---\n\n本篇介绍Swift的基础知识：枚举，类和结构体的基本概念和语法。\n\n<!--more-->\n**Title: [Swift基础入门(6)：枚举，类和结构体](https://aidaizyy.github.io/swift_6)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-24](http://aidaizyy.github.io)**\n\n# 枚举\n\n## 枚举语法\n枚举定义了一个通用来兴的一组相关的值。\n``` swift\nenum CompassPoint {\n    case North, South\n    case East\n    case West\n}\n```\n`enum`关键字把枚举的整个定义放在大括号中，`CompassPoint`是它的名称。`case`表明新的一行成员值被定义，同一行中可以定义多个成员值，用`,`隔开，这里的成员值为`North`，`South`，`East`，`West`。\n``` swift\nvar directionToHead = CompassPoint.West\ndirectionToHead = .East\n```\n变量的类型经过第一次赋值确定后，再次赋值可省略枚举类型名称，这里`directionToHead`已经被确定为`CompassPoint`的成员值，再次赋值用`.East`的形式就可以了。\n定义的枚举成员是没有值的，不会自动分配值。后面会介绍存储原始值，不仅可以存储整数，也可以存储浮点数字符串等其他类型。\n\n## 成员值\n枚举类型用`switch`匹配时，必须每个成员值都考虑到，否则编译无法通过，可用`default`替代其他成员值。\n``` swift\ndirectionToHead = .South\nswitch directionToHead {\ncase .North:\n    println(\"Lots of planets have a north\")\ncase .South:\n    println(\"Watch out for penguins\")\ncase .East:\n    println(\"Where the sun rises\")\ncase .West:\n    println(\"Where the skies are blue\")\n}\n// 输出 \"Watch out for penguins”\n```\n\n## 相关值\n枚举类型的用法比较像C语言中的联合体（_union_），可以为成员值提供其他类型的相关值，即成员值之外的自定义信息。\n相关值可以是任何类型，每个成员的数据类型也可以不一样。\n``` swift\nenum Barcode {\n  case UPCA(Int, Int, Int)\n  case QRCode(String)\n}\n```\n枚举类型`Barcode`有两个成员值，一个是`UPCA`，它的相关值是`(Int, Int, int)`，一个是`QRCode`，它的相关值是`(String)`\n``` swift\nvar productBarcode = Barcode.UPCA(8, 85909_51226, 3)\nproductBarcode = .QRCode(\"ABCDEFGHIJKLMNOP\")\n```\n\n# 类和结构体\n\n类（_Class_）和结构体（_Struct_）的用法和其他语言类似。\n主要区别在于，类允许继承，而结构体不行；类是引用传递，而结构体是值传递。\n\n``` swift\nstruct Resolution {\n    var width = 0\n    var height = 0\n}\nclass VideoMode {\n    var resolution = Resolution()\n    var interlaced = false\n    var frameRate = 0.0\n    var name: String?\n}\n\nvar someResolution = Resolution(width: 1920, height: 1080)\nlet someVideoMode = VideoMode()\nsomeVideoMode.resolution = someResolution;\nsomeVideoMode.interlaced = true;\nsomeVideoMode.name = \"1080i\"\nsomeVideoMode.frameRate = 25.0\n\nvar otherResolution = someResolution;\nlet otherVideoMode = someVideoMode;\n\nsomeResolution.width = 2048\nprintln(\"someResolution is now  \\(someResolution.width) pixels wide\")\n// 输出 \"someResolution is now 2048 pixels wide\"\nprintln(\"otherResolution is now  \\(otherResolution.width) pixels wide\")\n// 输出 \"otherResolution is now 1920 pixels wide\"\n\nsomeVideoMode.resolution.width = 1280\nprintln(\"The width of someVideoMode is now \\(someVideoMode.resolution.width)\")\n// 输出 \"The width of someVideoMode is now 1280\"\nprintln(\"The width of otherVideoMode is now \\(otherVideoMode.resolution.width)\")\n// 输出 \"The width of otherVideoMode is now 1280\"\n\nif someVideoMode === otherVideoMode {\n    println(\"someVideoMode and otherVideoMode refer to the same VideoMode instance.\")\n}\n//输出 \"someVideoMode and otherVideoMode refer to the same VideoMode instance.\"\n```\n第1-10行是类和结构体的定义，分别用`class`和`struct`表示。\n\n第12-17行是给类和结构体创建实例，并赋值。\n结构体可以在构造时逐一初始化成员，`(width: 1920, height: 1080)`，而类不可以。\n\n第19-20行，分别用类和结构体的实例去赋值变量或常量。\n\n第22-26行，变量`otherResolution`被结构体`someResolution`赋值时采用的是值传递，因此相互是独立的，只是成员值一样。\n改变了`someResolutin`的属性`width`的值后，`otherResolution`并未受到影响。\n\n第28-32行，常量`otherVideoMode`被类`otherVideoMode`赋值时采用的是引用传递，指向的是同一个对象。\n改变了`someVideoMode`的属性`reoulution.width`的值后，`otherVideoMode`的相应属性也随之变化。\n`someVideoMode`和`otherVideoMode`被声明为常量,也可以改变其中的成员属性：\n因为他们都不存储实例，只存储了引用对象，没有改变引用对象，只改变了被引用的基础`VideoMode`的成员属性。\nSwift中，几乎所有的基本类型，包括字符串，数组和字典等都是值传递。\n\n第34-37行，因为两者指向同一对象，不仅仅是成员值相等的关系了，`==`等于符号并不足以描述这样的关系。\n`====`恒等运算符用来形容两者指向同一对象，表示两个实例等价。\n\n枚举，类和结构体的其他特性，参见：\n[Swift基础入门(7)：属性，方法和下标](http://aidaizyy.github.io/swift_7)\n[Swift基础入门(8)：继承，构造，析构和嵌套类型](http://aidaizyy.github.io/swift_8)\n","slug":"swift_6","published":1,"updated":"2015-07-24T09:02:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qrl000emeo3gg22v2q8"},{"title":"Swift基础入门(5)：函数和闭包","date":"2015-07-16T09:11:53.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：函数和闭包（Closure）。\n\n<!--more-->\n**Title: [Swift基础入门(5)：函数和闭包](https://aidaizyy.github.io/swift_5)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-22](http://aidaizyy.github.io)**\n\n# 函数\n## 函数原型\n`func functionName(parameters) -> returnType { statements }`\n``` swift\nfunc halfOpenRangeLength(start: Int, end: Int) -> Int {\n    return end - start\n}\nprintln(halfOpenRangeLength(1, 10))\n// prints \"9\"\n```\n函数前必须加标识符`func`，函数名`halfOpenRangeLength`需要传入两个参数`start`和`end`，都是`Int`类型，返回`Int`类型。\n可以没有参数，也可以没有返回值，则写作`func halfOpenRangeLength() { statements }`，`statements`中不带`return`语句。\n\n函数可以有多个返回值，用元组表示返回值。\n``` swift\nfunc count(string: String) -> (vowels: Int, consonants: Int, others: Int) {\n    var vowels = 0, consonants = 0, others = 0\n    for character in string {\n        switch String(character).lowercaseString {\n        case \"a\", \"e\", \"i\", \"o\", \"u\":\n            ++vowels\n        case \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\",\n          \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\":\n            ++consonants\n        default:\n            ++others\n        }\n    }\n    return (vowels, consonants, others)\n}\n\nlet total = count(\"some arbitrary string!\")\nprintln(\"\\(total.vowels) vowels and \\(total.consonants) consonants\")\n// prints \"6 vowels and 13 consonants\"\n```\n`func count(String) -> (Int, Int, Int)`函数，传入一个`String`值，返回一个带3个`Int`值的元组。\n返回的元组成员不需要再命名，因为在函数定义时已经命名了返回元组成员的名称。\n当然也可以不命名，返回类型写作`(Int, Int, Int)`的形式，用`total.0`，`total.1`和`total.2`去获取元组`total`的第1个，第2个和第3个成员的值。\n\n## 函数参数\n\n### 外部参数名\n函数参数的名称作为局部参数名，只能在函数中使用。定义外部参数名，可以在函数外部使用帮助函数参数的意图清晰，`func functionName(externalParameterName localParameterName: dataType) { statements }`。\n注意：但是一旦定义了外部参数名，在函数调用时就**必须使用**。\n外部参数名和局部参数名如果一致，可在局部参数名前加`#`表示，`func functionName(#parameterName: dataType) { statements }`。\n``` swift\nfunc containsCharacter(str string: String, #characterToFind: Character) -> Bool {\n    for character in string {\n        if character == characterToFind {\n            return true\n        }\n    }\n    return false\n}\nlet containsAVee = containsCharacter(str: \"aardvark\", characterToFind: \"v\")\n// containsAVee equals true, because \"aardvark\" contains a \"v”\n```\n\n### 默认参数值\n函数参数可以定义默认值，但必须在函数参数列表的最后。调用时，如果不指定参数的值，则使用默认值。\n定义了默认值的函数参数会自动提供外部参数名，和局部参数名一样，也可以自己提供，如果不使用默认值，则必须在调用时使用外部参数名。\n``` swift\nfunc join(s1: String, s2: String, joiner: String = \" \", flag: String = \"!\") -> String {\n    return s1 + joiner + s2 + flag\n}\n\njoin(\"hello\", \"world\", joiner: \"-\")\n// returns \"hello-world!\"\n```\n第3个参数`joiner`和第四个参数`flag`都是提供了默认参数值，自动提供了外部参数名`joiner`和`flag`，与局部参数名一致。\n`joiner`提供了值，则必须使用参数名`joiner: \"-\"`。\n`flag`使用默认值，则不需要在调用时出现。\n\n### 可变参数\n可变参数（_variadic parameter_）表示不确定数量的输入参数，在参数后加`...`表示。一个函数最多只能有一个可变参数， 且必须是参数列表的最后一个参数。\n``` swift\nfunc arithmeticMean(numbers: Double...) -> Double {\n    var total: Double = 0\n    for number in numbers {\n        total += number\n    }\n    return total / Double(numbers.count)\n}\narithmeticMean(1, 2, 3, 4, 5)\n// returns 3.0, which is the arithmetic mean of these five numbers\narithmeticMean(3, 8, 19)\n// returns 10.0, which is the arithmetic mean of these three numbers\n```\n\n### 变量参数\nSwift的函数参数采用值拷贝传递，传递进去的参数是不能进行修改的，如果我们需要，可以定义变量参数。在参数前加`var`定义变量参数。\n``` swift\nfunc appendCharacter(var string: String, flag: Character) -> String {\n    string.append(flag)\n    return string\n}\nlet originalString = \"hello\"\nlet paddedString = appendCharacter(originalString, \"!\")\n// paddedString is equal to \"hello!\"\n```\n`string`在函数内被修改了，但是作为局部变量，只能在函数内部使用。\n\n### 输入输出参数\nSwift的函数参数不能被修改，使用变量参数修改后也不能传递到外部，采用输入输出参数可以解决这个问题。\n在参数前加`inout`定义输入输出参数。\n- 函数调用时，输入输出参数只能传入变量\n- 输入输出参数不能有默认参数值。\n- 输入输出参数不能是可变参数。\n``` swift\nfunc appendCharacter(inout string: String, flag: Character) {\n    string.append(flag)\n}\nvar originalString = \"hello\"\nappendCharacter(&originalString, \"!\")\n// originalString is equal to \"hello!\"\n```\n`appendCharacter`函数传入参数时，在输入输出参数前必须加`&`前缀。\n\n## 函数类型\n\n函数类型和其他类型一样，可以定义并赋值，如：\n``` swift\nfunc addTwoInts(a: Int, b: Int) -> Int {\n    return a + b\n}\n\nvar mathFunciton1: (Int, Int) -> Int =addTwoInts\n\nvar mathFunciton2 = addTwoInts\t\t//通过赋值自动判断mathFunction类型为函数类型\n\nprintln(\"Result: \\(mathFunction1(2, 3))\")\n// prints \"Result: 5\"\nprintln(\"Result: \\(mathFunction2(2, 3))\")\n// prints \"Result: 5\"\n```\n\n同样函数类型可以作为函数的参数类型和返回类型，形式如`func printMathResult(mathFunction: (Int, Int) -> Int, a: Int, b: Int)`和`func chooseStepFunction(backwards: Bool) -> (Int) -> Int`。前者的一个参数为`mathFunction: (Int, Int) -> Int`，后者的返回`(Int) -> Int`，都没有`func`关键字。\n\n函数也支持嵌套函数，在函数A内部定义的函数B只能在函数A内调用。\n\n# 闭包\n\n## 闭包表达式\n闭包指自包含的函数代码块，可以在代码中被传递和使用。\n函数就是特殊的闭包。\n闭包的一般形式：`{ (parameters) -> returnType in statements }\n和函数不同的是，用`in`替代了原本函数的大括号，并在最外层加上大括号。\n``` swift\nfunc backwards(s1: String, s2: String) -> Bool {\n    return s1 > s2\n}\nvar reversed = sorted(names, backwards)\n// reversed 为 [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"]\n```\n`sorted`函数需要两个参数，第一个参数是需要排序的数组，第二个参数是确定排序顺序的闭包函数，传入与数组类型相同的两个值，并返回`Bool`值。如果第二个参数返回`true`则两个数组元素顺序不变；如果第二个参数返回`false`则两个数组元素顺序相反。\n所以闭包函数中定义`return s1 > s2`，如果`s1`大于`s2`顺序不变，如果`s1`不大于`s2`则交换`s1`和`s2`的顺序，使值大的元素排在数组的前列，也就是逆序排列。\n就上面的代码改为闭包表达式的形式为：\n``` swift\nreversed = sorted(names, { (s1: String, s2: String) -> Bool in\n    return s1 > s2\n})\n```\n用闭包表达式代替了闭包函数，`in`替换函数的大括号，并在外层添加大括号。\n\n闭包表达式的参数类型由第一个参数数组元素的类型决定，返回类型确定为`Bool`型，创建闭包时可以省略已知的信息：\n``` swift\nreversed = sorted(names, { s1, s2 in return s1 > s2 })\n```\n闭包表达式中，如果只有单行表达式，比如`return s1 > s2`一行，可以省略`return`关键字：\n``` swift\nreversed = sorted(names, { s1, s2 in s1 > s2 })\n```\n闭包表达式的参数名称可以缩写成$0，$1，$2等，来顺序调用闭包参数：\n``` swift\nreversed = sorted(names, { $0 > $1 })\n```\n另外，还可以用运算符函数（operator function）使闭包表达式更简短。因为`>`的定义就是接收两个参数，并返回`Bool`类型值，所以可以写：\n``` swift\nreversed = sorted(names, >)\n```\n尾随闭包（trailing closure）：如果闭包表达是是函数的最后一个参数，可以把闭包放到函数的小括号后面，增强可读性：\n``` swift\nreversed = sorted(names, { $0 > $1 })\t//闭包表达式\n\nreversed = sorted(names) { $0 > $1 }\t//尾随闭包\n```\n如果闭包很长，尾随闭包就会非常有用。\n如果函数中只有闭包一个参数，则可以省略小括号，写成`reversed = sorted { $0 < $1 }`的形式。\n\n## 嵌套函数\n嵌套函数是最简单的闭包形式。嵌套函数可以捕获外部函数的参数和定义的常量变量。\n``` swift\nfunc makeIncrementor(forIncrement amount: Int) -> () -> Int {\n    var runningTotal = 0\n    func incrementor() -> Int {\n        runningTotal += amount\n        return runningTotal\n    }\n    return incrementor\n}\n```\n`incrementor`函数调用的`amount`是外部函数的参数，捕获并存储了副本；`runningTotal`会被修改，所以不可以是副本，而是捕获了一个引用，就算外部函数结束都不会消失。Swift会自动决定捕获引用还是副本。\n``` swift\nlet incrementByTen = makeIncrementor(forIncrement: 10)\n\nincrementByTen()\n// 返回的值为10\nincrementByTen()\n// 返回的值为20\nincrementByTen()\n// 返回的值为30\n\nlet incrementBySeven = makeIncrementor(forIncrement: 7)\nincrementBySeven()\n// 返回的值为7\nincrementByTen()\n// 返回的值为40\n```\n`incrementByTen`创建时，`runningTotal`也创建了，每调用一次函数其值就会增加10。\n`incremetnBySeven`创建时，一个新的`runningTotal`也创建了，每调用一次函数其值就会增加7。这个变量和`incrementByTen`中的变量没有任何关系，互不干扰。\n\n注意：无论是函数还是闭包，在赋值给常量或变量时都是**引用拷贝**，指向的是同一个函数/闭包对象。\n","source":"_posts/swift_5.md","raw":"title: \"Swift基础入门(5)：函数和闭包\"\ndate: 2015-07-16 17:11:53\ntags:\n- swift\ncategories: swift\ntoc: true\n---\n\n本篇介绍Swift的基础知识：函数和闭包（Closure）。\n\n<!--more-->\n**Title: [Swift基础入门(5)：函数和闭包](https://aidaizyy.github.io/swift_5)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-22](http://aidaizyy.github.io)**\n\n# 函数\n## 函数原型\n`func functionName(parameters) -> returnType { statements }`\n``` swift\nfunc halfOpenRangeLength(start: Int, end: Int) -> Int {\n    return end - start\n}\nprintln(halfOpenRangeLength(1, 10))\n// prints \"9\"\n```\n函数前必须加标识符`func`，函数名`halfOpenRangeLength`需要传入两个参数`start`和`end`，都是`Int`类型，返回`Int`类型。\n可以没有参数，也可以没有返回值，则写作`func halfOpenRangeLength() { statements }`，`statements`中不带`return`语句。\n\n函数可以有多个返回值，用元组表示返回值。\n``` swift\nfunc count(string: String) -> (vowels: Int, consonants: Int, others: Int) {\n    var vowels = 0, consonants = 0, others = 0\n    for character in string {\n        switch String(character).lowercaseString {\n        case \"a\", \"e\", \"i\", \"o\", \"u\":\n            ++vowels\n        case \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\",\n          \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\":\n            ++consonants\n        default:\n            ++others\n        }\n    }\n    return (vowels, consonants, others)\n}\n\nlet total = count(\"some arbitrary string!\")\nprintln(\"\\(total.vowels) vowels and \\(total.consonants) consonants\")\n// prints \"6 vowels and 13 consonants\"\n```\n`func count(String) -> (Int, Int, Int)`函数，传入一个`String`值，返回一个带3个`Int`值的元组。\n返回的元组成员不需要再命名，因为在函数定义时已经命名了返回元组成员的名称。\n当然也可以不命名，返回类型写作`(Int, Int, Int)`的形式，用`total.0`，`total.1`和`total.2`去获取元组`total`的第1个，第2个和第3个成员的值。\n\n## 函数参数\n\n### 外部参数名\n函数参数的名称作为局部参数名，只能在函数中使用。定义外部参数名，可以在函数外部使用帮助函数参数的意图清晰，`func functionName(externalParameterName localParameterName: dataType) { statements }`。\n注意：但是一旦定义了外部参数名，在函数调用时就**必须使用**。\n外部参数名和局部参数名如果一致，可在局部参数名前加`#`表示，`func functionName(#parameterName: dataType) { statements }`。\n``` swift\nfunc containsCharacter(str string: String, #characterToFind: Character) -> Bool {\n    for character in string {\n        if character == characterToFind {\n            return true\n        }\n    }\n    return false\n}\nlet containsAVee = containsCharacter(str: \"aardvark\", characterToFind: \"v\")\n// containsAVee equals true, because \"aardvark\" contains a \"v”\n```\n\n### 默认参数值\n函数参数可以定义默认值，但必须在函数参数列表的最后。调用时，如果不指定参数的值，则使用默认值。\n定义了默认值的函数参数会自动提供外部参数名，和局部参数名一样，也可以自己提供，如果不使用默认值，则必须在调用时使用外部参数名。\n``` swift\nfunc join(s1: String, s2: String, joiner: String = \" \", flag: String = \"!\") -> String {\n    return s1 + joiner + s2 + flag\n}\n\njoin(\"hello\", \"world\", joiner: \"-\")\n// returns \"hello-world!\"\n```\n第3个参数`joiner`和第四个参数`flag`都是提供了默认参数值，自动提供了外部参数名`joiner`和`flag`，与局部参数名一致。\n`joiner`提供了值，则必须使用参数名`joiner: \"-\"`。\n`flag`使用默认值，则不需要在调用时出现。\n\n### 可变参数\n可变参数（_variadic parameter_）表示不确定数量的输入参数，在参数后加`...`表示。一个函数最多只能有一个可变参数， 且必须是参数列表的最后一个参数。\n``` swift\nfunc arithmeticMean(numbers: Double...) -> Double {\n    var total: Double = 0\n    for number in numbers {\n        total += number\n    }\n    return total / Double(numbers.count)\n}\narithmeticMean(1, 2, 3, 4, 5)\n// returns 3.0, which is the arithmetic mean of these five numbers\narithmeticMean(3, 8, 19)\n// returns 10.0, which is the arithmetic mean of these three numbers\n```\n\n### 变量参数\nSwift的函数参数采用值拷贝传递，传递进去的参数是不能进行修改的，如果我们需要，可以定义变量参数。在参数前加`var`定义变量参数。\n``` swift\nfunc appendCharacter(var string: String, flag: Character) -> String {\n    string.append(flag)\n    return string\n}\nlet originalString = \"hello\"\nlet paddedString = appendCharacter(originalString, \"!\")\n// paddedString is equal to \"hello!\"\n```\n`string`在函数内被修改了，但是作为局部变量，只能在函数内部使用。\n\n### 输入输出参数\nSwift的函数参数不能被修改，使用变量参数修改后也不能传递到外部，采用输入输出参数可以解决这个问题。\n在参数前加`inout`定义输入输出参数。\n- 函数调用时，输入输出参数只能传入变量\n- 输入输出参数不能有默认参数值。\n- 输入输出参数不能是可变参数。\n``` swift\nfunc appendCharacter(inout string: String, flag: Character) {\n    string.append(flag)\n}\nvar originalString = \"hello\"\nappendCharacter(&originalString, \"!\")\n// originalString is equal to \"hello!\"\n```\n`appendCharacter`函数传入参数时，在输入输出参数前必须加`&`前缀。\n\n## 函数类型\n\n函数类型和其他类型一样，可以定义并赋值，如：\n``` swift\nfunc addTwoInts(a: Int, b: Int) -> Int {\n    return a + b\n}\n\nvar mathFunciton1: (Int, Int) -> Int =addTwoInts\n\nvar mathFunciton2 = addTwoInts\t\t//通过赋值自动判断mathFunction类型为函数类型\n\nprintln(\"Result: \\(mathFunction1(2, 3))\")\n// prints \"Result: 5\"\nprintln(\"Result: \\(mathFunction2(2, 3))\")\n// prints \"Result: 5\"\n```\n\n同样函数类型可以作为函数的参数类型和返回类型，形式如`func printMathResult(mathFunction: (Int, Int) -> Int, a: Int, b: Int)`和`func chooseStepFunction(backwards: Bool) -> (Int) -> Int`。前者的一个参数为`mathFunction: (Int, Int) -> Int`，后者的返回`(Int) -> Int`，都没有`func`关键字。\n\n函数也支持嵌套函数，在函数A内部定义的函数B只能在函数A内调用。\n\n# 闭包\n\n## 闭包表达式\n闭包指自包含的函数代码块，可以在代码中被传递和使用。\n函数就是特殊的闭包。\n闭包的一般形式：`{ (parameters) -> returnType in statements }\n和函数不同的是，用`in`替代了原本函数的大括号，并在最外层加上大括号。\n``` swift\nfunc backwards(s1: String, s2: String) -> Bool {\n    return s1 > s2\n}\nvar reversed = sorted(names, backwards)\n// reversed 为 [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"]\n```\n`sorted`函数需要两个参数，第一个参数是需要排序的数组，第二个参数是确定排序顺序的闭包函数，传入与数组类型相同的两个值，并返回`Bool`值。如果第二个参数返回`true`则两个数组元素顺序不变；如果第二个参数返回`false`则两个数组元素顺序相反。\n所以闭包函数中定义`return s1 > s2`，如果`s1`大于`s2`顺序不变，如果`s1`不大于`s2`则交换`s1`和`s2`的顺序，使值大的元素排在数组的前列，也就是逆序排列。\n就上面的代码改为闭包表达式的形式为：\n``` swift\nreversed = sorted(names, { (s1: String, s2: String) -> Bool in\n    return s1 > s2\n})\n```\n用闭包表达式代替了闭包函数，`in`替换函数的大括号，并在外层添加大括号。\n\n闭包表达式的参数类型由第一个参数数组元素的类型决定，返回类型确定为`Bool`型，创建闭包时可以省略已知的信息：\n``` swift\nreversed = sorted(names, { s1, s2 in return s1 > s2 })\n```\n闭包表达式中，如果只有单行表达式，比如`return s1 > s2`一行，可以省略`return`关键字：\n``` swift\nreversed = sorted(names, { s1, s2 in s1 > s2 })\n```\n闭包表达式的参数名称可以缩写成$0，$1，$2等，来顺序调用闭包参数：\n``` swift\nreversed = sorted(names, { $0 > $1 })\n```\n另外，还可以用运算符函数（operator function）使闭包表达式更简短。因为`>`的定义就是接收两个参数，并返回`Bool`类型值，所以可以写：\n``` swift\nreversed = sorted(names, >)\n```\n尾随闭包（trailing closure）：如果闭包表达是是函数的最后一个参数，可以把闭包放到函数的小括号后面，增强可读性：\n``` swift\nreversed = sorted(names, { $0 > $1 })\t//闭包表达式\n\nreversed = sorted(names) { $0 > $1 }\t//尾随闭包\n```\n如果闭包很长，尾随闭包就会非常有用。\n如果函数中只有闭包一个参数，则可以省略小括号，写成`reversed = sorted { $0 < $1 }`的形式。\n\n## 嵌套函数\n嵌套函数是最简单的闭包形式。嵌套函数可以捕获外部函数的参数和定义的常量变量。\n``` swift\nfunc makeIncrementor(forIncrement amount: Int) -> () -> Int {\n    var runningTotal = 0\n    func incrementor() -> Int {\n        runningTotal += amount\n        return runningTotal\n    }\n    return incrementor\n}\n```\n`incrementor`函数调用的`amount`是外部函数的参数，捕获并存储了副本；`runningTotal`会被修改，所以不可以是副本，而是捕获了一个引用，就算外部函数结束都不会消失。Swift会自动决定捕获引用还是副本。\n``` swift\nlet incrementByTen = makeIncrementor(forIncrement: 10)\n\nincrementByTen()\n// 返回的值为10\nincrementByTen()\n// 返回的值为20\nincrementByTen()\n// 返回的值为30\n\nlet incrementBySeven = makeIncrementor(forIncrement: 7)\nincrementBySeven()\n// 返回的值为7\nincrementByTen()\n// 返回的值为40\n```\n`incrementByTen`创建时，`runningTotal`也创建了，每调用一次函数其值就会增加10。\n`incremetnBySeven`创建时，一个新的`runningTotal`也创建了，每调用一次函数其值就会增加7。这个变量和`incrementByTen`中的变量没有任何关系，互不干扰。\n\n注意：无论是函数还是闭包，在赋值给常量或变量时都是**引用拷贝**，指向的是同一个函数/闭包对象。\n","slug":"swift_5","published":1,"updated":"2015-07-22T15:15:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qrn000hmeo3z3mddj1w"},{"title":"Swift基础入门(4)：条件与循环语句","date":"2015-07-16T06:36:11.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：条件语句和循环语句。\n\n<!--more-->\n**Title: [Swift基础入门(4)：条件与循环语句](https://aidaizyy.github.io/swift_4)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-16](http://aidaizyy.github.io)**\n\n# 循环语句\n\n## for-in循环\n``` swift\nfor index in 1...5 {\n\tprintln(index)\n}\n//1\n//2\n//3\n//4\n//5\n```\n`for-in`循环可用于区间。\n``` swift\nvar res = 1\nfor _ in 1...5 {\n\tres *= 2\n\tprintln(res)\n}\n//2\n//4\n//8\n//16\n//32\n```\n如果不需要区间中每项的值，可以用`_`替代。\n`for-in`用于字符串，请见[Swift基础入门(2)](http://aidaizyy.github.io/swift_2)。\n`for-in`用于数组集合字典，请见[Swift基础入门(3)](http://aidaizyy.github.io/swift_3)。\n\n## for循环\n`for`循环和C语言一致，格式为`for initialization; condition; increment { statements }`，区别在于没有括号。\n\n## while循环\n`while`循环和C语言一致，格式为`while condition { statements }`，区别在于没有括号。\n\n## do-while循环\n`do-while`循环和C语言一致，格式为`do { statements } while condition`，区别在于没有括号。\n\n# 条件语句\n\n## if语句\n`if`语句和C语言一直，格式为`if condition { statements } else if condition { statements } else { statesments },区别在于没有括号，`else if`和`else`不是必须存在。\n\n## switch语句\n``` swift\nlet count = 300\nvar naturalCount: String\nswitch count {\ncase 0:\n    naturalCount = \"no\"\ncase 1...3:\n    naturalCount = \"a few\"\ncase 4...9:\n    naturalCount = \"several\"\ncase 10...99:\n    naturalCount = \"tens of\"\ncase 100...999:\n    naturalCount = \"hundreds of\"\ncase 1000...999_999:\n    naturalCount = \"thousands of\"\ndefault:\n    naturalCount = \"millions and millions of\"\n}\nprintln(\"There are \\(naturalCount) stars in the Milky Way.\")\n// 输出 \"There are hundreds of stars in the Milk Way.\"\n```\n在C语言中，通常使用`break`，避免执行了一个`case`语句后继续执行下一个`case`语句。在Swift语言中不需要添加`break`，`switch`语句只执行最前面一个符合条件的`case`语句。\n`case`语句可以接类似于`1...3`的区间。\n`case`语句可以接多个情况，用逗号隔开，`switch value { case value1, value2: statements }`\n\n## 元组\n``` swift\nlet somePoint = (1, 1)\nswitch somePoint {\ncase (0, 0):\n    println(\"(0, 0) is at the origin\")\ncase (_, 0):\n    println(\"(\\(somePoint.0), 0) is on the x-axis\")\ncase (0, _):\n    println(\"(0, \\(somePoint.1)) is on the y-axis\")\ncase (-2...2, -2...2):\n    println(\"(\\(somePoint.0), \\(somePoint.1)) is inside the box\")\ndefault:\n    println(\"(\\(somePoint.0), \\(somePoint.1)) is outside of the box\")\n}\n// 输出 \"(1, 1) is inside the box\"\n``` \n元组也可以用来判断条件，`_`用来匹配所有可能的值，也就是需要忽略的值。\n\n## 值绑定\n``` swift\nlet anotherPoint = (2, 0)\nswitch anotherPoint {\ncase (let x, 0):\n    println(\"on the x-axis with an x value of \\(x)\")\ncase (0, let y):\n    println(\"on the y-axis with a y value of \\(y)\")\ncase let (x, y):\n    println(\"somewhere else at (\\(x), \\(y))\")\n}\n```\n`case`语句中，可以用临时的常量变量去绑定值并使用。\n\n## 额外条件（Where语句）\n``` swift\nlet yetAnotherPoint = (1, -1)\nswitch yetAnotherPoint {\ncase let (x, y) where x == y:\n    println(\"(\\(x), \\(y)) is on the line x == y\")\ncase let (x, y) where x == -y:\n    println(\"(\\(x), \\(y)) is on the line x == -y\")\ncase let (x, y):\n    println(\"(\\(x), \\(y)) is just some arbitrary point\")\n}\n// 输出 \"(1, -1) is on the line x == -y\"\n```\n`case`语句中可以使用`where`语句跟在条件后作为额外的补充条件，需要同时满足两个条件才可以执行。\n\n# 控制转移语句\nSwift一共有四种控制转移语句：\n-continue\n-break\n-fallthrough\n-return\n\n`continue`，`break`和`return`用法和C语言基本一致。\n在`switch`语句中，`continue`和`break`都针对整个`switch`语句，而不是C语言中的一个`case`语句。遇到`break`后直接退出整个`switch`语句，而不是判断下一个`case`，`continue`同理。\n\n## 贯穿语句（Fallthrough语句）\n``` swift\nlet integerToDescribe = 5\nvar description = \"The number \\(integerToDescribe) is\"\nswitch integerToDescribe {\ncase 2, 3, 5, 7, 11, 13, 17, 19:\n    description += \" a prime number, and also\"\n    fallthrough\ndefault:\n    description += \" an integer.\"\n}\nprintln(description)\n// 输出 \"The number 5 is a prime number, and also an integer.\"\n```\nSwift语言不支持在`switch`语句中贯穿多个`case`语句的情况，但有时我们需要这么做。这时我们可以加上关键字`fallthrough`，当遇到`fallthrough`时，就会继续执行下一个`case`语句。\n注意：遇到`fallthrough`时会直接**执行**下一个`case`语句，而不是去**判断**条件。\n\n## 精确控制转移\nSwift语言中可以让`break`和`continue`精确地表示针对哪一个循环或条件语句，这称为带标签的语句（_Labeled Statements_）。\n`label name: while condition { statements }`，之后再执行`break label name`或`continue label name`。 \n``` swift\n//求第一个质数\nloop: for integer in 1...10 {\n    switch integer {\n    case 2, 3, 5, 7, 11, 13, 17, 19:\n        println(\"\\(integer) is a prime number\")\n        break loop\n    default:\n        println(\"\\(integer) is not a prime number\")\n    }\n}\n```\n上面代码中，给`for-in`循环指定了标签`loop`，我们要求得到第一个质数，所以当遇到质数后用`break loop`结束循环。如果不加标签，`break`只能结束`switch`语句，会继续执行循环，不能达到目的。\n","source":"_posts/swift_4.md","raw":"title: \"Swift基础入门(4)：条件与循环语句\"\ndate: 2015-07-16 14:36:11\ntags:\n- swift\ncategories: swift \ntoc: true\n---\n\n本篇介绍Swift的基础知识：条件语句和循环语句。\n\n<!--more-->\n**Title: [Swift基础入门(4)：条件与循环语句](https://aidaizyy.github.io/swift_4)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-16](http://aidaizyy.github.io)**\n\n# 循环语句\n\n## for-in循环\n``` swift\nfor index in 1...5 {\n\tprintln(index)\n}\n//1\n//2\n//3\n//4\n//5\n```\n`for-in`循环可用于区间。\n``` swift\nvar res = 1\nfor _ in 1...5 {\n\tres *= 2\n\tprintln(res)\n}\n//2\n//4\n//8\n//16\n//32\n```\n如果不需要区间中每项的值，可以用`_`替代。\n`for-in`用于字符串，请见[Swift基础入门(2)](http://aidaizyy.github.io/swift_2)。\n`for-in`用于数组集合字典，请见[Swift基础入门(3)](http://aidaizyy.github.io/swift_3)。\n\n## for循环\n`for`循环和C语言一致，格式为`for initialization; condition; increment { statements }`，区别在于没有括号。\n\n## while循环\n`while`循环和C语言一致，格式为`while condition { statements }`，区别在于没有括号。\n\n## do-while循环\n`do-while`循环和C语言一致，格式为`do { statements } while condition`，区别在于没有括号。\n\n# 条件语句\n\n## if语句\n`if`语句和C语言一直，格式为`if condition { statements } else if condition { statements } else { statesments },区别在于没有括号，`else if`和`else`不是必须存在。\n\n## switch语句\n``` swift\nlet count = 300\nvar naturalCount: String\nswitch count {\ncase 0:\n    naturalCount = \"no\"\ncase 1...3:\n    naturalCount = \"a few\"\ncase 4...9:\n    naturalCount = \"several\"\ncase 10...99:\n    naturalCount = \"tens of\"\ncase 100...999:\n    naturalCount = \"hundreds of\"\ncase 1000...999_999:\n    naturalCount = \"thousands of\"\ndefault:\n    naturalCount = \"millions and millions of\"\n}\nprintln(\"There are \\(naturalCount) stars in the Milky Way.\")\n// 输出 \"There are hundreds of stars in the Milk Way.\"\n```\n在C语言中，通常使用`break`，避免执行了一个`case`语句后继续执行下一个`case`语句。在Swift语言中不需要添加`break`，`switch`语句只执行最前面一个符合条件的`case`语句。\n`case`语句可以接类似于`1...3`的区间。\n`case`语句可以接多个情况，用逗号隔开，`switch value { case value1, value2: statements }`\n\n## 元组\n``` swift\nlet somePoint = (1, 1)\nswitch somePoint {\ncase (0, 0):\n    println(\"(0, 0) is at the origin\")\ncase (_, 0):\n    println(\"(\\(somePoint.0), 0) is on the x-axis\")\ncase (0, _):\n    println(\"(0, \\(somePoint.1)) is on the y-axis\")\ncase (-2...2, -2...2):\n    println(\"(\\(somePoint.0), \\(somePoint.1)) is inside the box\")\ndefault:\n    println(\"(\\(somePoint.0), \\(somePoint.1)) is outside of the box\")\n}\n// 输出 \"(1, 1) is inside the box\"\n``` \n元组也可以用来判断条件，`_`用来匹配所有可能的值，也就是需要忽略的值。\n\n## 值绑定\n``` swift\nlet anotherPoint = (2, 0)\nswitch anotherPoint {\ncase (let x, 0):\n    println(\"on the x-axis with an x value of \\(x)\")\ncase (0, let y):\n    println(\"on the y-axis with a y value of \\(y)\")\ncase let (x, y):\n    println(\"somewhere else at (\\(x), \\(y))\")\n}\n```\n`case`语句中，可以用临时的常量变量去绑定值并使用。\n\n## 额外条件（Where语句）\n``` swift\nlet yetAnotherPoint = (1, -1)\nswitch yetAnotherPoint {\ncase let (x, y) where x == y:\n    println(\"(\\(x), \\(y)) is on the line x == y\")\ncase let (x, y) where x == -y:\n    println(\"(\\(x), \\(y)) is on the line x == -y\")\ncase let (x, y):\n    println(\"(\\(x), \\(y)) is just some arbitrary point\")\n}\n// 输出 \"(1, -1) is on the line x == -y\"\n```\n`case`语句中可以使用`where`语句跟在条件后作为额外的补充条件，需要同时满足两个条件才可以执行。\n\n# 控制转移语句\nSwift一共有四种控制转移语句：\n-continue\n-break\n-fallthrough\n-return\n\n`continue`，`break`和`return`用法和C语言基本一致。\n在`switch`语句中，`continue`和`break`都针对整个`switch`语句，而不是C语言中的一个`case`语句。遇到`break`后直接退出整个`switch`语句，而不是判断下一个`case`，`continue`同理。\n\n## 贯穿语句（Fallthrough语句）\n``` swift\nlet integerToDescribe = 5\nvar description = \"The number \\(integerToDescribe) is\"\nswitch integerToDescribe {\ncase 2, 3, 5, 7, 11, 13, 17, 19:\n    description += \" a prime number, and also\"\n    fallthrough\ndefault:\n    description += \" an integer.\"\n}\nprintln(description)\n// 输出 \"The number 5 is a prime number, and also an integer.\"\n```\nSwift语言不支持在`switch`语句中贯穿多个`case`语句的情况，但有时我们需要这么做。这时我们可以加上关键字`fallthrough`，当遇到`fallthrough`时，就会继续执行下一个`case`语句。\n注意：遇到`fallthrough`时会直接**执行**下一个`case`语句，而不是去**判断**条件。\n\n## 精确控制转移\nSwift语言中可以让`break`和`continue`精确地表示针对哪一个循环或条件语句，这称为带标签的语句（_Labeled Statements_）。\n`label name: while condition { statements }`，之后再执行`break label name`或`continue label name`。 \n``` swift\n//求第一个质数\nloop: for integer in 1...10 {\n    switch integer {\n    case 2, 3, 5, 7, 11, 13, 17, 19:\n        println(\"\\(integer) is a prime number\")\n        break loop\n    default:\n        println(\"\\(integer) is not a prime number\")\n    }\n}\n```\n上面代码中，给`for-in`循环指定了标签`loop`，我们要求得到第一个质数，所以当遇到质数后用`break loop`结束循环。如果不加标签，`break`只能结束`switch`语句，会继续执行循环，不能达到目的。\n","slug":"swift_4","published":1,"updated":"2015-07-21T08:52:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qrq000kmeo30a79pyf3"},{"title":"Swift基础入门(3)：数组，集合和字典","date":"2015-07-15T09:04:30.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：数组（Array），集合（Set）和字符（Dictionary）。\n\n<!--more-->\n**Title: [Swift基础入门(3)：数组，集合和字典](https://aidaizyy.github.io/swift_3)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-16](http://aidaizyy.github.io)**\n\n# 数组\n\n## 构造\n``` swift\nvar shoppinglist = [\"Eggs\", \"Milk\"]\t//初始化为字符串数组，没有指定数据类型，通过添加数据自动判断为String数组\n\nvar someInts1 = [2, 3]\nvar someInts2: [Int] = [2, 3]\t\t//等价于上一句，初始化为整数数组，指定了数据类型Int，只能添加Int数据，并添加了元素2，3\nvar someInts3: Array<Int> = [2, 3]\t//等价于上一句\n\nvar someInts4 = Array<Int>()\t\t//初始化为整数数组，指定了数据类型Int，只能添加Int数据，没有添加元素\nvar someInts5 = [Int]()\t\t\t//等价于上一句\n\nvar someDoubles = []\t\t\t//初始化为空数组，没有指定数据类型，通过添加数据自动判断\nsomeDoubles.append(2.3)\t\t\t//通过添加数据自动判断为Double数组\n\nvar threeDoubles = [Double](count: 3, repeatedValue: 0.0)\n//(count: , repeatedValue: )形式，指定了重复的值和重复的次数，构造数组{0.0, 0.0, 0.0}\n```\n数组的元素只能有一种数据类型。\n\n## 数量\n- Array.count：属性`count`表示数组`Array`的元素个数。\n- Array.isEmpty：属性`isEmpty`表示数组`Array`的元素是否为0个，结果为`true`或`false`。\n\n## 访问\n- Array[i]：通过下标`[i]`访问数组`Array`的第`i`位，可修改。\n\n## 遍历\n``` swift\nvar shoppinglist = [\"Eggs\", \"Milk\"]\nfor item in shoppingList {\n\tprintln(item)\n}\n//Eggs\n//Milk\n```\n\n## 添加\n- Array.append(Item)：将元素`Item`添加到数组`Array`的尾部。\n- Array.imsert(Item, atIndex: i)：将元素`Item`添加到数组`Array`的第`i`位。\n- Array += [Item1, Item2]：将元素`Item1`和`Item2`添加到数组`Array`的尾部。\n\n## 删除\n- Array.removeAtIndex(i)：删除数组`Array`的第`i`位。\n- Array.removeLast()：删除数组`Array`的最后一位。\n\n## 替换\n- Array[m...n] = [Item1, Item2]：用元素`Item1`和`Item2`替换数组`Array`的第`m`位到第`n`位。这种方法不能用于添加新元素。\n\n#  集合\n集合中的元素没有确定顺序，且每个元素只出现一次。\n\n## 构造\n``` swift\nvar shoppinglist: Set = [\"Eggs\", \"Milk\"]\t//初始化为字符串集合，没有指定数据类型，通过添加数据自动判断为String集合\n\nvar someInts1: Set = [2, 3]\t\t\t\nvar someInts2: Set<Int> = [2, 3]\t\t//等价于上一句，初始化为整数集合，指定了数据类型Int，只能添加Int数据，并添加了元素2，3\n\nvar someInts3 = Set<Int>()\t\t\t//初始化为整数集合，指定了数据类型Int，只能添加Int数据，没有添加元素\n\nvar someDoubles: Set = []\t\t\t//初始化为空集合，没有指定数据类型，通过添加数据自动判断\nsomeDoubles.insert(2.3)\t\t\t\t//通过添加数据自动判断为Double集合\n```\n集合的元素只能有一种数据类型。\n\n## 数量\n- Set.count：属性`count`表示集合`Set`的元素个数。\n- Set.isEmpty：属性`isEmpty`表示集合`Set`的元素是否为0个，结果为`true`或`false`。\n\n## 遍历\n``` swift\nvar shoppinglist1: Set = [\"Milk\", \"Eggs\"]\nfor item in shoppingList {\n\tprintln(item)\n}\n//Milk\n//Eggs\n\nvar shoppinglist2: Set = [\"Milk\", \"Eggs\"]\nfor item in sorted(shoppingList) {\n\tprintln(item)\n}\n//Eggs\n//Milk\n```\n因为`Set`中没有确定顺序，可以通过`sorted(Set)`函数返回一个排序的集合。\n\n## 添加\n- Set.imsert(Item)：将元素`Item`添加到集合`Set`中。\n\n## 删除\n- Set.remove(Item)：删除集合`Set`中的元素`Item`，成功则返回`Item`，如果集合中不包含`Item`则返回`nil`。\n- Set.removeAll()：删除集合`Set`中的所有元素\n\n## 包含\n- Set.contains(Item)：检查集合`Set`是否包含元素`Item`，返回`true`或`false`。\n\n## 比较\n``` swift\nlet s1: Set = [1, 2]\nlet s2: Set = [3, 4, 5, 1, 2]\nlet cityAnimals: Set = [6, 7]\ns1.isSubsetOf(s2)\n// true\ns2.isSuperSetOf(s1)\n// true\ns2.isDisjointWith(s3)\n// true\n```\n- ==：判断两个集合是否相等\n- Set1.isSubsetOf(Set2)：判断`Set1`是否是`Set2`的子集\n- Set1.isSupersetOf(Set2)：判断`Set1`是否是`Set2`的父集\n- Set1.isStrictSubsetOf(Set2)，Set1.isStrictSupersetOf(Set2)：和上面方法相似，不过两个集合不能相等。\n- Set1.isDisjoinWith(Set2)：判断`Set1`和`Set2`是否完成没有一个相同元素\n上述方法都返回`true`或`false`。\n\n## 操作\n``` swift\nlet oddDigits: Set = [1, 3, 5, 7, 9]\nlet evenDigits: Set = [0, 2, 4, 6, 8]\nlet singleDigitPrimeNumbers: Set = [2, 3, 5, 7]\nsorted(oddDigits.union(evenDigits))\n// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nsorted(oddDigits.intersect(evenDigits))\n// []\nsorted(oddDigits.subtract(singleDigitPrimeNumbers))\n// [1, 9]\nsorted(oddDigits.exclusiveOr(singleDigitPrimeNumbers))\n// [1, 2, 9]\n```\n- Set1.intersects(Set2)：返回`Set1`和`Set2`的交集，即两个集合中都有的元素\n- Set1.union(Set2)：返回`Set1`和`Set2`的并集，即两个集合中的所有元素\n- Set1.subtract(Set2)：返回`Set1`和`Set2`的差集，即`Set1`中有的且`Set2`中没有的元素\n- Set1.exclusiverOr(Set2)：返回并集减去并集的集合，即`Set1`中独有的和`Set2`中独有的元素，也就是所有元素减去两个集合中都有的元素。\n\n## 哈希值\nSwift中的所有基本类型默认都是可哈希的，通过`a.hashValue`求得哈希值。哈希值相等可以判断对象相同，如`a == b`即`a.hashValue == b.hashValue`。\n\n# 字典\n字典中每个值（_Value_）都关联唯一的建（_key_）。\n\n## 构造\n在构造过程中，键值对默认用`[key 1: value 1, key 2: value 2, key 3: value 3]`的形式。\n``` swift\nvar airports1 = [\"TYO\": \"Tokyo\", \"DUB\": \"Dublin\"]\t\t\t\t//初始化为[String: String]字典，没有指定数据类型，通过添加数据自动判断\nvar airports2: [String: String] = [\"TYO\": \"Tokyo\", \"DUB\": \"Dublin\"]\t\t//等价于上一句\nvar airports3: Dictionary<Stringr, String> = [\"TYO\": \"Tokyo\", \"DUB\": \"Dublin\"]\t//等价于上一句\n\nvar airports4 = Dictionary<String, Sting>()\t//初始化为[Sting: String]空字典，指定了数据类型[String: String]，只能添加[String:String]数据，没有添加元素\nvar airports5 = [String: String]()\t\t//等价于上一句\n\nvar airports6 = [:]\t//初始化为空字典，没有指定数据类型，通过添加数据自动判断\nairports6[2] = 3\t//通过添加数据自动判断为[Int: Int]字典\n```\n\n## 数量\n- Dictionary.count：属性`count`表示字典`Dictionary`的元素个数。\n- Dictionary.isEmpty：属性`isEmpty`表示字典`Dictionary`的元素是否为0个，结果为`true`或`false`。\n\n## 访问\n- Dictionary[key]：通过下标`[key]`访问字典`Dictionary`的键`key`对应的值，可修改。\n\n## 遍历\n``` swift\nfor (airportCode, airportName) in airports {\n    println(\"\\(airportCode): \\(airportName)\")\n}\n// TYO: Tokyo\n// DUB: Dublin\n\nfor airportCode in airports.keys {\n    println(\"Airport code: \\(airportCode)\")\n}\n// Airport code: TYO\n// Airport code: DUB\n\nfor airportName in airports.values {\n    println(\"Airport name: \\(airportName)\")\n}\n// Airport name: Tokyo\n// Airport name: Dublin\n```\n`for-in`可便利字典，可便利键值对`(key, value)`，也可以通过属性`keys`或`values`只便利键值其中一项。\n字典的属性`keys`和`values`返回数组。\n``` swift\nlet airportCodes = Array(airports.keys)\n// airportCodes is [\"TYO\", \"DUB\"]\n\nlet airportNames = Array(airports.values)\n// airportNames is [\"Tokyo\", \"Dublin\"]\n```\n## 添加\n- Dictionary[key] = value：更新字典`Dictionary`中键`key`对应的值，如果不存在，则将键值对<key, valye>添加到字典`Dictionary`中。\n- Dicitonary.updateValue(value, forkey: key)：更新字典`Dictionary`中键`key`对应的值，如果不存在，则将键值对<key, value>添加到字典`Dictionary`。\n注意：该方法返回**原值**，即执行`updateValue`方法之前键`key`对应的值，如果不存在，则返回`nil`。\n\n## 删除\n- Dictionary[key] = nil：删除字典`Dictionary`中键`key`对应的值。\n- Dictionary.removeValueForKey(key)：删除字典`Dictionary`中键`key`对应的值，返回删除的值，如果不存在，则返回`nil`。\n\n添加操作和删除操作返回值有可能为`nil`，都是可选类型，使用时需要进行判断是否有值。\n","source":"_posts/swift_3.md","raw":"title: \"Swift基础入门(3)：数组，集合和字典\"\ndate: 2015-07-15 17:04:30\ntags:\n- swift\ncategories: swift\ntoc: true\n---\n\n本篇介绍Swift的基础知识：数组（Array），集合（Set）和字符（Dictionary）。\n\n<!--more-->\n**Title: [Swift基础入门(3)：数组，集合和字典](https://aidaizyy.github.io/swift_3)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-16](http://aidaizyy.github.io)**\n\n# 数组\n\n## 构造\n``` swift\nvar shoppinglist = [\"Eggs\", \"Milk\"]\t//初始化为字符串数组，没有指定数据类型，通过添加数据自动判断为String数组\n\nvar someInts1 = [2, 3]\nvar someInts2: [Int] = [2, 3]\t\t//等价于上一句，初始化为整数数组，指定了数据类型Int，只能添加Int数据，并添加了元素2，3\nvar someInts3: Array<Int> = [2, 3]\t//等价于上一句\n\nvar someInts4 = Array<Int>()\t\t//初始化为整数数组，指定了数据类型Int，只能添加Int数据，没有添加元素\nvar someInts5 = [Int]()\t\t\t//等价于上一句\n\nvar someDoubles = []\t\t\t//初始化为空数组，没有指定数据类型，通过添加数据自动判断\nsomeDoubles.append(2.3)\t\t\t//通过添加数据自动判断为Double数组\n\nvar threeDoubles = [Double](count: 3, repeatedValue: 0.0)\n//(count: , repeatedValue: )形式，指定了重复的值和重复的次数，构造数组{0.0, 0.0, 0.0}\n```\n数组的元素只能有一种数据类型。\n\n## 数量\n- Array.count：属性`count`表示数组`Array`的元素个数。\n- Array.isEmpty：属性`isEmpty`表示数组`Array`的元素是否为0个，结果为`true`或`false`。\n\n## 访问\n- Array[i]：通过下标`[i]`访问数组`Array`的第`i`位，可修改。\n\n## 遍历\n``` swift\nvar shoppinglist = [\"Eggs\", \"Milk\"]\nfor item in shoppingList {\n\tprintln(item)\n}\n//Eggs\n//Milk\n```\n\n## 添加\n- Array.append(Item)：将元素`Item`添加到数组`Array`的尾部。\n- Array.imsert(Item, atIndex: i)：将元素`Item`添加到数组`Array`的第`i`位。\n- Array += [Item1, Item2]：将元素`Item1`和`Item2`添加到数组`Array`的尾部。\n\n## 删除\n- Array.removeAtIndex(i)：删除数组`Array`的第`i`位。\n- Array.removeLast()：删除数组`Array`的最后一位。\n\n## 替换\n- Array[m...n] = [Item1, Item2]：用元素`Item1`和`Item2`替换数组`Array`的第`m`位到第`n`位。这种方法不能用于添加新元素。\n\n#  集合\n集合中的元素没有确定顺序，且每个元素只出现一次。\n\n## 构造\n``` swift\nvar shoppinglist: Set = [\"Eggs\", \"Milk\"]\t//初始化为字符串集合，没有指定数据类型，通过添加数据自动判断为String集合\n\nvar someInts1: Set = [2, 3]\t\t\t\nvar someInts2: Set<Int> = [2, 3]\t\t//等价于上一句，初始化为整数集合，指定了数据类型Int，只能添加Int数据，并添加了元素2，3\n\nvar someInts3 = Set<Int>()\t\t\t//初始化为整数集合，指定了数据类型Int，只能添加Int数据，没有添加元素\n\nvar someDoubles: Set = []\t\t\t//初始化为空集合，没有指定数据类型，通过添加数据自动判断\nsomeDoubles.insert(2.3)\t\t\t\t//通过添加数据自动判断为Double集合\n```\n集合的元素只能有一种数据类型。\n\n## 数量\n- Set.count：属性`count`表示集合`Set`的元素个数。\n- Set.isEmpty：属性`isEmpty`表示集合`Set`的元素是否为0个，结果为`true`或`false`。\n\n## 遍历\n``` swift\nvar shoppinglist1: Set = [\"Milk\", \"Eggs\"]\nfor item in shoppingList {\n\tprintln(item)\n}\n//Milk\n//Eggs\n\nvar shoppinglist2: Set = [\"Milk\", \"Eggs\"]\nfor item in sorted(shoppingList) {\n\tprintln(item)\n}\n//Eggs\n//Milk\n```\n因为`Set`中没有确定顺序，可以通过`sorted(Set)`函数返回一个排序的集合。\n\n## 添加\n- Set.imsert(Item)：将元素`Item`添加到集合`Set`中。\n\n## 删除\n- Set.remove(Item)：删除集合`Set`中的元素`Item`，成功则返回`Item`，如果集合中不包含`Item`则返回`nil`。\n- Set.removeAll()：删除集合`Set`中的所有元素\n\n## 包含\n- Set.contains(Item)：检查集合`Set`是否包含元素`Item`，返回`true`或`false`。\n\n## 比较\n``` swift\nlet s1: Set = [1, 2]\nlet s2: Set = [3, 4, 5, 1, 2]\nlet cityAnimals: Set = [6, 7]\ns1.isSubsetOf(s2)\n// true\ns2.isSuperSetOf(s1)\n// true\ns2.isDisjointWith(s3)\n// true\n```\n- ==：判断两个集合是否相等\n- Set1.isSubsetOf(Set2)：判断`Set1`是否是`Set2`的子集\n- Set1.isSupersetOf(Set2)：判断`Set1`是否是`Set2`的父集\n- Set1.isStrictSubsetOf(Set2)，Set1.isStrictSupersetOf(Set2)：和上面方法相似，不过两个集合不能相等。\n- Set1.isDisjoinWith(Set2)：判断`Set1`和`Set2`是否完成没有一个相同元素\n上述方法都返回`true`或`false`。\n\n## 操作\n``` swift\nlet oddDigits: Set = [1, 3, 5, 7, 9]\nlet evenDigits: Set = [0, 2, 4, 6, 8]\nlet singleDigitPrimeNumbers: Set = [2, 3, 5, 7]\nsorted(oddDigits.union(evenDigits))\n// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nsorted(oddDigits.intersect(evenDigits))\n// []\nsorted(oddDigits.subtract(singleDigitPrimeNumbers))\n// [1, 9]\nsorted(oddDigits.exclusiveOr(singleDigitPrimeNumbers))\n// [1, 2, 9]\n```\n- Set1.intersects(Set2)：返回`Set1`和`Set2`的交集，即两个集合中都有的元素\n- Set1.union(Set2)：返回`Set1`和`Set2`的并集，即两个集合中的所有元素\n- Set1.subtract(Set2)：返回`Set1`和`Set2`的差集，即`Set1`中有的且`Set2`中没有的元素\n- Set1.exclusiverOr(Set2)：返回并集减去并集的集合，即`Set1`中独有的和`Set2`中独有的元素，也就是所有元素减去两个集合中都有的元素。\n\n## 哈希值\nSwift中的所有基本类型默认都是可哈希的，通过`a.hashValue`求得哈希值。哈希值相等可以判断对象相同，如`a == b`即`a.hashValue == b.hashValue`。\n\n# 字典\n字典中每个值（_Value_）都关联唯一的建（_key_）。\n\n## 构造\n在构造过程中，键值对默认用`[key 1: value 1, key 2: value 2, key 3: value 3]`的形式。\n``` swift\nvar airports1 = [\"TYO\": \"Tokyo\", \"DUB\": \"Dublin\"]\t\t\t\t//初始化为[String: String]字典，没有指定数据类型，通过添加数据自动判断\nvar airports2: [String: String] = [\"TYO\": \"Tokyo\", \"DUB\": \"Dublin\"]\t\t//等价于上一句\nvar airports3: Dictionary<Stringr, String> = [\"TYO\": \"Tokyo\", \"DUB\": \"Dublin\"]\t//等价于上一句\n\nvar airports4 = Dictionary<String, Sting>()\t//初始化为[Sting: String]空字典，指定了数据类型[String: String]，只能添加[String:String]数据，没有添加元素\nvar airports5 = [String: String]()\t\t//等价于上一句\n\nvar airports6 = [:]\t//初始化为空字典，没有指定数据类型，通过添加数据自动判断\nairports6[2] = 3\t//通过添加数据自动判断为[Int: Int]字典\n```\n\n## 数量\n- Dictionary.count：属性`count`表示字典`Dictionary`的元素个数。\n- Dictionary.isEmpty：属性`isEmpty`表示字典`Dictionary`的元素是否为0个，结果为`true`或`false`。\n\n## 访问\n- Dictionary[key]：通过下标`[key]`访问字典`Dictionary`的键`key`对应的值，可修改。\n\n## 遍历\n``` swift\nfor (airportCode, airportName) in airports {\n    println(\"\\(airportCode): \\(airportName)\")\n}\n// TYO: Tokyo\n// DUB: Dublin\n\nfor airportCode in airports.keys {\n    println(\"Airport code: \\(airportCode)\")\n}\n// Airport code: TYO\n// Airport code: DUB\n\nfor airportName in airports.values {\n    println(\"Airport name: \\(airportName)\")\n}\n// Airport name: Tokyo\n// Airport name: Dublin\n```\n`for-in`可便利字典，可便利键值对`(key, value)`，也可以通过属性`keys`或`values`只便利键值其中一项。\n字典的属性`keys`和`values`返回数组。\n``` swift\nlet airportCodes = Array(airports.keys)\n// airportCodes is [\"TYO\", \"DUB\"]\n\nlet airportNames = Array(airports.values)\n// airportNames is [\"Tokyo\", \"Dublin\"]\n```\n## 添加\n- Dictionary[key] = value：更新字典`Dictionary`中键`key`对应的值，如果不存在，则将键值对<key, valye>添加到字典`Dictionary`中。\n- Dicitonary.updateValue(value, forkey: key)：更新字典`Dictionary`中键`key`对应的值，如果不存在，则将键值对<key, value>添加到字典`Dictionary`。\n注意：该方法返回**原值**，即执行`updateValue`方法之前键`key`对应的值，如果不存在，则返回`nil`。\n\n## 删除\n- Dictionary[key] = nil：删除字典`Dictionary`中键`key`对应的值。\n- Dictionary.removeValueForKey(key)：删除字典`Dictionary`中键`key`对应的值，返回删除的值，如果不存在，则返回`nil`。\n\n添加操作和删除操作返回值有可能为`nil`，都是可选类型，使用时需要进行判断是否有值。\n","slug":"swift_3","published":1,"updated":"2015-07-21T08:50:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qrs000nmeo3e9gkksds"},{"title":"Swift基础入门(2)：字符串和字符","date":"2015-07-15T06:09:04.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：字符串和字符。\n\n<!--more-->\n**Title: [Swift基础入门(2)：字符串和字符](https://aidaizyy.github.io/swift_2)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-15](http://aidaizyy.github.io)**\n\n## 字符串和字符\n\n### 空字符串\n``` swift\nvar str1 = \"\"\nvar str2 = String()\n\nif str1.isEmpty {\n\t//空字符串\n}\n```\n两条语句等价，都表示空字符串。\n`String`的`isEmpty`属性表示`String`是否为空，结果为`Bool`值。\n\n### 值传递\n在函数/方法中传递的是字符串的值，不会改变字符串本身。\n\n### 遍历\n``` swift\nfor character in \"Dog!\" {\n    println(character)\n}\n// D\n// o\n// g\n// !\n```\n`for-in`：`for characte in \"Hello World!\"`将会遍历字符串`\"Hello World!\"`的每个字符，并用`character: Character`来表示。\n\n### 长度\n`count(String)`函数，得到字符串的字符数量。\n\n### 连接\n- +, +=：连接字符串\n- String.append(Character)：将字符连接到字符串尾部。\n\n### 比较\n- ==：字符串相等\n- String1.hasPrefix(String2)：是否有特定前缀。如果`String1`包含前缀`String2`返回`true`，否则返回`false`。\n- String1.hasSuffix(String2)：是否有特定后缀。如果`String1`包含后缀`String2`返回`true`，否则返回`false`。\n\n### 大小写\n``` swift\nlet normal = \"Could you help me, please?\"\nlet shouty = normal.uppercaseString\n// shouty 值为 \"COULD YOU HELP ME, PLEASE?\"\nlet whispered = normal.lowercaseString\n// whispered 值为 \"could you help me, please?\"\n```\nString.uppercaseString属性表示字符串的大写，String.lowercaseString属性表示字符串的小写。\n\n## Unicode\n\nUnicode字符用`\\u{n}`表示，其中`n`为任意的一到八位十六进制数。\n\n>String：\n属性：\nString.isEmpty\nString.uppercaseString\nString.lowercaseString\nString.utf8\nString.utf16\nString.unicodeScalars\n方法：\nString.append()\nString.hasPrefix()\nString.hasSuffix()\ncount(String)\n","source":"_posts/swift_2.md","raw":"title: \"Swift基础入门(2)：字符串和字符\"\ndate: 2015-07-15 14:09:04\ntags:\n- swift\ncategories: swift\ntoc: true\n---\n\n本篇介绍Swift的基础知识：字符串和字符。\n\n<!--more-->\n**Title: [Swift基础入门(2)：字符串和字符](https://aidaizyy.github.io/swift_2)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-15](http://aidaizyy.github.io)**\n\n## 字符串和字符\n\n### 空字符串\n``` swift\nvar str1 = \"\"\nvar str2 = String()\n\nif str1.isEmpty {\n\t//空字符串\n}\n```\n两条语句等价，都表示空字符串。\n`String`的`isEmpty`属性表示`String`是否为空，结果为`Bool`值。\n\n### 值传递\n在函数/方法中传递的是字符串的值，不会改变字符串本身。\n\n### 遍历\n``` swift\nfor character in \"Dog!\" {\n    println(character)\n}\n// D\n// o\n// g\n// !\n```\n`for-in`：`for characte in \"Hello World!\"`将会遍历字符串`\"Hello World!\"`的每个字符，并用`character: Character`来表示。\n\n### 长度\n`count(String)`函数，得到字符串的字符数量。\n\n### 连接\n- +, +=：连接字符串\n- String.append(Character)：将字符连接到字符串尾部。\n\n### 比较\n- ==：字符串相等\n- String1.hasPrefix(String2)：是否有特定前缀。如果`String1`包含前缀`String2`返回`true`，否则返回`false`。\n- String1.hasSuffix(String2)：是否有特定后缀。如果`String1`包含后缀`String2`返回`true`，否则返回`false`。\n\n### 大小写\n``` swift\nlet normal = \"Could you help me, please?\"\nlet shouty = normal.uppercaseString\n// shouty 值为 \"COULD YOU HELP ME, PLEASE?\"\nlet whispered = normal.lowercaseString\n// whispered 值为 \"could you help me, please?\"\n```\nString.uppercaseString属性表示字符串的大写，String.lowercaseString属性表示字符串的小写。\n\n## Unicode\n\nUnicode字符用`\\u{n}`表示，其中`n`为任意的一到八位十六进制数。\n\n>String：\n属性：\nString.isEmpty\nString.uppercaseString\nString.lowercaseString\nString.utf8\nString.utf16\nString.unicodeScalars\n方法：\nString.append()\nString.hasPrefix()\nString.hasSuffix()\ncount(String)\n","slug":"swift_2","published":1,"updated":"2015-07-15T09:17:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qru000qmeo32cq9js95"},{"title":"Swift基础入门(14)：权限控制","date":"2015-07-29T03:28:32.000Z","toc":false,"_content":"\n本篇介绍Swift的基础知识：权限控制，包括公开访问（_pubilc_），内部访问（_internal_），私有访问（_private_）三种访问方式控制实体访问的权限。\n\n<!--more-->\n**Title: [Swift基础入门(14)：权限控制](https://aidaizyy.github.io/swift_14)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-29](http://aidaizyy.github.io)**\n\n# 权限控制\n我们可以给基本类型、常量变量、函数、类、结构体、枚举、属性、方法、下标等等设置访问级别确定访问权限。\n- public：公开访问，实体能够被当前模块（_module_）中的所有源文件访问，也可以被其他引用了该模块的另一个模块中的所有源文件访问。\n- internal：内部访问，实体能够被当前模块中的所有源文件访问，但是不可以被其他引用了该模块的另一个模块中的源文件访问。\n- private：私有访问，实体只能在当前源文件中访问，不能被其他任何源文件访问。\n\n默认的权限为`internal`，`public`和`private`必须指定。\n\n对于属性，可以设置取值权限比赋值权限更加开放，即getter的权限比setter高。\n比如下面的例子，用`private(set)`把属性的setter权限设置为私有访问，而getter的权限仍然为默认的`internal`内部访问。\n``` swift\n    public class ListItem {\n\n    // ListItem这个类，有两个公开的属性\n    public var text: String\n    public var isComplete: Bool\n\n    // 下面的代码表示把变量UUID的赋值权限设为private，对整个app可读，但值只能在本文件里写入\n    private(set) var UUID: NSUUID\n\n    public init(text: String, completed: Bool, UUID: NSUUID) {\n        self.text = text\n        self.isComplete = completed\n        self.UUID = UUID\n    }\n\n    // 这段没有特别标记权限，因此属于默认的internal级别。在框架目标内可用，但对于其他目标不可用\n    func refreshIdentity() {\n        self.UUID = NSUUID()\n    }\n\n    public override func isEqual(object: AnyObject?) -> Bool {\n        if let item = object as? ListItem {\n            return self.UUID == item.UUID\n        }\n        return false\n        }\n    }\n```\n","source":"_posts/swift_14.md","raw":"title: \"Swift基础入门(14)：权限控制\"\ndate: 2015-07-29 11:28:32\ntags:\n- swift\ncategories: swift\ntoc: false\n---\n\n本篇介绍Swift的基础知识：权限控制，包括公开访问（_pubilc_），内部访问（_internal_），私有访问（_private_）三种访问方式控制实体访问的权限。\n\n<!--more-->\n**Title: [Swift基础入门(14)：权限控制](https://aidaizyy.github.io/swift_14)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-29](http://aidaizyy.github.io)**\n\n# 权限控制\n我们可以给基本类型、常量变量、函数、类、结构体、枚举、属性、方法、下标等等设置访问级别确定访问权限。\n- public：公开访问，实体能够被当前模块（_module_）中的所有源文件访问，也可以被其他引用了该模块的另一个模块中的所有源文件访问。\n- internal：内部访问，实体能够被当前模块中的所有源文件访问，但是不可以被其他引用了该模块的另一个模块中的源文件访问。\n- private：私有访问，实体只能在当前源文件中访问，不能被其他任何源文件访问。\n\n默认的权限为`internal`，`public`和`private`必须指定。\n\n对于属性，可以设置取值权限比赋值权限更加开放，即getter的权限比setter高。\n比如下面的例子，用`private(set)`把属性的setter权限设置为私有访问，而getter的权限仍然为默认的`internal`内部访问。\n``` swift\n    public class ListItem {\n\n    // ListItem这个类，有两个公开的属性\n    public var text: String\n    public var isComplete: Bool\n\n    // 下面的代码表示把变量UUID的赋值权限设为private，对整个app可读，但值只能在本文件里写入\n    private(set) var UUID: NSUUID\n\n    public init(text: String, completed: Bool, UUID: NSUUID) {\n        self.text = text\n        self.isComplete = completed\n        self.UUID = UUID\n    }\n\n    // 这段没有特别标记权限，因此属于默认的internal级别。在框架目标内可用，但对于其他目标不可用\n    func refreshIdentity() {\n        self.UUID = NSUUID()\n    }\n\n    public override func isEqual(object: AnyObject?) -> Bool {\n        if let item = object as? ListItem {\n            return self.UUID == item.UUID\n        }\n        return false\n        }\n    }\n```\n","slug":"swift_14","published":1,"updated":"2015-07-29T03:46:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qrw000tmeo3spj99g5t"},{"title":"Swift基础入门(13)：高级运算符","date":"2015-07-28T03:59:40.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：高级运算符，包括位运算符，溢出运算符和运算符重载与自定义。\n\n<!--more-->\n**Title: [Swift基础入门(13)：高级操作符](https://aidaizyy.github.io/swift_13)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-28](http://aidaizyy.github.io)**\n\n# 高级操作符\n\n## 位运算符\nSwift中位运算符和C语言基本一致，不再详细介绍。\n- ~：取反\n- &：与\n- |：或\n- ^：异或\n- <<：左移\n- \\>\\>：右移\n左移右移同样分逻辑移位和算术移位\n\n## 溢出运算符\nSwift默认不能溢出，如果故意要溢出必须采用溢出运算。\n- &+：溢出加法\n- &-：溢出减法\n- &*：溢出乘法\n- &/：溢出除法\n- &%：溢出求余\n``` swift\nvar willOverflow = UInt8.max\n// willOverflow 等于UInt8的最大整数 255\nwillOverflow = willOverflow &+ 1\n// 此时 willOverflow 等于 0\n\nvar willUnderflow = UInt8.min\n// willUnderflow 等于UInt8的最小值0\nwillUnderflow = willUnderflow &- 1\n// 此时 willUnderflow 等于 255\n\nvar signedUnderflow = Int8.min\n// signedUnderflow 等于最小的有符整数 -128\nsignedUnderflow = signedUnderflow &- 1\n// 此时 signedUnderflow 等于 127\n\nlet x = 1\nlet y = x &/ 0\n// y 等于 0\n```\n不一样的地方在于：一个数除以0或者对0求余数，即`i / 0`或者`i % 0`，其他默认会溢出的语言会报错。但是Swift的`i &/ 0`和`i &% 0`溢出运算会让结果都等于0。\n\n## 运算符函数\n对运算符重载，让已有的运算符，如`+`，`-`等基本运算符能对自定义的类和结构体进行运算。\n- @infix：中置运算符\n- @prefix：前置运算符\n- @postfix：后置运算符\n- @assignment：组合赋值运算符\n下面对`+`进行重载，函数传入了两个参数，表示双目运算符，有两个操作数。\n函数前加上关键字`@infix`，表示`+`作为中置运算符，放在两个操作数的中间。\n``` swift\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\n@infix func + (left: Vector2D, right: Vector2D) -> Vector2D {\n    return Vector2D(x: left.x + right.x, y: left.y + right.y)\n}\n\nlet vector = Vector2D(x: 3.0, y: 1.0)\nlet anotherVector = Vector2D(x: 2.0, y: 4.0)\nlet combinedVector = vector + anotherVector\n// combinedVector 是一个新的Vector2D, 值为 (5.0, 5.0)\n```\n前置和后置运算分别加上关键字`@prefix`和`@postfix`，表示把运算符放在操作数前面或后面。\n函数只传入一个参数，表示弹幕运算符，只有一个操作数。\n``` swift\n@prefix func - (vector: Vector2D) -> Vector2D {\n    return Vector2D(x: -vector.x, y: -vector.y)\n}\n\nlet positive = Vector2D(x: 3.0, y: 4.0)\nlet negative = -positive\n// negative 为 (-3.0, -4.0)\nlet alsoPositive = -negative\n// alsoPositive 为 (3.0, 4.0)\n```\n如果我们要重载`+=`，`-=`等运算符加上赋值符的组合赋值运算符，需要使用`@assignment`关键字。也可以和前置后置组合起来，形成`@prefix @assignment`或`@postfix @assignment`。\n``` swift\n@assignment func += (inout left: Vector2D, right: Vector2D) {\n    left = left + right\t\t//`+`在前面的例子中已经定义过了\n}\n\nvar original = Vector2D(x: 1.0, y: 2.0)\nlet vectorToAdd = Vector2D(x: 3.0, y: 4.0)\noriginal += vectorToAdd\n// original 现在为 (4.0, 6.0)\n\n@prefix @assignment func ++ (inout vector: Vector2D) -> Vector2D {\n    vector += Vector2D(x: 1.0, y: 1.0)\n    return vector\n}\n\nvar toIncrement = Vector2D(x: 3.0, y: 4.0)\nlet afterIncrement = ++toIncrement\n// toIncrement 现在是 (4.0, 5.0)\n// afterIncrement 现在也是 (4.0, 5.0)\n```\n比较运算符重载`==`和`!=`类似于其他中置运算符。\n``` swift\n@infix func == (left: Vector2D, right: Vector2D) -> Bool {\n    return (left.x == right.x) && (left.y == right.y)\n}\n\n@infix func != (left: Vector2D, right: Vector2D) -> Bool {\n    return !(left == right)\n}\n\nlet twoThree = Vector2D(x: 2.0, y: 3.0)\nlet anotherTwoThree = Vector2D(x: 2.0, y: 3.0)\nif twoThree == anotherTwoThree {\n    println(\"这两个向量是相等的.\")\n}\n// prints \"这两个向量是相等的.\"\n```\n但是默认赋值符`=`和三目条件运算符`a?b:c`都不可重载。\n- 自定义运算符\n除了标准的运算符之外，Swift还规定对只有`/ = - + * / < > ! & | ^ . ~`这些符号的运算符进行自定义。\n新的运算符需要在全局域用`operator`关键字声明，声明为中置，前置或后置。\n比如`operator prefix +++ {}`声明了新的前置运算符`+++`。\n然后重载实现`+++`运算符：\n``` swift\n@prefix @assignment func +++ (inout vector: Vector2D) -> Vector2D {\n    vector += vector\n    return vector\n}\n\nvar toBeDoubled = Vector2D(x: 1.0, y: 4.0)\nlet afterDoubling = +++toBeDoubled\n// toBeDoubled 现在是 (2.0, 8.0)\n// afterDoubling 现在也是 (2.0, 8.0)\n```\n还可以为自定义的运算符定义结合性和优先级。\n结合性`associativity`后面可以接`left`（和左边操作数结合），`right`（和右边操作数结合），`none`（默认值，不与其他相同优先级的运算符写在一起）。\n优先级`precedence`后面接数值表示优先级，默认为`100`。\n下面一个例子。\n``` swift\noperator infix +- { associativity left precedence 140 }\nfunc +- (left: Vector2D, right: Vector2D) -> Vector2D {\n    return Vector2D(x: left.x + right.x, y: left.y - right.y)\n}\nlet firstVector = Vector2D(x: 1.0, y: 2.0)\nlet secondVector = Vector2D(x: 3.0, y: 4.0)\nlet plusMinusVector = firstVector +- secondVector\n// plusMinusVector 此时的值为 (4.0, -2.0)\n```\n自定义运算符优先级默认为100，其他标准运算符优先级从高到低：\n- 160（无结合）：`<<`  `>>`\n- 150（左结合）：`*`  `/`  `%`  `&*`  `&/`  `&%`  `&`（位与）\n- 140（左结合）：`+`  `-`  `&+`  `&-`  `|`（位或）  `^`（位异或）\n- 135（无结合）：`..<`  `...`\n- 132（无结合）：`is`  `as`\n- 130（无结合）：`<`  `<=`  `\\>`  `\\>=`  `==`  `!=`  `===`  `!==`  `~=`（模式匹配）\n- 120（左结合）：`&&`（逻辑与）\n- 110（左结合）：`||`（逻辑或）\n- 100（右结合）：`? :` （三元条件）\n- 90（右结合）：`=`  `*=`  `/=`  `%=`  `+=`  `-=`  `<<=`  `>>=`  `&=`  `|=`  `^=`  `&&=`  `||=`\n","source":"_posts/swift_13.md","raw":"title: \"Swift基础入门(13)：高级运算符\"\ndate: 2015-07-28 11:59:40\ntags:\n- swift\ncategories: swift \ntoc: true\n---\n\n本篇介绍Swift的基础知识：高级运算符，包括位运算符，溢出运算符和运算符重载与自定义。\n\n<!--more-->\n**Title: [Swift基础入门(13)：高级操作符](https://aidaizyy.github.io/swift_13)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-28](http://aidaizyy.github.io)**\n\n# 高级操作符\n\n## 位运算符\nSwift中位运算符和C语言基本一致，不再详细介绍。\n- ~：取反\n- &：与\n- |：或\n- ^：异或\n- <<：左移\n- \\>\\>：右移\n左移右移同样分逻辑移位和算术移位\n\n## 溢出运算符\nSwift默认不能溢出，如果故意要溢出必须采用溢出运算。\n- &+：溢出加法\n- &-：溢出减法\n- &*：溢出乘法\n- &/：溢出除法\n- &%：溢出求余\n``` swift\nvar willOverflow = UInt8.max\n// willOverflow 等于UInt8的最大整数 255\nwillOverflow = willOverflow &+ 1\n// 此时 willOverflow 等于 0\n\nvar willUnderflow = UInt8.min\n// willUnderflow 等于UInt8的最小值0\nwillUnderflow = willUnderflow &- 1\n// 此时 willUnderflow 等于 255\n\nvar signedUnderflow = Int8.min\n// signedUnderflow 等于最小的有符整数 -128\nsignedUnderflow = signedUnderflow &- 1\n// 此时 signedUnderflow 等于 127\n\nlet x = 1\nlet y = x &/ 0\n// y 等于 0\n```\n不一样的地方在于：一个数除以0或者对0求余数，即`i / 0`或者`i % 0`，其他默认会溢出的语言会报错。但是Swift的`i &/ 0`和`i &% 0`溢出运算会让结果都等于0。\n\n## 运算符函数\n对运算符重载，让已有的运算符，如`+`，`-`等基本运算符能对自定义的类和结构体进行运算。\n- @infix：中置运算符\n- @prefix：前置运算符\n- @postfix：后置运算符\n- @assignment：组合赋值运算符\n下面对`+`进行重载，函数传入了两个参数，表示双目运算符，有两个操作数。\n函数前加上关键字`@infix`，表示`+`作为中置运算符，放在两个操作数的中间。\n``` swift\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\n@infix func + (left: Vector2D, right: Vector2D) -> Vector2D {\n    return Vector2D(x: left.x + right.x, y: left.y + right.y)\n}\n\nlet vector = Vector2D(x: 3.0, y: 1.0)\nlet anotherVector = Vector2D(x: 2.0, y: 4.0)\nlet combinedVector = vector + anotherVector\n// combinedVector 是一个新的Vector2D, 值为 (5.0, 5.0)\n```\n前置和后置运算分别加上关键字`@prefix`和`@postfix`，表示把运算符放在操作数前面或后面。\n函数只传入一个参数，表示弹幕运算符，只有一个操作数。\n``` swift\n@prefix func - (vector: Vector2D) -> Vector2D {\n    return Vector2D(x: -vector.x, y: -vector.y)\n}\n\nlet positive = Vector2D(x: 3.0, y: 4.0)\nlet negative = -positive\n// negative 为 (-3.0, -4.0)\nlet alsoPositive = -negative\n// alsoPositive 为 (3.0, 4.0)\n```\n如果我们要重载`+=`，`-=`等运算符加上赋值符的组合赋值运算符，需要使用`@assignment`关键字。也可以和前置后置组合起来，形成`@prefix @assignment`或`@postfix @assignment`。\n``` swift\n@assignment func += (inout left: Vector2D, right: Vector2D) {\n    left = left + right\t\t//`+`在前面的例子中已经定义过了\n}\n\nvar original = Vector2D(x: 1.0, y: 2.0)\nlet vectorToAdd = Vector2D(x: 3.0, y: 4.0)\noriginal += vectorToAdd\n// original 现在为 (4.0, 6.0)\n\n@prefix @assignment func ++ (inout vector: Vector2D) -> Vector2D {\n    vector += Vector2D(x: 1.0, y: 1.0)\n    return vector\n}\n\nvar toIncrement = Vector2D(x: 3.0, y: 4.0)\nlet afterIncrement = ++toIncrement\n// toIncrement 现在是 (4.0, 5.0)\n// afterIncrement 现在也是 (4.0, 5.0)\n```\n比较运算符重载`==`和`!=`类似于其他中置运算符。\n``` swift\n@infix func == (left: Vector2D, right: Vector2D) -> Bool {\n    return (left.x == right.x) && (left.y == right.y)\n}\n\n@infix func != (left: Vector2D, right: Vector2D) -> Bool {\n    return !(left == right)\n}\n\nlet twoThree = Vector2D(x: 2.0, y: 3.0)\nlet anotherTwoThree = Vector2D(x: 2.0, y: 3.0)\nif twoThree == anotherTwoThree {\n    println(\"这两个向量是相等的.\")\n}\n// prints \"这两个向量是相等的.\"\n```\n但是默认赋值符`=`和三目条件运算符`a?b:c`都不可重载。\n- 自定义运算符\n除了标准的运算符之外，Swift还规定对只有`/ = - + * / < > ! & | ^ . ~`这些符号的运算符进行自定义。\n新的运算符需要在全局域用`operator`关键字声明，声明为中置，前置或后置。\n比如`operator prefix +++ {}`声明了新的前置运算符`+++`。\n然后重载实现`+++`运算符：\n``` swift\n@prefix @assignment func +++ (inout vector: Vector2D) -> Vector2D {\n    vector += vector\n    return vector\n}\n\nvar toBeDoubled = Vector2D(x: 1.0, y: 4.0)\nlet afterDoubling = +++toBeDoubled\n// toBeDoubled 现在是 (2.0, 8.0)\n// afterDoubling 现在也是 (2.0, 8.0)\n```\n还可以为自定义的运算符定义结合性和优先级。\n结合性`associativity`后面可以接`left`（和左边操作数结合），`right`（和右边操作数结合），`none`（默认值，不与其他相同优先级的运算符写在一起）。\n优先级`precedence`后面接数值表示优先级，默认为`100`。\n下面一个例子。\n``` swift\noperator infix +- { associativity left precedence 140 }\nfunc +- (left: Vector2D, right: Vector2D) -> Vector2D {\n    return Vector2D(x: left.x + right.x, y: left.y - right.y)\n}\nlet firstVector = Vector2D(x: 1.0, y: 2.0)\nlet secondVector = Vector2D(x: 3.0, y: 4.0)\nlet plusMinusVector = firstVector +- secondVector\n// plusMinusVector 此时的值为 (4.0, -2.0)\n```\n自定义运算符优先级默认为100，其他标准运算符优先级从高到低：\n- 160（无结合）：`<<`  `>>`\n- 150（左结合）：`*`  `/`  `%`  `&*`  `&/`  `&%`  `&`（位与）\n- 140（左结合）：`+`  `-`  `&+`  `&-`  `|`（位或）  `^`（位异或）\n- 135（无结合）：`..<`  `...`\n- 132（无结合）：`is`  `as`\n- 130（无结合）：`<`  `<=`  `\\>`  `\\>=`  `==`  `!=`  `===`  `!==`  `~=`（模式匹配）\n- 120（左结合）：`&&`（逻辑与）\n- 110（左结合）：`||`（逻辑或）\n- 100（右结合）：`? :` （三元条件）\n- 90（右结合）：`=`  `*=`  `/=`  `%=`  `+=`  `-=`  `<<=`  `>>=`  `&=`  `|=`  `^=`  `&&=`  `||=`\n","slug":"swift_13","published":1,"updated":"2015-07-29T03:32:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qs0000wmeo3l6ja8pw5"},{"title":"Swift基础入门(12)：泛型","date":"2015-07-28T02:34:05.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：泛型，适合任何类型的函数和类型。\n\n<!--more-->\n**Title: [Swift基础入门(12)：泛型](https://aidaizyy.github.io/swift_12)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-28](http://aidaizyy.github.io)**\n\n# 泛型\n泛型（_generic_）类似于C++中的模板，可以写出适合任何类型的函数和类型。为函数或者类型指定了模板类型，可以传入任何类型去替代模板类型。\n\n## 泛型函数\n``` swift\nfunc swapTwoValues<T>(inout a: T, inout b: T) {\n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n\nvar someInt = 3\nvar anotherInt = 107\nswapTwoValues(&someInt, &anotherInt)\n// someInt is now 107, and anotherInt is now 3\n\nvar someString = \"hello\"\nvar anotherString = \"world\"\nswapTwoValues(&someString, &anotherString)\n// someString is now \"world\", and anotherString is now \"hello\"\n```\n函数`swapTwoValues`后面接尖括号和占位符`T`替代任何类型，函数的两个参数`a`和`b`的类型都指定为`T`，代表这两个参数类型是一样的，但是没有被确定，适合任何类型。\n第7-10行，传入了两个整数，可以调用函数；第12-15行，传入了两个字符串，可以调用函数。\n\n## 泛型类型\n``` swift\nstruct Stack<T> {\n    var items = [T]()\n    mutating func push(item: T) {\n        items.append(item)\n    }\n    mutating func pop() -> T {\n        return items.removeLast()\n    }\n}\n\nvar stackOfStrings = Stack<String>()\nstackOfStrings.push(\"uno\")\nstackOfStrings.push(\"dos\")\nstackOfStrings.push(\"tres\")\nstackOfStrings.push(\"cuatro\")\n// 现在栈已经有4个string了\n```\n结构体`Stack`被定义为泛型类型，传入参数T表示类型，比如`Stack<String>`。\n\n## 类型约束\n类型参数可以有多个，在尖括号中用逗号隔开。\n类型参数的命名可以自由命名，以大写字母开头。\n类型参数也可以定义类型约束。\n``` swift\nfunc someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {\n    // function body goes here\n}\n```\n比如上面代码中，类型`T`必须是类`SomeClass`的子类，类型`U`必须遵循协议`SomeProtocol`。\n再来一个例子。\n``` swift\nfunc findIndex<T: Equatable>(array: T[], valueToFind: T) -> Int? {\n    for (index, value) in enumerate(array) {\n        if value == valueToFind {\n            return index\n        }\n    }\n    return nil\n}\n```\n`Equatable`是Swift自带的协议，表示可以用`==`和`!=`进行比较，所有的标准类型都支持这个协议。因为后面的函数体中出现了`==`比较，所以必须要求类型`T`遵循`Equatable`类型。\n\n## 关联类型\n关联类型（_associated type_）声明在协议中，表示一个类型，但协议被实现前不需要指定具体类型。\n下面的例子声明了一个协议`Container`，表示容器，并定义了`append`方法，`count`属性和下标。`append`方法需要传入一个参数，为了使协议能支持任何类型，传入的参数类型不确定，因此用关联类型`ItemType`替代，使用关键字`typealias`，这里不是别名的意思。\n``` swift\nprotocol Container {\n    typealias ItemType\n    mutating func append(item: ItemType)\n    var count: Int { get }\n    subscript(i: Int) -> ItemType { get }\n}\n```\n声明协议之后，实现这个协议。\n把关联类型声明成`Int`：\n``` swift\nstruct IntStack: Container {\n    // IntStack的原始实现\n    var items = [Int]()\n    // 遵循Container协议的实现\n    typealias ItemType = Int\n    mutating func append(item: Int) {\n        self.push(item)\n    }\n    ……\n}\n```\n也可以把关联类型声明成泛型类型：\n``` swift\nstruct Stack<T>: Container {\n    // original Stack<T> implementation\n    var items = [T]()\n    // conformance to the Container protocol\n    mutating func append(item: T) {\n        self.push(item)\n    }\n}\n```\n这里没有定义`typealias ItemType`的类型，因为通过`append()`传入的参数就可以判断`ItemType`的类型，可以省略定义。\n\n- 参数约束\n通常对关联类型定义约束，使用`where`语句定义参数的约束，紧跟在类型参数列表后面。\n下面一个例子。\n``` swift\nfunc allItemsMatch<\n    C1: Container, C2: Container\n    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable>\n    (someContainer: C1, anotherContainer: C2) -> Bool {\n\n        // 检查两个Container的元素个数是否相同\n        if someContainer.count != anotherContainer.count {\n            return false\n        }\n\n        // 检查两个Container相应位置的元素彼此是否相等\n        for i in 0..<someContainer.count {\n            if someContainer[i] != anotherContainer[i] {\n                return false\n            }\n        }\n\n        // 如果所有元素检查都相同则返回true\n        return true\n\n}\n```\n两个类型参数`C1`和`C2`都遵循协议`Container`，紧跟`where`语句，表示`C1`的参数和`C2`的参数必须是同一个类型，且可以使用`==`或者`=!`符号。\n``` swift\nvar stackOfStrings = Stack<String>()\nstackOfStrings.push(\"uno\")\nstackOfStrings.push(\"dos\")\nstackOfStrings.push(\"tres\")\n\nvar arrayOfStrings = [\"uno\", \"dos\", \"tres\"]\n\nif allItemsMatch(stackOfStrings, arrayOfStrings) {\n    println(\"All items match.\")\n} else {\n    println(\"Not all items match.\")\n}\n// 输出 \"All items match.\"\n```\n这个函数的作用是比较两个容器的元素是否完全一样。\n","source":"_posts/swift_12.md","raw":"title: \"Swift基础入门(12)：泛型\"\ndate: 2015-07-28 10:34:05\ntags:\n- swift\ncategories: swift\ntoc: true\n---\n\n本篇介绍Swift的基础知识：泛型，适合任何类型的函数和类型。\n\n<!--more-->\n**Title: [Swift基础入门(12)：泛型](https://aidaizyy.github.io/swift_12)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-28](http://aidaizyy.github.io)**\n\n# 泛型\n泛型（_generic_）类似于C++中的模板，可以写出适合任何类型的函数和类型。为函数或者类型指定了模板类型，可以传入任何类型去替代模板类型。\n\n## 泛型函数\n``` swift\nfunc swapTwoValues<T>(inout a: T, inout b: T) {\n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n\nvar someInt = 3\nvar anotherInt = 107\nswapTwoValues(&someInt, &anotherInt)\n// someInt is now 107, and anotherInt is now 3\n\nvar someString = \"hello\"\nvar anotherString = \"world\"\nswapTwoValues(&someString, &anotherString)\n// someString is now \"world\", and anotherString is now \"hello\"\n```\n函数`swapTwoValues`后面接尖括号和占位符`T`替代任何类型，函数的两个参数`a`和`b`的类型都指定为`T`，代表这两个参数类型是一样的，但是没有被确定，适合任何类型。\n第7-10行，传入了两个整数，可以调用函数；第12-15行，传入了两个字符串，可以调用函数。\n\n## 泛型类型\n``` swift\nstruct Stack<T> {\n    var items = [T]()\n    mutating func push(item: T) {\n        items.append(item)\n    }\n    mutating func pop() -> T {\n        return items.removeLast()\n    }\n}\n\nvar stackOfStrings = Stack<String>()\nstackOfStrings.push(\"uno\")\nstackOfStrings.push(\"dos\")\nstackOfStrings.push(\"tres\")\nstackOfStrings.push(\"cuatro\")\n// 现在栈已经有4个string了\n```\n结构体`Stack`被定义为泛型类型，传入参数T表示类型，比如`Stack<String>`。\n\n## 类型约束\n类型参数可以有多个，在尖括号中用逗号隔开。\n类型参数的命名可以自由命名，以大写字母开头。\n类型参数也可以定义类型约束。\n``` swift\nfunc someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {\n    // function body goes here\n}\n```\n比如上面代码中，类型`T`必须是类`SomeClass`的子类，类型`U`必须遵循协议`SomeProtocol`。\n再来一个例子。\n``` swift\nfunc findIndex<T: Equatable>(array: T[], valueToFind: T) -> Int? {\n    for (index, value) in enumerate(array) {\n        if value == valueToFind {\n            return index\n        }\n    }\n    return nil\n}\n```\n`Equatable`是Swift自带的协议，表示可以用`==`和`!=`进行比较，所有的标准类型都支持这个协议。因为后面的函数体中出现了`==`比较，所以必须要求类型`T`遵循`Equatable`类型。\n\n## 关联类型\n关联类型（_associated type_）声明在协议中，表示一个类型，但协议被实现前不需要指定具体类型。\n下面的例子声明了一个协议`Container`，表示容器，并定义了`append`方法，`count`属性和下标。`append`方法需要传入一个参数，为了使协议能支持任何类型，传入的参数类型不确定，因此用关联类型`ItemType`替代，使用关键字`typealias`，这里不是别名的意思。\n``` swift\nprotocol Container {\n    typealias ItemType\n    mutating func append(item: ItemType)\n    var count: Int { get }\n    subscript(i: Int) -> ItemType { get }\n}\n```\n声明协议之后，实现这个协议。\n把关联类型声明成`Int`：\n``` swift\nstruct IntStack: Container {\n    // IntStack的原始实现\n    var items = [Int]()\n    // 遵循Container协议的实现\n    typealias ItemType = Int\n    mutating func append(item: Int) {\n        self.push(item)\n    }\n    ……\n}\n```\n也可以把关联类型声明成泛型类型：\n``` swift\nstruct Stack<T>: Container {\n    // original Stack<T> implementation\n    var items = [T]()\n    // conformance to the Container protocol\n    mutating func append(item: T) {\n        self.push(item)\n    }\n}\n```\n这里没有定义`typealias ItemType`的类型，因为通过`append()`传入的参数就可以判断`ItemType`的类型，可以省略定义。\n\n- 参数约束\n通常对关联类型定义约束，使用`where`语句定义参数的约束，紧跟在类型参数列表后面。\n下面一个例子。\n``` swift\nfunc allItemsMatch<\n    C1: Container, C2: Container\n    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable>\n    (someContainer: C1, anotherContainer: C2) -> Bool {\n\n        // 检查两个Container的元素个数是否相同\n        if someContainer.count != anotherContainer.count {\n            return false\n        }\n\n        // 检查两个Container相应位置的元素彼此是否相等\n        for i in 0..<someContainer.count {\n            if someContainer[i] != anotherContainer[i] {\n                return false\n            }\n        }\n\n        // 如果所有元素检查都相同则返回true\n        return true\n\n}\n```\n两个类型参数`C1`和`C2`都遵循协议`Container`，紧跟`where`语句，表示`C1`的参数和`C2`的参数必须是同一个类型，且可以使用`==`或者`=!`符号。\n``` swift\nvar stackOfStrings = Stack<String>()\nstackOfStrings.push(\"uno\")\nstackOfStrings.push(\"dos\")\nstackOfStrings.push(\"tres\")\n\nvar arrayOfStrings = [\"uno\", \"dos\", \"tres\"]\n\nif allItemsMatch(stackOfStrings, arrayOfStrings) {\n    println(\"All items match.\")\n} else {\n    println(\"Not all items match.\")\n}\n// 输出 \"All items match.\"\n```\n这个函数的作用是比较两个容器的元素是否完全一样。\n","slug":"swift_12","published":1,"updated":"2015-07-29T03:32:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qs3000zmeo32vtgqkrp"},{"title":"Swift基础入门(11)：扩展和协议","date":"2015-07-24T08:28:22.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：扩展（_extensions_）和协议（_protocol_）的语法和实例。\n\n<!--more-->\n**Title: [Swift基础入门(11)：扩展和协议](https://aidaizyy.github.io/swift_11)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-27](http://aidaizyy.github.io)**\n\n# 扩展\n扩展可以为枚举，类和结构体：\n- 添加计算型实例属性和计算型类型属性\n- 添加实例方法和类型方法\n- 添加构造器\n- 添加下标\n- 添加新的嵌套类型\n- 已有类型适配协议\n\n## 语法\n声明扩展使用关键字`extension`：\n``` swfit\nextension SomeType {\n    // 新功能\n}\n\nextension SomeType: SomeProtocol, AnotherProtocol {\n    // 已有类型适配的协议实现\n}\n```\n\n## 计算型属性\n扩展只能添加计算型属性，包括实例属性和类型属性，但是不能添加存储属性和属性观察器。\n下面的例子为`Double`类添加了5个计算型实例属性，因为都是只读属性，所以省略了`get`关键字。\n``` swift\nextension Double {\n    var km: Double { return self * 1_000.0 }\n    var m : Double { return self }\n    var cm: Double { return self / 100.0 }\n    var mm: Double { return self / 1_000.0 }\n    var ft: Double { return self / 3.28084 }\n}\nlet oneInch = 25.4.mm\nprintln(\"One inch is \\(oneInch) meters\")\n// 打印输出：\"One inch is 0.0254 meters\"\nlet threeFeet = 3.ft\nprintln(\"Three feet is \\(threeFeet) meters\")\n// 打印输出：\"Three feet is 0.914399970739201 meters\"\n```\n\n## 方法\n下面的例子为`Int`类型添加了1个实例方法，实现了多次执行某任务的功能。\n``` swift\nextension Int {\n    func repetitions(task: () -> ()) {\n        for i in 0..<self {\n            task()\n}}}\n\n3.repetitions({\n    println(\"Hello!\")\n    })\n// Hello!\n// Hello!\n// Hello!\n```\n这个实例方法传入一个无参数无返回值的函数，没有返回值。\n\n扩展的方法可以修改实例本身，使用`mutating`关键字。\n下面的例子添加了一个实现平方计算的方法。\n``` swift\nextension Int {\n    mutating func square() {\n        self = self * self\n    }\n}\nvar someInt = 3\nsomeInt.square()\n// someInt 现在值是 9\n```\n枚举和结构体修改`self`或者属性的方法都必须标注为`mutating`。\n\n## 下标\n下面的例子为`Int`类型添加了1个下标，返回整数的从右数第`index`位上的个位数。\n``` swift\nextension Int {\n    subscript(var digitIndex: Int) -> Int {\n        var decimalBase = 1\n            while digitIndex > 0 {\n                decimalBase *= 10\n                --digitIndex\n            }\n            return (self / decimalBase) % 10\n    }\n}\n746381295[0]\n// returns 5\n746381295[1]\n// returns 9\n746381295[2]\n// returns 2\n746381295[8]\n// returns 7\n```\n\n## 构造器\n扩展只能添加便利构造器，但是不能添加指定构造器和析构函数。\n``` swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Point {\n    var x = 0.0, y = 0.0\n}\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n}\n\nextension Rect {\n    init(center: Point, size: Size) {\n        let originX = center.x - (size.width / 2)\n        let originY = center.y - (size.height / 2)\n        self.init(origin: Point(x: originX, y: originY), size: size)\n    }\n}\n\nlet centerRect = Rect(center: Point(x: 4.0, y: 4.0),\n    size: Size(width: 3.0, height: 3.0))\n// centerRect的原点是 (2.5, 2.5)，大小是 (3.0, 3.0)\n```\n上面的例子为类`Rect`添加了构造器，传入`Point`和`Size`参数，初始化了`Rect`。\n\n## 嵌套类型\n扩展可以向已有的枚举，类和结构体添加新的嵌套类型。\n下面的例子为`Character`添加了新的枚举类型：\n``` swift\nextension Character {\n    enum Kind {\n        case Vowel, Consonant, Other\n    }\n    var kind: Kind {\n        switch String(self).lowercaseString {\n        case \"a\", \"e\", \"i\", \"o\", \"u\":\n            return .Vowel\n        case \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\",\n             \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\":\n            return .Consonant\n        default:\n            return .Other\n        }\n    }\n}\n\nfunc printLetterKinds(word: String) {\n    println(\"'\\(word)' is made up of the following kinds of letters:\")\n    for character in word {\n        switch character.kind {\n        case .Vowel:\n            print(\"vowel \")\n        case .Consonant:\n            print(\"consonant \")\n        case .Other:\n            print(\"other \")\n        }\n    }\n    print(\"\\n\")\n}\nprintLetterKinds(\"Hello\")\n// 'Hello' is made up of the following kinds of letters:\n// consonant vowel consonant consonant vowel\n```\n枚举类型`Kind`表示字母是元音，辅音还是其他类型。\n添加了计算型方法，返回字母对应的`Kind`枚举成员类型。\n\n# 协议\n协议类似于C++/Java语言中的接口，定义要实现的属性方法，但是不实现，由继承的枚举，结构体和类去实现。\n\n## 语法\n``` swift\nprotocol SomeProtocol {\n    // 协议内容\n}\n\nstruct SomeStructure: FirstProtocol, AnotherProtocol {\n    // 结构体内容\n}\n\nclass SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol {\n    // 类的内容\n}\n```\n结构体`SomeStructure`实现（用`:`表示）协议`someProtocol`和`AnotherProtocol`，多个协议隔开用`,`表示，需要实现协议的所有属性和方法。\n类`SomeClass`实现父类`SomeSuperClass`和两个协议，需要把父类声明写到前面，协议并列写在后面。\n\n- 协议类型\n协议也可以作为一种基本类型，作为函数方法的参数类型、返回值类型，常量变量属性的类型，数组字典等集合的元素类型等等。\n当协议作为集合的元素类型时，遍历集合得到的实例是协议类型，只能访问属于协议中定义的属性方法下标。\n\n## 属性\n协议中声明的属性，可以实现为实例属性或类型属性，存储型属性或计算型属性都可以。\n协议中的只读属性，可以实现为只读属性或读写属性；但是协议中的读写属性，只能实现为读写属性。\n``` swift\nprotocol SomeProtocol {\n    var mustBeSettable : Int { get set }\t//读写属性\n    var doesNotNeedToBeSettable: Int { get }\t//只读属性\n}\n```\n协议中可以定义类型属性，只能实现为类型属性，属性前加上关键字`static`。\n枚举和结构体实现后要在属性前加上关键字`static`，但是类实现后要在属性前加上关键字`class`。\n``` swift\nprotocol AnotherProtocol {\n    static var someTypeProperty: Int { get set }\n}\n```\n下面一个实例。\n``` swift\nprotocol FullyNamed {\n    var fullName: String { get }\n}\n\nstruct Person: FullyNamed{\n    var fullName: String\n}\nlet john = Person(fullName: \"John Appleseed\")\n//john.fullName 为 \"John Appleseed\"\n```\n\n## 方法\n协议中的方法不需要大括号和具体实现，支持变长参数，而不支持参数默认值。\n``` swift\nprotocol RandomNumberGenerator {\n    func random() -> Double\n}\n```\n和类型属性一样，类型方法也是在协议中使用`static`，枚举和结构体中用`static`继承，而类中用`class`继承。\n``` swift\nprotocol SomeProtocol {\n    class func someTypeMethod()\n}\n```\n- 变异方法\n在`func`前加上关键字`mutating`的方法表示在该方法中可以修改实例及其属性的值，称为变异（_mutating_）方法。\n枚举和结构体实现时，需要加上`mutating`关键字；而类实现时，不需要加上`mutating`关键字。\n下面一个实例。\n``` swift\nprotocol Togglable {\n    mutating func toggle()\n}\n\nenum OnOffSwitch: Togglable {\n    case Off, On\n    mutating func toggle() {\n        switch self {\n        case Off:\n            self = On\n        case On:\n            self = Off\n        }\n    }\n}\nvar lightSwitch = OnOffSwitch.Off\nlightSwitch.toggle()\n//lightSwitch 现在的值为 .On\n```\n在`func toggle()`中，修改了`self`的值，属于变异方法。\n\n## 构造器\n协议中的构造器不需要大括号和具体实现。\n类实现协议时，必须给构造器前面加上关键字`required`，表示它的子类必须继承的构造器。\n当然，如果针对`final`类就不需要加`required`了，标有关键字`final`的类表示不能有子类。\n``` swift\nprotocol SomeProtocol {\n    init(someParameter: Int)\n}\n\nclass SomeClass: SomeProtocol {\n    required init(someParameter: Int) {\n        //构造器实现\n    }\n}\n```\n还有一种情况，如果子类重写了父类的指定构造器，需要在构造器前加上`override`，但是如果又要同时实现协议，需要在构造器前加上`required`，那么`required`应该放在`override`前面。\n``` swift\nclass SomeSubClass: SomeSuperClass, SomeProtocol {\n    // \"required\" from SomeProtocol conformance; \"override\" from SomeSuperClass\n    required override init() {\n        // 构造器实现\n    }\n}\n```\n- 可失败构造器\n协议中的可失败构造器可以实现成可失败构造器或非可失败构造器；而协议中的非可失败构造器只能实现成非可失败构造器或隐式解析类型的可失败构造器（`init!`）。\n\n## 适配协议\n扩展可以对已存在的枚举，结构体和类添加成员，比如属性，方法，下标，协议等。\n下面的例子展示了通过扩展为已有类型适配协议。\n``` swift\nprotocol TextRepresentable {\n    func asText() -> String\n}\n\nextension Dice: TextRepresentable {\n    func asText() -> String {\n        return \"A \\(sides)-sided dice\"\n    }\n}\n```\n`Dice`是一个已存在的类型，协议中的`asText`方法被添加实现在了`Dice`中。\n如果`Dice`已经存在了`asText() -> String`方法，可以直接`extension Dice: TextRepresentable {}`，添加实现协议的声明。\n\n## 协议继承\n协议也可以和类一样，继承别的协议。\n``` swift\nprotocol InheritingProtocol: SomeProtocol, AnotherProtocol {\n    // 协议定义\n}\n```\n- 类专属协议\n如果在继承列表中加上`class`，且`class`必须第一个被声明，其他继承协议在后面并列声明，则表示这个协议只能由类实现，枚举和结构体不可以实现。\n``` swift\nprotocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {\n    // class-only protocol definition goes here\n}\n```\n\n## 协议合成\n多个协议可以用protcol<someProtocol, AnotherProtocol>的格式临时组合成一个协议。\n下面一个例子。\n``` swift\nprotocol Named {\n    var name: String { get }\n}\nprotocol Aged {\n    var age: Int { get }\n}\nstruct Person: Named, Aged {\n    var name: String\n    var age: Int\n}\nfunc wishHappyBirthday(celebrator: protocol<Named, Aged>) {\n    println(\"Happy birthday \\(celebrator.name) - you're \\(celebrator.age)!\")\n}\nlet birthdayPerson = Person(name: \"Malcolm\", age: 21)\nwishHappyBirthday(birthdayPerson)\n// 输出 \"Happy birthday Malcolm - you're 21!\n```\n\n## 协议一致性\n用`is`操作符检查协议是否实现了特定协议，返回`true`或`false`。\n用`as?`操作符返回一个可选值，如果协议实现了特定协议，返回协议类型；否则返回`nil`。如果这个协议一定实现了特定协议，可以用`as!`强制返回非可选的特定类型。\n下面一个例子。\n``` swift\nprotocol HasArea {\n    var area: Double { get }\n}\n\nclass Circle: HasArea {\n    let pi = 3.1415927\n    var radius: Double\n    var area: Double { return pi * radius * radius }\n    init(radius: Double) { self.radius = radius }\n}\nclass Country: HasArea {\n    var area: Double\n    init(area: Double) { self.area = area }\n}\nclass Animal {\n    var legs: Int\n    init(legs: Int) { self.legs = legs }\n}\n\nlet objects: [AnyObject] = [\n    Circle(radius: 2.0),\n    Country(area: 243_610),\n    Animal(legs: 4)\n]\n\nfor object in objects {\n    if let objectWithArea = object as? HasArea {\n        println(\"Area is \\(objectWithArea.area)\")\n    } else {\n        println(\"Something that doesn't have an area\")\n    }\n}\n// Area is 12.5663708\n// Area is 243610.0\n// Something that doesn't have an area\n```\n类`Circle`和类`Country`都实现了`HasArea`协议，而类`Animal`没有实现`HasArea`协议。\n这三个类的实例用同一个数组装上，然后遍历，利用协议一致性检查。在这个数组中实例的值的类型没有变，但是这里显式为`HasArea`类型，所以只能访问`area`属性。\n\n## 可选协议\n可选类型可以含有可选成员，可以选择是否实现这些可选成员，用关键字`optional`来表示这些可选成员。可选协议在调用时可以使用可选链。\n协议前的`@objc`表示协议是可选的，也表示暴露给`Objective-C`的代码，只对类有效。所以可选协议只能由类实现。\n下面一个例子。\n``` swift\n@objc protocol CounterDataSource {\n    optional func incrementForCount(count: Int) -> Int\n    optional var fixedIncrement: Int { get }\n}\n\n@objc class Counter {\n    var count = 0\n    var dataSource: CounterDataSource?\n    func increment() {\n        if let amount = dataSource?.incrementForCount?(count) {\n            count += amount\n        } else if let amount = dataSource?.fixedIncrement? {\n            count += amount\n        }\n    }\n}\n\n//为协议实现可选属性\n@objc class ThreeSource: CounterDataSource {\n    let fixedIncrement = 3\n}\nvar counter = Counter()\ncounter.dataSource = ThreeSource()\nfor _ in 1...4 {\n    counter.increment()\n    print(counter.count)\n}\n// 3\n// 6\n// 9\n// 12\n\n//为协议实现可选方法\nclass TowardsZeroSource: CounterDataSource {\nfunc incrementForCount(count: Int) -> Int {\n        if count == 0 {\n            return 0\n        } else if count < 0 {\n            return 1\n        } else {\n            return -1\n        }\n    }\n}\ncounter.count = -4\ncounter.dataSource = TowardsZeroSource()\nfor _ in 1...5 {\n    counter.increment()\n    print(counter.count)\n}\n// -3\n// -2\n// -1\n// 0\n// 0\n```\n\n## 协议扩展\n扩展协议可以为每个实现该协议的地方（_遵循者_）添加属性或方法的实现，该协议的遵循者不用任何修改，可以得到添加的属性方法。\n这种方式可以为协议中的属性和方法提供默认的实现，遵循者中再次实现可以覆盖默认的实现。\n扩展协议时可以限定条件，只有满足条件的遵循者能够得到协议扩展的属性和方法。\n","source":"_posts/swift_11.md","raw":"title: \"Swift基础入门(11)：扩展和协议\"\ndate: 2015-07-24 16:28:22\ntags:\n- swift\ncategories: swift\ntoc: true\n---\n\n本篇介绍Swift的基础知识：扩展（_extensions_）和协议（_protocol_）的语法和实例。\n\n<!--more-->\n**Title: [Swift基础入门(11)：扩展和协议](https://aidaizyy.github.io/swift_11)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-27](http://aidaizyy.github.io)**\n\n# 扩展\n扩展可以为枚举，类和结构体：\n- 添加计算型实例属性和计算型类型属性\n- 添加实例方法和类型方法\n- 添加构造器\n- 添加下标\n- 添加新的嵌套类型\n- 已有类型适配协议\n\n## 语法\n声明扩展使用关键字`extension`：\n``` swfit\nextension SomeType {\n    // 新功能\n}\n\nextension SomeType: SomeProtocol, AnotherProtocol {\n    // 已有类型适配的协议实现\n}\n```\n\n## 计算型属性\n扩展只能添加计算型属性，包括实例属性和类型属性，但是不能添加存储属性和属性观察器。\n下面的例子为`Double`类添加了5个计算型实例属性，因为都是只读属性，所以省略了`get`关键字。\n``` swift\nextension Double {\n    var km: Double { return self * 1_000.0 }\n    var m : Double { return self }\n    var cm: Double { return self / 100.0 }\n    var mm: Double { return self / 1_000.0 }\n    var ft: Double { return self / 3.28084 }\n}\nlet oneInch = 25.4.mm\nprintln(\"One inch is \\(oneInch) meters\")\n// 打印输出：\"One inch is 0.0254 meters\"\nlet threeFeet = 3.ft\nprintln(\"Three feet is \\(threeFeet) meters\")\n// 打印输出：\"Three feet is 0.914399970739201 meters\"\n```\n\n## 方法\n下面的例子为`Int`类型添加了1个实例方法，实现了多次执行某任务的功能。\n``` swift\nextension Int {\n    func repetitions(task: () -> ()) {\n        for i in 0..<self {\n            task()\n}}}\n\n3.repetitions({\n    println(\"Hello!\")\n    })\n// Hello!\n// Hello!\n// Hello!\n```\n这个实例方法传入一个无参数无返回值的函数，没有返回值。\n\n扩展的方法可以修改实例本身，使用`mutating`关键字。\n下面的例子添加了一个实现平方计算的方法。\n``` swift\nextension Int {\n    mutating func square() {\n        self = self * self\n    }\n}\nvar someInt = 3\nsomeInt.square()\n// someInt 现在值是 9\n```\n枚举和结构体修改`self`或者属性的方法都必须标注为`mutating`。\n\n## 下标\n下面的例子为`Int`类型添加了1个下标，返回整数的从右数第`index`位上的个位数。\n``` swift\nextension Int {\n    subscript(var digitIndex: Int) -> Int {\n        var decimalBase = 1\n            while digitIndex > 0 {\n                decimalBase *= 10\n                --digitIndex\n            }\n            return (self / decimalBase) % 10\n    }\n}\n746381295[0]\n// returns 5\n746381295[1]\n// returns 9\n746381295[2]\n// returns 2\n746381295[8]\n// returns 7\n```\n\n## 构造器\n扩展只能添加便利构造器，但是不能添加指定构造器和析构函数。\n``` swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Point {\n    var x = 0.0, y = 0.0\n}\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n}\n\nextension Rect {\n    init(center: Point, size: Size) {\n        let originX = center.x - (size.width / 2)\n        let originY = center.y - (size.height / 2)\n        self.init(origin: Point(x: originX, y: originY), size: size)\n    }\n}\n\nlet centerRect = Rect(center: Point(x: 4.0, y: 4.0),\n    size: Size(width: 3.0, height: 3.0))\n// centerRect的原点是 (2.5, 2.5)，大小是 (3.0, 3.0)\n```\n上面的例子为类`Rect`添加了构造器，传入`Point`和`Size`参数，初始化了`Rect`。\n\n## 嵌套类型\n扩展可以向已有的枚举，类和结构体添加新的嵌套类型。\n下面的例子为`Character`添加了新的枚举类型：\n``` swift\nextension Character {\n    enum Kind {\n        case Vowel, Consonant, Other\n    }\n    var kind: Kind {\n        switch String(self).lowercaseString {\n        case \"a\", \"e\", \"i\", \"o\", \"u\":\n            return .Vowel\n        case \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\",\n             \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\":\n            return .Consonant\n        default:\n            return .Other\n        }\n    }\n}\n\nfunc printLetterKinds(word: String) {\n    println(\"'\\(word)' is made up of the following kinds of letters:\")\n    for character in word {\n        switch character.kind {\n        case .Vowel:\n            print(\"vowel \")\n        case .Consonant:\n            print(\"consonant \")\n        case .Other:\n            print(\"other \")\n        }\n    }\n    print(\"\\n\")\n}\nprintLetterKinds(\"Hello\")\n// 'Hello' is made up of the following kinds of letters:\n// consonant vowel consonant consonant vowel\n```\n枚举类型`Kind`表示字母是元音，辅音还是其他类型。\n添加了计算型方法，返回字母对应的`Kind`枚举成员类型。\n\n# 协议\n协议类似于C++/Java语言中的接口，定义要实现的属性方法，但是不实现，由继承的枚举，结构体和类去实现。\n\n## 语法\n``` swift\nprotocol SomeProtocol {\n    // 协议内容\n}\n\nstruct SomeStructure: FirstProtocol, AnotherProtocol {\n    // 结构体内容\n}\n\nclass SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol {\n    // 类的内容\n}\n```\n结构体`SomeStructure`实现（用`:`表示）协议`someProtocol`和`AnotherProtocol`，多个协议隔开用`,`表示，需要实现协议的所有属性和方法。\n类`SomeClass`实现父类`SomeSuperClass`和两个协议，需要把父类声明写到前面，协议并列写在后面。\n\n- 协议类型\n协议也可以作为一种基本类型，作为函数方法的参数类型、返回值类型，常量变量属性的类型，数组字典等集合的元素类型等等。\n当协议作为集合的元素类型时，遍历集合得到的实例是协议类型，只能访问属于协议中定义的属性方法下标。\n\n## 属性\n协议中声明的属性，可以实现为实例属性或类型属性，存储型属性或计算型属性都可以。\n协议中的只读属性，可以实现为只读属性或读写属性；但是协议中的读写属性，只能实现为读写属性。\n``` swift\nprotocol SomeProtocol {\n    var mustBeSettable : Int { get set }\t//读写属性\n    var doesNotNeedToBeSettable: Int { get }\t//只读属性\n}\n```\n协议中可以定义类型属性，只能实现为类型属性，属性前加上关键字`static`。\n枚举和结构体实现后要在属性前加上关键字`static`，但是类实现后要在属性前加上关键字`class`。\n``` swift\nprotocol AnotherProtocol {\n    static var someTypeProperty: Int { get set }\n}\n```\n下面一个实例。\n``` swift\nprotocol FullyNamed {\n    var fullName: String { get }\n}\n\nstruct Person: FullyNamed{\n    var fullName: String\n}\nlet john = Person(fullName: \"John Appleseed\")\n//john.fullName 为 \"John Appleseed\"\n```\n\n## 方法\n协议中的方法不需要大括号和具体实现，支持变长参数，而不支持参数默认值。\n``` swift\nprotocol RandomNumberGenerator {\n    func random() -> Double\n}\n```\n和类型属性一样，类型方法也是在协议中使用`static`，枚举和结构体中用`static`继承，而类中用`class`继承。\n``` swift\nprotocol SomeProtocol {\n    class func someTypeMethod()\n}\n```\n- 变异方法\n在`func`前加上关键字`mutating`的方法表示在该方法中可以修改实例及其属性的值，称为变异（_mutating_）方法。\n枚举和结构体实现时，需要加上`mutating`关键字；而类实现时，不需要加上`mutating`关键字。\n下面一个实例。\n``` swift\nprotocol Togglable {\n    mutating func toggle()\n}\n\nenum OnOffSwitch: Togglable {\n    case Off, On\n    mutating func toggle() {\n        switch self {\n        case Off:\n            self = On\n        case On:\n            self = Off\n        }\n    }\n}\nvar lightSwitch = OnOffSwitch.Off\nlightSwitch.toggle()\n//lightSwitch 现在的值为 .On\n```\n在`func toggle()`中，修改了`self`的值，属于变异方法。\n\n## 构造器\n协议中的构造器不需要大括号和具体实现。\n类实现协议时，必须给构造器前面加上关键字`required`，表示它的子类必须继承的构造器。\n当然，如果针对`final`类就不需要加`required`了，标有关键字`final`的类表示不能有子类。\n``` swift\nprotocol SomeProtocol {\n    init(someParameter: Int)\n}\n\nclass SomeClass: SomeProtocol {\n    required init(someParameter: Int) {\n        //构造器实现\n    }\n}\n```\n还有一种情况，如果子类重写了父类的指定构造器，需要在构造器前加上`override`，但是如果又要同时实现协议，需要在构造器前加上`required`，那么`required`应该放在`override`前面。\n``` swift\nclass SomeSubClass: SomeSuperClass, SomeProtocol {\n    // \"required\" from SomeProtocol conformance; \"override\" from SomeSuperClass\n    required override init() {\n        // 构造器实现\n    }\n}\n```\n- 可失败构造器\n协议中的可失败构造器可以实现成可失败构造器或非可失败构造器；而协议中的非可失败构造器只能实现成非可失败构造器或隐式解析类型的可失败构造器（`init!`）。\n\n## 适配协议\n扩展可以对已存在的枚举，结构体和类添加成员，比如属性，方法，下标，协议等。\n下面的例子展示了通过扩展为已有类型适配协议。\n``` swift\nprotocol TextRepresentable {\n    func asText() -> String\n}\n\nextension Dice: TextRepresentable {\n    func asText() -> String {\n        return \"A \\(sides)-sided dice\"\n    }\n}\n```\n`Dice`是一个已存在的类型，协议中的`asText`方法被添加实现在了`Dice`中。\n如果`Dice`已经存在了`asText() -> String`方法，可以直接`extension Dice: TextRepresentable {}`，添加实现协议的声明。\n\n## 协议继承\n协议也可以和类一样，继承别的协议。\n``` swift\nprotocol InheritingProtocol: SomeProtocol, AnotherProtocol {\n    // 协议定义\n}\n```\n- 类专属协议\n如果在继承列表中加上`class`，且`class`必须第一个被声明，其他继承协议在后面并列声明，则表示这个协议只能由类实现，枚举和结构体不可以实现。\n``` swift\nprotocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {\n    // class-only protocol definition goes here\n}\n```\n\n## 协议合成\n多个协议可以用protcol<someProtocol, AnotherProtocol>的格式临时组合成一个协议。\n下面一个例子。\n``` swift\nprotocol Named {\n    var name: String { get }\n}\nprotocol Aged {\n    var age: Int { get }\n}\nstruct Person: Named, Aged {\n    var name: String\n    var age: Int\n}\nfunc wishHappyBirthday(celebrator: protocol<Named, Aged>) {\n    println(\"Happy birthday \\(celebrator.name) - you're \\(celebrator.age)!\")\n}\nlet birthdayPerson = Person(name: \"Malcolm\", age: 21)\nwishHappyBirthday(birthdayPerson)\n// 输出 \"Happy birthday Malcolm - you're 21!\n```\n\n## 协议一致性\n用`is`操作符检查协议是否实现了特定协议，返回`true`或`false`。\n用`as?`操作符返回一个可选值，如果协议实现了特定协议，返回协议类型；否则返回`nil`。如果这个协议一定实现了特定协议，可以用`as!`强制返回非可选的特定类型。\n下面一个例子。\n``` swift\nprotocol HasArea {\n    var area: Double { get }\n}\n\nclass Circle: HasArea {\n    let pi = 3.1415927\n    var radius: Double\n    var area: Double { return pi * radius * radius }\n    init(radius: Double) { self.radius = radius }\n}\nclass Country: HasArea {\n    var area: Double\n    init(area: Double) { self.area = area }\n}\nclass Animal {\n    var legs: Int\n    init(legs: Int) { self.legs = legs }\n}\n\nlet objects: [AnyObject] = [\n    Circle(radius: 2.0),\n    Country(area: 243_610),\n    Animal(legs: 4)\n]\n\nfor object in objects {\n    if let objectWithArea = object as? HasArea {\n        println(\"Area is \\(objectWithArea.area)\")\n    } else {\n        println(\"Something that doesn't have an area\")\n    }\n}\n// Area is 12.5663708\n// Area is 243610.0\n// Something that doesn't have an area\n```\n类`Circle`和类`Country`都实现了`HasArea`协议，而类`Animal`没有实现`HasArea`协议。\n这三个类的实例用同一个数组装上，然后遍历，利用协议一致性检查。在这个数组中实例的值的类型没有变，但是这里显式为`HasArea`类型，所以只能访问`area`属性。\n\n## 可选协议\n可选类型可以含有可选成员，可以选择是否实现这些可选成员，用关键字`optional`来表示这些可选成员。可选协议在调用时可以使用可选链。\n协议前的`@objc`表示协议是可选的，也表示暴露给`Objective-C`的代码，只对类有效。所以可选协议只能由类实现。\n下面一个例子。\n``` swift\n@objc protocol CounterDataSource {\n    optional func incrementForCount(count: Int) -> Int\n    optional var fixedIncrement: Int { get }\n}\n\n@objc class Counter {\n    var count = 0\n    var dataSource: CounterDataSource?\n    func increment() {\n        if let amount = dataSource?.incrementForCount?(count) {\n            count += amount\n        } else if let amount = dataSource?.fixedIncrement? {\n            count += amount\n        }\n    }\n}\n\n//为协议实现可选属性\n@objc class ThreeSource: CounterDataSource {\n    let fixedIncrement = 3\n}\nvar counter = Counter()\ncounter.dataSource = ThreeSource()\nfor _ in 1...4 {\n    counter.increment()\n    print(counter.count)\n}\n// 3\n// 6\n// 9\n// 12\n\n//为协议实现可选方法\nclass TowardsZeroSource: CounterDataSource {\nfunc incrementForCount(count: Int) -> Int {\n        if count == 0 {\n            return 0\n        } else if count < 0 {\n            return 1\n        } else {\n            return -1\n        }\n    }\n}\ncounter.count = -4\ncounter.dataSource = TowardsZeroSource()\nfor _ in 1...5 {\n    counter.increment()\n    print(counter.count)\n}\n// -3\n// -2\n// -1\n// 0\n// 0\n```\n\n## 协议扩展\n扩展协议可以为每个实现该协议的地方（_遵循者_）添加属性或方法的实现，该协议的遵循者不用任何修改，可以得到添加的属性方法。\n这种方式可以为协议中的属性和方法提供默认的实现，遵循者中再次实现可以覆盖默认的实现。\n扩展协议时可以限定条件，只有满足条件的遵循者能够得到协议扩展的属性和方法。\n","slug":"swift_11","published":1,"updated":"2015-07-27T13:53:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qs60012meo321006qay"},{"title":"Swift基础入门(10)：类型转换","date":"2015-07-24T07:23:06.000Z","toc":true,"_content":"\n本篇介绍Swift的基础知识：类型的检查和转换。\n\n<!--more-->\n**Title: [Swift基础入门(10)：类型转换](https://aidaizyy.github.io/swift_10)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-24](http://aidaizyy.github.io)**\n\n# 类型转换\n\n## 数值型类型转换\n- Int，Double，Float：\n`Int16`与`Int8`不能直接相加，需要通过`Int16(Int8)`转换。同样，`Int8`，`UInt8`，`Int16`，`UInt16`，`Int32`，`UInt32`，`Int64`，`UInt64`都可以互相转换。\n`Double`与`Int`也不能相加，也需要通过`Double(Int)`转换，如果只需要整数部分，也可以通过`Int(Double)`转换。同样，`Float(Int)`，`Int(Float)`，`Double(Float)`，`Float(Double)`都可以互相转换\n\n- String，Int：\nString->Int：`String.toInt()`函数可以把`String`转换成可选类型`Int?`，因为`String`中不一定能转换成`Int`，所以得到可选类型。\nInt->String：`String(Int)`函数可以把`Int`转换成`String`。\n\n## 类型检查和向下转换\n类型检查用`is`操作符检查一个实例是否属于特定类型，返回`true`或者`false`。\n基类类型用`as?`或者`as!`操作符转换成子类类型。因为转换可能失败，所以使用`as?`返回可选类型的子类类型；如果确定转换一定成功，可以使用`as!`强制返回非可选类型的子类类型。\n``` swift\nclass MediaItem {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n}\n\nclass Movie: MediaItem {\n    var director: String\n    init(name: String, director: String) {\n        self.director = director\n        super.init(name: name)\n    }\n}\n\nclass Song: MediaItem {\n    var artist: String\n    init(name: String, artist: String) {\n        self.artist = artist\n        super.init(name: name)\n    }\n}\n\nlet library = [\n    Movie(name: \"Casablanca\", director: \"Michael Curtiz\"),\n    Song(name: \"Blue Suede Shoes\", artist: \"Elvis Presley\"),\n    Movie(name: \"Citizen Kane\", director: \"Orson Welles\"),\n    Song(name: \"The One And Only\", artist: \"Chesney Hawkes\"),\n    Song(name: \"Never Gonna Give You Up\", artist: \"Rick Astley\")\n]\n// the type of \"library\" is inferred to be [MediaItem]\n\nvar movieCount = 0\nvar songCount = 0\nfor item in library {\n    if item is Movie {\n        ++movieCount\n    } else if item is Song {\n        ++songCount\n    }\n}\nprintln(\"Media library contains \\(movieCount) movies and \\(songCount) songs\")\n// prints \"Media library contains 2 movies and 3 songs\"\n\nfor item in library {\n    if let movie = item as? Movie {\n        println(\"Movie: '\\(movie.name)', dir. \\(movie.director)\")\n    } else if let song = item as? Song {\n        println(\"Song: '\\(song.name)', by \\(song.artist)\")\n    }\n}\n// Movie: 'Casablanca', dir. Michael Curtiz\n// Song: 'Blue Suede Shoes', by Elvis Presley\n// Movie: 'Citizen Kane', dir. Orson Welles\n// Song: 'The One And Only', by Chesney Hawkes\n// Song: 'Never Gonna Give You Up', by Rick Astley\n```\n类`Movie`和类`Song`都是继承自类`MediaItem`。\n数组`Libray`自动判断类型为`MediaItem`，存入了两个`Movie`实例和三个`Song`实例。在`for-in`循环中遍历出来的都是基类类型，但它实际上存储的是子类类型。\n第33-43行：`item is Movie`和`item is Song`判断`item`实际存储的值是不是子类类型，是的话在相应数量的记录上加1，最后输出各子类类型的数组元素的个数。\n第45-56行：`item as? Movie`和`item as? Song`将`item`强制转换成子类类型，如果实际存储的不相符返回`nil`，实际存储的相符返回相应的子类类型，并打印相应信息。\n\n## Any和AnyObject类型转换\n- Any：任意类型，包括方法类型。\n- AnyObject：任意class类型。\n``` swift\nlet someObjects: [AnyObject] = [\n    Movie(name: \"2001: A Space Odyssey\", director: \"Stanley Kubrick\"),\n    Movie(name: \"Moon\", director: \"Duncan Jones\"),\n    Movie(name: \"Alien\", director: \"Ridley Scott\")\n]\n\nvar things = [Any]()\nthings.append(0)\nthings.append(0.0)\nthings.append(\"hello\")\n```\n`someObject`是一个很多class类型组成的混合class类型数组，所以用`AnyObject`。\n`things`是一个很多类型组成的混合类型数组，所以用`Any`。\n它们的访问都可以通过遍历，然后使用`is`判断或者`as`转换。\n\n> 在`switch`的`case`语句中，使用`as`而不是`as?`。因为`case`语句中类型的检查和转换总是安全的。\n\n","source":"_posts/swift_10.md","raw":"title: \"Swift基础入门(10)：类型转换\"\ndate: 2015-07-24 15:23:06\ntags:\n- swift\ncategories: swift\ntoc: true\n---\n\n本篇介绍Swift的基础知识：类型的检查和转换。\n\n<!--more-->\n**Title: [Swift基础入门(10)：类型转换](https://aidaizyy.github.io/swift_10)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-24](http://aidaizyy.github.io)**\n\n# 类型转换\n\n## 数值型类型转换\n- Int，Double，Float：\n`Int16`与`Int8`不能直接相加，需要通过`Int16(Int8)`转换。同样，`Int8`，`UInt8`，`Int16`，`UInt16`，`Int32`，`UInt32`，`Int64`，`UInt64`都可以互相转换。\n`Double`与`Int`也不能相加，也需要通过`Double(Int)`转换，如果只需要整数部分，也可以通过`Int(Double)`转换。同样，`Float(Int)`，`Int(Float)`，`Double(Float)`，`Float(Double)`都可以互相转换\n\n- String，Int：\nString->Int：`String.toInt()`函数可以把`String`转换成可选类型`Int?`，因为`String`中不一定能转换成`Int`，所以得到可选类型。\nInt->String：`String(Int)`函数可以把`Int`转换成`String`。\n\n## 类型检查和向下转换\n类型检查用`is`操作符检查一个实例是否属于特定类型，返回`true`或者`false`。\n基类类型用`as?`或者`as!`操作符转换成子类类型。因为转换可能失败，所以使用`as?`返回可选类型的子类类型；如果确定转换一定成功，可以使用`as!`强制返回非可选类型的子类类型。\n``` swift\nclass MediaItem {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n}\n\nclass Movie: MediaItem {\n    var director: String\n    init(name: String, director: String) {\n        self.director = director\n        super.init(name: name)\n    }\n}\n\nclass Song: MediaItem {\n    var artist: String\n    init(name: String, artist: String) {\n        self.artist = artist\n        super.init(name: name)\n    }\n}\n\nlet library = [\n    Movie(name: \"Casablanca\", director: \"Michael Curtiz\"),\n    Song(name: \"Blue Suede Shoes\", artist: \"Elvis Presley\"),\n    Movie(name: \"Citizen Kane\", director: \"Orson Welles\"),\n    Song(name: \"The One And Only\", artist: \"Chesney Hawkes\"),\n    Song(name: \"Never Gonna Give You Up\", artist: \"Rick Astley\")\n]\n// the type of \"library\" is inferred to be [MediaItem]\n\nvar movieCount = 0\nvar songCount = 0\nfor item in library {\n    if item is Movie {\n        ++movieCount\n    } else if item is Song {\n        ++songCount\n    }\n}\nprintln(\"Media library contains \\(movieCount) movies and \\(songCount) songs\")\n// prints \"Media library contains 2 movies and 3 songs\"\n\nfor item in library {\n    if let movie = item as? Movie {\n        println(\"Movie: '\\(movie.name)', dir. \\(movie.director)\")\n    } else if let song = item as? Song {\n        println(\"Song: '\\(song.name)', by \\(song.artist)\")\n    }\n}\n// Movie: 'Casablanca', dir. Michael Curtiz\n// Song: 'Blue Suede Shoes', by Elvis Presley\n// Movie: 'Citizen Kane', dir. Orson Welles\n// Song: 'The One And Only', by Chesney Hawkes\n// Song: 'Never Gonna Give You Up', by Rick Astley\n```\n类`Movie`和类`Song`都是继承自类`MediaItem`。\n数组`Libray`自动判断类型为`MediaItem`，存入了两个`Movie`实例和三个`Song`实例。在`for-in`循环中遍历出来的都是基类类型，但它实际上存储的是子类类型。\n第33-43行：`item is Movie`和`item is Song`判断`item`实际存储的值是不是子类类型，是的话在相应数量的记录上加1，最后输出各子类类型的数组元素的个数。\n第45-56行：`item as? Movie`和`item as? Song`将`item`强制转换成子类类型，如果实际存储的不相符返回`nil`，实际存储的相符返回相应的子类类型，并打印相应信息。\n\n## Any和AnyObject类型转换\n- Any：任意类型，包括方法类型。\n- AnyObject：任意class类型。\n``` swift\nlet someObjects: [AnyObject] = [\n    Movie(name: \"2001: A Space Odyssey\", director: \"Stanley Kubrick\"),\n    Movie(name: \"Moon\", director: \"Duncan Jones\"),\n    Movie(name: \"Alien\", director: \"Ridley Scott\")\n]\n\nvar things = [Any]()\nthings.append(0)\nthings.append(0.0)\nthings.append(\"hello\")\n```\n`someObject`是一个很多class类型组成的混合class类型数组，所以用`AnyObject`。\n`things`是一个很多类型组成的混合类型数组，所以用`Any`。\n它们的访问都可以通过遍历，然后使用`is`判断或者`as`转换。\n\n> 在`switch`的`case`语句中，使用`as`而不是`as?`。因为`case`语句中类型的检查和转换总是安全的。\n\n","slug":"swift_10","published":1,"updated":"2015-07-24T08:08:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qs70015meo38i7757zl"},{"title":"Swift基础入门(1)：常量变量，基本数据类型和基本运算符","date":"2015-07-14T07:23:13.000Z","toc":true,"_content":"\nSwift是苹果公司于2014年推出的用于iOS，OS X和watchOS应用开发的新语言。\n本篇介绍Swift的基础知识：常量变量，基本数据类型和基本运算符。\n\n<!--more-->\n**Title: [Swift基础入门(1)：常量变量，基本数据类型和基本运算符](https://aidaizyy.github.io/swift_1)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-15](http://aidaizyy.github.io)**\n\n## 概要\n\nSwift结合了C和Objectiv-C的特点，基于Cocoa和Cocoa Touch框架。\n本文主要讲述Swift的基本语法。\n\n## 常量变量\n\n### 命名\n\n常量变量命名不能包括数学符号，箭头，保留的Unicode码位，连线和制表符，不能以数字开头。\n\n### 声明\n\n声明常量使用`let`关键字，声明变量使用`var`关键字。\n一般可省略数据类型，通过赋予的第一个值来自动确定数据类型。\n``` swift\nlet maxNumber = 20\nvar currentNumber = 0, item = 0.1\n```\n在swift中，语句结束不需要加分号。（添加分号也没有问题）\n上面两句，声明了常量`maxNumber`，并赋值为20，这个值不能被改变。声明时可以不赋值，但之后只能赋值一次。\n声明了变量`currentNumber`和`item`，并赋值为0和0.1，可赋值多次。\n在一行中可声明多个常量或变量，用逗号隔开。\n`maxNumber`和`currentNumber`第一次赋值了整数，被确定为整数类型`Int`；`item`第一次赋值了小数，被确定为浮点数类型`Double`（未指定数据类型时，小数一定会被确定为`Double`而不是`Float`）。\n\n> 基本数据类型：\n- Int\n- Double\n- Float\n- Bool\n- String\n- Character\n\n声明常量变量时，也可以指定数据类型，通过在常量变量名称后接冒号再接数据类型名称来实现。\n``` swift\nvar currentNumer: Double = 5\nprintln(currentNumber)\t//输出currentNumber的值\n```\n上面两句输出结果为`5.0`，因为`currentNumber`指定为`Double`类型，即使给它赋值了整数5。\n\n### 输出\n\n`println`和`print`函数都是输出函数，区别在于前者在输出末尾加上了换行符。\n\n输出常量变量：\n``` swift\nvar currentNumer: Double = 5\nprintln(\"The current number is \\(currentNumber)\")\n```\n上面两句输出结果为`The current number is 0.5`。\n通过`\\(常量变量)`将常量变量转换为字符串并在`println`语句中输出。\n\n### 注释\n\n和C语言类似，注释分为单行注释`//`和多行注释`/*  */`\n``` swift\nvar single\t//单行注释\n\n/* 多行注释 */\n```\n不一样的地方在于，swift的`/* */`可以嵌套。\n\n## 基本数据类型\n\n### 整数\n\n整数分为`Int8`，`UInt8`，`Int16`，`UInt16`，`Int32`，`UInt32`，`Int64`，`UInt64`，分别对应8，16，32，64位的有符号整数类型和无符号整数类型。\n一般`Int`指`Int32`（32位电脑）或`Int64`（64位电脑）。\n整数类型都有`min`和`max`两个方法。\n``` swift\nvar tmp = Int.max\nprintln(tmp)\n```\n结果为`9223372036854775807`（64位电脑）。\n\n``` swift\nlet decimalInteger = 17\t\t//十进制表示17\nlet binaryInteger = 0b1001\t//二进制表示17\nlet octalInteger = 0o21\t\t//八进制表示17\nlet hexadecimalInteger = 0x11\t//十六进制表示17\n```\n二进制，八进制和十六进制分别加前缀`0b`，`0o`，`0x`表示。\n\n### 浮点数\n\n- Double：64位浮点数，至少15位数字\n- Float：32位浮点数，最少6位数字\n\n``` swift\nlet decimalDouble = 12.1875\t//十进制表示12.1875\nlet exponentDouble = 1.21875e1\t//十进制指数表示12.1875\nlet hexadecimalDouble = 0xC.3p0\t//十六进制指数表示12.1875\n```\n浮点数字面量可以用十进制和十六进制表示，指数分别用`e`和`p`表示。\n\n数值型字面量都可以加0或_，不影响数值，比如`000_1_000.000_000_1`等于`1000.0000001`。\n\n### 布尔值\n\n`Bool`有两个值`true`和`false`。\n\n### 可选类型\n\n>可选类型（_optionals)用来表示值可能丢失的情况：\n- 有值且等于x\n- 没有值\n\n- 有无值判断\n可以通过条件语句判断，`if optional != nil`，结果为`ture`即表示有值，否则表示无值。\n\n- 强制解析\n在名字后面加`!`强制获取可选类型的值，但必须在有值的情况下，否则会报错，`optional!`。\n\n- 可选绑定\n``` swift\nlet optionalValue: Int? = 123\nif let actualValue = optionalValue {\n} else {\n}\n```\n`Int?`在数据类型后面加`?`表示包含该数据类型的可选类型，`optionalValue`表示包含`123`的可选类型，如果包含值，则赋值给`actualValue`，并返回`true`，否则返回`false`。\n\n- 无值：nil\n``` swift\nvar optionalInt: Int? = 123\noptionalInt = nil\n\nvar optionalStr: String?\n```\n可选类型可以被赋值为nil，即表示无值，这表示一个确定的值。\n如果可选类型声明时没有赋值，则自动赋值为nil。\n\n- 隐式解析\n声明时将数据类型后面的`?`改为`!`，表示一个隐式解析可选类型，即每次自动解析，使用时可直接用常量变量名称。\n\n### 断言\n可选类型无值可能会影响程序运行，在某些特定情况下，需要终止程序，我们使用断言。\n断言类似于条件判断语句，不同点在于，结果为`false`时直接终止程序。\n``` swift\nlet age = -3\nassert(age >= 0, \"age cannot be less than zero\")\n```\n`assert`的第二个参数描述信息可以省略。\n\n### 元组\n\n元组（_tuples_）把多个数据类型组合成一个复合的数据类型。\n``` swift\nlet httpStatus1 = (statusCode: 200, description: \"OK\")\nprintln(httpStatus1.statusCode, httpStatus1.description)\n//输出“200OK”\n\nlet httpStatus2 = (200, \"OK\")\nprintln(httpStatus2.0, httpStatus2.1)\n//输出“200OK”\n\nlet (statusCode, statusMessage) = httpStatus2\nprintln(statusCode, statusMessage)\n//输出“200OK”\n\nlet (statusCode, _) = httpStatus2\nprintln(statusCode)\n//输出“200”\n```\n元组用括号`(Int, String)`表示一个整数和一个字符串组合，可以给元组的单个元素命名，比如第1行的`statusCode`和`description`，调用时直接用`httpStatus1.statusCode`和`httpStatus2.description`表示；如果不命名，则用`.0`和`.1`表示。\n也可以把元组内容分解，比如第9行，分别用`statusCode`和`statusMessage`存储元组`httpStatus2`对应的元素。分解过程中忽略的部分可用`_`表示，比如第13行，只使`statusCode`存储元组`httpStatus2`的第一个元素，忽略第二个元素。\n\n### 类型别名\n\n``` swift\ntypealias tmpType = Int\nlet tmpValue: tmpType = 4\n```\n通过`typealias`关键字，给现有的数据类型再起一个新的名字，可替代使用。\n常量`tmpValue`的数据类型就是`Int`。\n\n### 类型转换\n\n- Int，Double，Float：\n`Int16`与`Int8`不能直接相加，需要通过`Int16(Int8)`转换。\n同样，`Double`与`Int`也不能相加，也需要通过`Double(Int)`转换，如果只需要整数部分，也可以通过`Int(Double)`转换。\n\n- String，Int：\nString->Int：`String.toInt()`函数可以把`String`转换成可选类型`Int?`，因为`String`中不一定能转换成`Int`，所以得到可选类型。\nInt->String：`String(Int)`函数可以把`Int`转换成`String`。\n\n## 基本运算符\n\n### 普通运算符\n\n大部分基本运算符和主流语言一致：\n- +：加\n- -：减\n- *：乘\n- /：除\n- =：赋值\n        - 不返回值，将`if a == b`误写成`if a = b`会出现编译错误。\n        - 元组赋值，`let (x, y) = (1, 2)`，表示`x = 1`且`y = 2`。\n- %：求余\n        - 除了整数，也可以对浮点数求余，`8 % 2.5`等于`Double`值`0.5`。\n- ++：自增\n- --：自减\n        - 除了整数，浮点数也可以自增和自减。\n- -：负号\n- +：正号\n- +=, -=, *=, /=, %=：复合赋值\n- ==：等于\n- !=: 不等于\n- \\>, <, >=, <=：比较运算符\n- ===, !===：是否引用同一个对象实例\n- ? : ：三目运算符\n- &&：与\n- ||：或\n- !：非\n- ()：括号，确定运算先后顺序\n\n### 空合运算符（Nil Coalescing Operator）\n\n`a ?? b`：其中`a`必须是可选（_Optional_）类型，`b`的类型与a存储的值的类型一致。\n如果a包含一个值，就返回`a`包含的值；否则返回默认值`b`，等同于`a != nil ? a! : b`。\n\n### 区间运算符（Range Operator）\n\n`a..<b`，闭区间运算符，表示`a`到`b`的区间，包含`a`，不包含`b`；\n`a...b`，半开区间运算符，表示`a`到`b`的区间，包含`a`和`b`。\n","source":"_posts/swift_1.md","raw":"title: \"Swift基础入门(1)：常量变量，基本数据类型和基本运算符\"\ndate: 2015-07-14 15:23:13\ntags:\n- swift\ncategories: swift \ntoc: true\n---\n\nSwift是苹果公司于2014年推出的用于iOS，OS X和watchOS应用开发的新语言。\n本篇介绍Swift的基础知识：常量变量，基本数据类型和基本运算符。\n\n<!--more-->\n**Title: [Swift基础入门(1)：常量变量，基本数据类型和基本运算符](https://aidaizyy.github.io/swift_1)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-15](http://aidaizyy.github.io)**\n\n## 概要\n\nSwift结合了C和Objectiv-C的特点，基于Cocoa和Cocoa Touch框架。\n本文主要讲述Swift的基本语法。\n\n## 常量变量\n\n### 命名\n\n常量变量命名不能包括数学符号，箭头，保留的Unicode码位，连线和制表符，不能以数字开头。\n\n### 声明\n\n声明常量使用`let`关键字，声明变量使用`var`关键字。\n一般可省略数据类型，通过赋予的第一个值来自动确定数据类型。\n``` swift\nlet maxNumber = 20\nvar currentNumber = 0, item = 0.1\n```\n在swift中，语句结束不需要加分号。（添加分号也没有问题）\n上面两句，声明了常量`maxNumber`，并赋值为20，这个值不能被改变。声明时可以不赋值，但之后只能赋值一次。\n声明了变量`currentNumber`和`item`，并赋值为0和0.1，可赋值多次。\n在一行中可声明多个常量或变量，用逗号隔开。\n`maxNumber`和`currentNumber`第一次赋值了整数，被确定为整数类型`Int`；`item`第一次赋值了小数，被确定为浮点数类型`Double`（未指定数据类型时，小数一定会被确定为`Double`而不是`Float`）。\n\n> 基本数据类型：\n- Int\n- Double\n- Float\n- Bool\n- String\n- Character\n\n声明常量变量时，也可以指定数据类型，通过在常量变量名称后接冒号再接数据类型名称来实现。\n``` swift\nvar currentNumer: Double = 5\nprintln(currentNumber)\t//输出currentNumber的值\n```\n上面两句输出结果为`5.0`，因为`currentNumber`指定为`Double`类型，即使给它赋值了整数5。\n\n### 输出\n\n`println`和`print`函数都是输出函数，区别在于前者在输出末尾加上了换行符。\n\n输出常量变量：\n``` swift\nvar currentNumer: Double = 5\nprintln(\"The current number is \\(currentNumber)\")\n```\n上面两句输出结果为`The current number is 0.5`。\n通过`\\(常量变量)`将常量变量转换为字符串并在`println`语句中输出。\n\n### 注释\n\n和C语言类似，注释分为单行注释`//`和多行注释`/*  */`\n``` swift\nvar single\t//单行注释\n\n/* 多行注释 */\n```\n不一样的地方在于，swift的`/* */`可以嵌套。\n\n## 基本数据类型\n\n### 整数\n\n整数分为`Int8`，`UInt8`，`Int16`，`UInt16`，`Int32`，`UInt32`，`Int64`，`UInt64`，分别对应8，16，32，64位的有符号整数类型和无符号整数类型。\n一般`Int`指`Int32`（32位电脑）或`Int64`（64位电脑）。\n整数类型都有`min`和`max`两个方法。\n``` swift\nvar tmp = Int.max\nprintln(tmp)\n```\n结果为`9223372036854775807`（64位电脑）。\n\n``` swift\nlet decimalInteger = 17\t\t//十进制表示17\nlet binaryInteger = 0b1001\t//二进制表示17\nlet octalInteger = 0o21\t\t//八进制表示17\nlet hexadecimalInteger = 0x11\t//十六进制表示17\n```\n二进制，八进制和十六进制分别加前缀`0b`，`0o`，`0x`表示。\n\n### 浮点数\n\n- Double：64位浮点数，至少15位数字\n- Float：32位浮点数，最少6位数字\n\n``` swift\nlet decimalDouble = 12.1875\t//十进制表示12.1875\nlet exponentDouble = 1.21875e1\t//十进制指数表示12.1875\nlet hexadecimalDouble = 0xC.3p0\t//十六进制指数表示12.1875\n```\n浮点数字面量可以用十进制和十六进制表示，指数分别用`e`和`p`表示。\n\n数值型字面量都可以加0或_，不影响数值，比如`000_1_000.000_000_1`等于`1000.0000001`。\n\n### 布尔值\n\n`Bool`有两个值`true`和`false`。\n\n### 可选类型\n\n>可选类型（_optionals)用来表示值可能丢失的情况：\n- 有值且等于x\n- 没有值\n\n- 有无值判断\n可以通过条件语句判断，`if optional != nil`，结果为`ture`即表示有值，否则表示无值。\n\n- 强制解析\n在名字后面加`!`强制获取可选类型的值，但必须在有值的情况下，否则会报错，`optional!`。\n\n- 可选绑定\n``` swift\nlet optionalValue: Int? = 123\nif let actualValue = optionalValue {\n} else {\n}\n```\n`Int?`在数据类型后面加`?`表示包含该数据类型的可选类型，`optionalValue`表示包含`123`的可选类型，如果包含值，则赋值给`actualValue`，并返回`true`，否则返回`false`。\n\n- 无值：nil\n``` swift\nvar optionalInt: Int? = 123\noptionalInt = nil\n\nvar optionalStr: String?\n```\n可选类型可以被赋值为nil，即表示无值，这表示一个确定的值。\n如果可选类型声明时没有赋值，则自动赋值为nil。\n\n- 隐式解析\n声明时将数据类型后面的`?`改为`!`，表示一个隐式解析可选类型，即每次自动解析，使用时可直接用常量变量名称。\n\n### 断言\n可选类型无值可能会影响程序运行，在某些特定情况下，需要终止程序，我们使用断言。\n断言类似于条件判断语句，不同点在于，结果为`false`时直接终止程序。\n``` swift\nlet age = -3\nassert(age >= 0, \"age cannot be less than zero\")\n```\n`assert`的第二个参数描述信息可以省略。\n\n### 元组\n\n元组（_tuples_）把多个数据类型组合成一个复合的数据类型。\n``` swift\nlet httpStatus1 = (statusCode: 200, description: \"OK\")\nprintln(httpStatus1.statusCode, httpStatus1.description)\n//输出“200OK”\n\nlet httpStatus2 = (200, \"OK\")\nprintln(httpStatus2.0, httpStatus2.1)\n//输出“200OK”\n\nlet (statusCode, statusMessage) = httpStatus2\nprintln(statusCode, statusMessage)\n//输出“200OK”\n\nlet (statusCode, _) = httpStatus2\nprintln(statusCode)\n//输出“200”\n```\n元组用括号`(Int, String)`表示一个整数和一个字符串组合，可以给元组的单个元素命名，比如第1行的`statusCode`和`description`，调用时直接用`httpStatus1.statusCode`和`httpStatus2.description`表示；如果不命名，则用`.0`和`.1`表示。\n也可以把元组内容分解，比如第9行，分别用`statusCode`和`statusMessage`存储元组`httpStatus2`对应的元素。分解过程中忽略的部分可用`_`表示，比如第13行，只使`statusCode`存储元组`httpStatus2`的第一个元素，忽略第二个元素。\n\n### 类型别名\n\n``` swift\ntypealias tmpType = Int\nlet tmpValue: tmpType = 4\n```\n通过`typealias`关键字，给现有的数据类型再起一个新的名字，可替代使用。\n常量`tmpValue`的数据类型就是`Int`。\n\n### 类型转换\n\n- Int，Double，Float：\n`Int16`与`Int8`不能直接相加，需要通过`Int16(Int8)`转换。\n同样，`Double`与`Int`也不能相加，也需要通过`Double(Int)`转换，如果只需要整数部分，也可以通过`Int(Double)`转换。\n\n- String，Int：\nString->Int：`String.toInt()`函数可以把`String`转换成可选类型`Int?`，因为`String`中不一定能转换成`Int`，所以得到可选类型。\nInt->String：`String(Int)`函数可以把`Int`转换成`String`。\n\n## 基本运算符\n\n### 普通运算符\n\n大部分基本运算符和主流语言一致：\n- +：加\n- -：减\n- *：乘\n- /：除\n- =：赋值\n        - 不返回值，将`if a == b`误写成`if a = b`会出现编译错误。\n        - 元组赋值，`let (x, y) = (1, 2)`，表示`x = 1`且`y = 2`。\n- %：求余\n        - 除了整数，也可以对浮点数求余，`8 % 2.5`等于`Double`值`0.5`。\n- ++：自增\n- --：自减\n        - 除了整数，浮点数也可以自增和自减。\n- -：负号\n- +：正号\n- +=, -=, *=, /=, %=：复合赋值\n- ==：等于\n- !=: 不等于\n- \\>, <, >=, <=：比较运算符\n- ===, !===：是否引用同一个对象实例\n- ? : ：三目运算符\n- &&：与\n- ||：或\n- !：非\n- ()：括号，确定运算先后顺序\n\n### 空合运算符（Nil Coalescing Operator）\n\n`a ?? b`：其中`a`必须是可选（_Optional_）类型，`b`的类型与a存储的值的类型一致。\n如果a包含一个值，就返回`a`包含的值；否则返回默认值`b`，等同于`a != nil ? a! : b`。\n\n### 区间运算符（Range Operator）\n\n`a..<b`，闭区间运算符，表示`a`到`b`的区间，包含`a`，不包含`b`；\n`a...b`，半开区间运算符，表示`a`到`b`的区间，包含`a`和`b`。\n","slug":"swift_1","published":1,"updated":"2015-07-24T07:22:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qs90018meo3pmqta7wk"},{"title":"SPDK简介","date":"2016-08-15T15:02:27.000Z","toc":true,"_content":"\nSPDK（Storage Performance Development Kit）是Intel发布的存储性能开发工具集。\n> 原文：[《Introduction to the Storage Performance Development Kit (SPDK)》](https://software.intel.com/en-us/articles/introduction-to-the-storage-performance-development-kit-spdk)\n\n<!--more-->\n**Title: [SPDK简介](https://aidaizyy.github.io/spdk)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2016-08-16](http://aidaizyy.github.io)**\n\n\n## 简介\n固态存储媒介正在取代数据中心。目前这一代的闪存存储，比起传统的磁盘介质，在性能（performance）、功耗（power consumption）和机架密度（rack density）上具有显著的优势。这些优势将会继续增大，使闪存存储作为下一代媒介进入市场。\n\n用户使用现在的固态媒介，比如Intel P3700非易失存储器标准（Non-Volatile Memory Express, NVMe）驱动，面临一个主要的挑战：因为吞吐量和延迟性能比传统的磁盘好太多，现在总的处理时间中，存储软件占用了更大的比例。换句话说，存储软件栈的性能和效率在整个存储系统中越来越重要。随着存储媒介继续发展，它将面临远远超过正在使用的软件体系结构的风险（即存储媒介受制于相关软件的不足而不能发挥全部性能），在接下来的几年中，存储媒介将会继续发展到一个令人难以置信的地步。\n\n为了帮助存储OEM（设备代工厂）和ISV（独立软件开发商）整合硬件，Inte构造了一系列驱动和一个完善的，端对端引用存储体系结构，称为存储性能开发工具集（Storage Performance Development Kit, SPDK）。SPDK的目标是通过同时使用Intel的网络，处理器和存储技术来提高突出显著的效率和性能。通过运行为硬件设计的软件，SPDK已经证明很容易达到每秒钟数百万次I/O读取，通过使用许多处理器核心和许多NVMe驱动去存储，而不需要额外卸载硬件。Intel提供了其全部的Linux参考架构的源代码，在Intel的许可下无需付费，把用户态NVMe驱动通过01.org开源，开发工具集的其他内容将会在2016年开源。\n\n## 软件体系结构概览\nSPDK如何工作？达到这样的超高性能运用了两个关键技术：运行于用户态和轮询模式。让我们进一步了解这两个软件工程术语。\n\n首先，我们的设备驱动代码运行在用户态意味着，在定义上，驱动代码不会运行在内核中。避免内核上下文切换和中断将会节省大量的处理开销，允许更多的时钟周期被用来做实际的数据存储。无视复杂的存储算法（去冗，加密，压缩，空白块存储），更少浪费的时间周期意味着更好的性能。\n\n其次，轮询模式驱动（Polled Mode Drivers, PMDs）会持续工作，而不是被派遣工作。考虑在一个忙碌的周六晚上的市区打车，不断招手，一辆又一辆后座已经有乘客的计程车驶过。这样的等待是不可预测的，不可能说清楚花掉多少分钟之后能打到车。打车就像在传统的中断-派遣存储I/O驱动中等待一个包或一个数据块传输。另一方面，想象在机场打车的过程中，队首的计程车司机观察，只需要固定的几秒钟就可以载上乘客并驶向目的地。这就是PMDs怎么工作的，SPDK的所有组件怎么设计的。数据包和数据块被立即分派，因为等待花掉的时间变小，使得延迟更低，一致性延迟更多（抖动更少），吞吐量也得到提高。\n\nSPDK由数个子组件构成，相互连接并共享用户态和轮询模式的共有部分。当构造端对端SPDK体系结构时，每个组件被构造用于克服遭遇到的特定的性能瓶颈。然而，每个组件也可以被整合进非SPDK体系结构，允许用户使用SPDK影响经验和技术而加速他们自己的软件。举例来说，用户态网络服务（Userspace Network Services, UNS）库被构造用来克服Linux内核TCP/IP协议栈的性能限制。通过构造一个用户态，轮序模式的TCP/IP协议栈，SPDK可以通过更少的处理器时钟周期处理TCP/IP包排序和处理，获得地更高的IOPS性能。\n\n![SPDK Architecture](https://software.intel.com/sites/default/files/managed/a8/ff/introduction-to-the-storage-performance-development-kit-spdk-fig2.png)\n\n一共三种基本类型的子组件：网络前端，处理框架，后端。\n\n前端是由数据平面开发工具集（Data Plane Development Kit, DPDK）网卡驱动和UNS组成。DPDK提供一个高性能的在网卡中处理数据包的框架，提供一个从网卡到用户空间的数据到达的快速路径。然后UNS代码进行接管，破解TCP/IP数据包形成iSCSI命令。\n\n这时，处理框架得到数据包内容并翻译iSCSI命令为SCSI块级命令。然而，在它把这些命令发送到后端驱动之前，SPDK提供一个API框架增加用户特定的功能——“special sauce”，到SPDK框架中（上图绿色框内）。很多例子，包括缓存，数据的去冗和压缩，磁盘阵列（RAID），和纠删码计算。这些功能都包含在SPDK中，虽然这些功能只是为了帮助我们构建真实世界的用例，不应该和产品级实现混淆。\n\n最终，数据到达后端驱动，在这里与物理块设备交互发生，就是读或写。SPDK包括针对几种存储媒介的用户态PMDs；NVMe设备；Linux AIO设备，比如传统磁盘；基于块地址的内存应用的内存驱动（比如，RAMDISKS）；和可以用Intel I/O加速技术（Intel I/O Acceleration Technology，代号为Crystal Beach DMA，CBDMA）的设备。这套后端驱动涵盖了不同层次性能的存储设备，保证了几乎每种存储应用的相关性。\n\nSPDK不适应所有的存储体系结构。这里有一些问题可能会帮助用户决定SPDK组件是否适合他们的体系结构。\n\n**这个存储系统是否基于Linux？**\nSPDK现在只在Linux上测试和支持。\n\n**这个存储系统的高性能路径是否运行在用户态？**\nSPDK通过仅在用户态下运行从网卡到磁盘的高性能路径，提高性能和效率。\n\n**系统体系结构可以合并无锁的PMDs到它的线程模型吗？**\n因为PMD持续运行在它们的线程中（而不是睡眠或者不用时让出处理器），所以它们有特殊的线程模型需求\n\n**系统现在是否用DPDK处理网络数据包的工作负载**\nDPDK包含了SPDK的框架，所以现在使用DPDK的用户就会发现与SPDK紧密整合非常有用。\n\n**你们的许可模型可以使用非可再分发源吗？**\nSPDK的一部分是作为开源可获得的，BSD许可组件（比如NVMe和CBDMA用户态驱动）。而其他部分暂时是Intel许可下（UNS和用户态iSCSI对象），但是它肯定会改变，所有的SPDK源代码免费提供。\n\n**开发团队自己是否具有理解和解决问题的专业技能？**\nIntel没有为相关软件提供支持的义务。当Intel和围绕SPDK的开源社区将付出商业上合理的努力去调出未修改的发布版本软件的潜在错误，任何情况下Intel都没有任务义务为用户提供针对该软件任何形式的维护和支持。\n\n","source":"_posts/spdk.md","raw":"title: SPDK简介\ndate: 2016-08-15 23:02:27\ntags:\n- spdk\ncategories: spdk\ntoc: true\n---\n\nSPDK（Storage Performance Development Kit）是Intel发布的存储性能开发工具集。\n> 原文：[《Introduction to the Storage Performance Development Kit (SPDK)》](https://software.intel.com/en-us/articles/introduction-to-the-storage-performance-development-kit-spdk)\n\n<!--more-->\n**Title: [SPDK简介](https://aidaizyy.github.io/spdk)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2016-08-16](http://aidaizyy.github.io)**\n\n\n## 简介\n固态存储媒介正在取代数据中心。目前这一代的闪存存储，比起传统的磁盘介质，在性能（performance）、功耗（power consumption）和机架密度（rack density）上具有显著的优势。这些优势将会继续增大，使闪存存储作为下一代媒介进入市场。\n\n用户使用现在的固态媒介，比如Intel P3700非易失存储器标准（Non-Volatile Memory Express, NVMe）驱动，面临一个主要的挑战：因为吞吐量和延迟性能比传统的磁盘好太多，现在总的处理时间中，存储软件占用了更大的比例。换句话说，存储软件栈的性能和效率在整个存储系统中越来越重要。随着存储媒介继续发展，它将面临远远超过正在使用的软件体系结构的风险（即存储媒介受制于相关软件的不足而不能发挥全部性能），在接下来的几年中，存储媒介将会继续发展到一个令人难以置信的地步。\n\n为了帮助存储OEM（设备代工厂）和ISV（独立软件开发商）整合硬件，Inte构造了一系列驱动和一个完善的，端对端引用存储体系结构，称为存储性能开发工具集（Storage Performance Development Kit, SPDK）。SPDK的目标是通过同时使用Intel的网络，处理器和存储技术来提高突出显著的效率和性能。通过运行为硬件设计的软件，SPDK已经证明很容易达到每秒钟数百万次I/O读取，通过使用许多处理器核心和许多NVMe驱动去存储，而不需要额外卸载硬件。Intel提供了其全部的Linux参考架构的源代码，在Intel的许可下无需付费，把用户态NVMe驱动通过01.org开源，开发工具集的其他内容将会在2016年开源。\n\n## 软件体系结构概览\nSPDK如何工作？达到这样的超高性能运用了两个关键技术：运行于用户态和轮询模式。让我们进一步了解这两个软件工程术语。\n\n首先，我们的设备驱动代码运行在用户态意味着，在定义上，驱动代码不会运行在内核中。避免内核上下文切换和中断将会节省大量的处理开销，允许更多的时钟周期被用来做实际的数据存储。无视复杂的存储算法（去冗，加密，压缩，空白块存储），更少浪费的时间周期意味着更好的性能。\n\n其次，轮询模式驱动（Polled Mode Drivers, PMDs）会持续工作，而不是被派遣工作。考虑在一个忙碌的周六晚上的市区打车，不断招手，一辆又一辆后座已经有乘客的计程车驶过。这样的等待是不可预测的，不可能说清楚花掉多少分钟之后能打到车。打车就像在传统的中断-派遣存储I/O驱动中等待一个包或一个数据块传输。另一方面，想象在机场打车的过程中，队首的计程车司机观察，只需要固定的几秒钟就可以载上乘客并驶向目的地。这就是PMDs怎么工作的，SPDK的所有组件怎么设计的。数据包和数据块被立即分派，因为等待花掉的时间变小，使得延迟更低，一致性延迟更多（抖动更少），吞吐量也得到提高。\n\nSPDK由数个子组件构成，相互连接并共享用户态和轮询模式的共有部分。当构造端对端SPDK体系结构时，每个组件被构造用于克服遭遇到的特定的性能瓶颈。然而，每个组件也可以被整合进非SPDK体系结构，允许用户使用SPDK影响经验和技术而加速他们自己的软件。举例来说，用户态网络服务（Userspace Network Services, UNS）库被构造用来克服Linux内核TCP/IP协议栈的性能限制。通过构造一个用户态，轮序模式的TCP/IP协议栈，SPDK可以通过更少的处理器时钟周期处理TCP/IP包排序和处理，获得地更高的IOPS性能。\n\n![SPDK Architecture](https://software.intel.com/sites/default/files/managed/a8/ff/introduction-to-the-storage-performance-development-kit-spdk-fig2.png)\n\n一共三种基本类型的子组件：网络前端，处理框架，后端。\n\n前端是由数据平面开发工具集（Data Plane Development Kit, DPDK）网卡驱动和UNS组成。DPDK提供一个高性能的在网卡中处理数据包的框架，提供一个从网卡到用户空间的数据到达的快速路径。然后UNS代码进行接管，破解TCP/IP数据包形成iSCSI命令。\n\n这时，处理框架得到数据包内容并翻译iSCSI命令为SCSI块级命令。然而，在它把这些命令发送到后端驱动之前，SPDK提供一个API框架增加用户特定的功能——“special sauce”，到SPDK框架中（上图绿色框内）。很多例子，包括缓存，数据的去冗和压缩，磁盘阵列（RAID），和纠删码计算。这些功能都包含在SPDK中，虽然这些功能只是为了帮助我们构建真实世界的用例，不应该和产品级实现混淆。\n\n最终，数据到达后端驱动，在这里与物理块设备交互发生，就是读或写。SPDK包括针对几种存储媒介的用户态PMDs；NVMe设备；Linux AIO设备，比如传统磁盘；基于块地址的内存应用的内存驱动（比如，RAMDISKS）；和可以用Intel I/O加速技术（Intel I/O Acceleration Technology，代号为Crystal Beach DMA，CBDMA）的设备。这套后端驱动涵盖了不同层次性能的存储设备，保证了几乎每种存储应用的相关性。\n\nSPDK不适应所有的存储体系结构。这里有一些问题可能会帮助用户决定SPDK组件是否适合他们的体系结构。\n\n**这个存储系统是否基于Linux？**\nSPDK现在只在Linux上测试和支持。\n\n**这个存储系统的高性能路径是否运行在用户态？**\nSPDK通过仅在用户态下运行从网卡到磁盘的高性能路径，提高性能和效率。\n\n**系统体系结构可以合并无锁的PMDs到它的线程模型吗？**\n因为PMD持续运行在它们的线程中（而不是睡眠或者不用时让出处理器），所以它们有特殊的线程模型需求\n\n**系统现在是否用DPDK处理网络数据包的工作负载**\nDPDK包含了SPDK的框架，所以现在使用DPDK的用户就会发现与SPDK紧密整合非常有用。\n\n**你们的许可模型可以使用非可再分发源吗？**\nSPDK的一部分是作为开源可获得的，BSD许可组件（比如NVMe和CBDMA用户态驱动）。而其他部分暂时是Intel许可下（UNS和用户态iSCSI对象），但是它肯定会改变，所有的SPDK源代码免费提供。\n\n**开发团队自己是否具有理解和解决问题的专业技能？**\nIntel没有为相关软件提供支持的义务。当Intel和围绕SPDK的开源社区将付出商业上合理的努力去调出未修改的发布版本软件的潜在错误，任何情况下Intel都没有任务义务为用户提供针对该软件任何形式的维护和支持。\n\n","slug":"spdk","published":1,"updated":"2016-08-15T15:09:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qsc001bmeo3nwnlyd6a"},{"title":"Hadoop安装运行","date":"2016-05-29T06:18:57.000Z","toc":true,"_content":"\nHadoop：是一个由Apache基金会所开发的处理计算机集群上大数据的开源分布式系统基础框架。\n本文基于Mac OSX 10.11操作系统和Hadoop 2.6.4。\n\n<!--more-->\n**Title: [Hadoop安装运行](https://aidaizyy.github.io/hadoop)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2016-05-29](http://aidaizyy.github.io)**\n\n## 准备\n\n### JAVA\nHadoop是由Java实现的，所以首先确入是否已经安装Java。\n``` bash\njava -version\n```\n在终端中输入以上命令，确认是否安装Java。如果没有，可以去[Java官方网站](http://www.java.com)下载，并参照说明配置环境变量。如果已经安装Java，可以进行下一步。\n本文基于JDK 1.8安装Hadoop。官方要求至少java 1.5及其以上版本。\n\n### SSH\n其次，确认ssh安装，且sshd一直运行，以便Hadoop脚本管理远端Hadoop守护进程。\nMac系统已自带ssh，可通过以下三条命令验证。\n``` bash\nwhich ssh\nwhich sshd\nwhich ssh-Keygen\n```\n得到ssh路径。\n我们要实现无密码登录ssh。\n``` bash\nssh-keygen -t rsa\n```\n输入以上命令，需要输入密码时按enter键。\n成功后进入ssh目录。\n``` bash\ncd ~/.ssh\ncp id_rsa.pub authorized_keys\n```\n下面验证是否成功。\n``` bash\nssh localhost\n```\n如果出现\n``` bash\nssh: connect to host localhost port 22: Connection refuse\n```\n说明用户没有权限，需要去“系统偏好设置”——“共享”——“远程登录”，勾选并选择允许访问：“所有用户”。\n\n注意，在Windows系统下，需要安装Cygwin，提供shell支持。\n\n## 下载\n\n### 下载Hadoop\n前往[Apache Hadoop官方网站](http://hadoop.apache.org/releases.html)下载Hadoop发行版。本文下载了最新修改发布的2.6.4版本（2016年2月），选择[binary版本](http://www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-2.6.4/hadoop-2.6.4.tar.gz)，如果选择了source版本，压缩包后会有-src后缀，表示源码，需要额外编译。\n\n### 解开压缩包\n``` bash \ntar -xvzf hadoop-2.6.4.tar.gz\n```\n我这里将其放置的路径是~/Applications（本文的路径是/Users/zhangyunyao/Applications/hadoop-2.6.4）。\n\n### 设置环境变量\n在~/.bash_profile文件或~/.profile文件中添加环境变量（本文在zsh环境下，在~/.zshrc中添加环境变量）。\n\n**添加JAVA_HOME环境变量**\n```\nexport JAVA_HOME=`/usr/libexec/java_home`\n```\n将上面句子加在环境变量文件末尾，并用source命令更新。\n``` bash\nsource .zshrc\n```\n验证JAVA_HOME环境变量是否设置成功。\n``` bash\necho $JAVA_HOME\n```\n如果返回Java路径则说明设置成功。\n\n**添加HADOOP_HOME环境变量**\n``` \nexport HADOOP_HOME=/Users/zhangyunyao/Applications/hadoop-2.6.4\n```\n将上面句子加载环境变量文件末尾，同样可以用source命令更新和echo命令验证。\n\n**添加其他可能用到的环境变量** \n``` \nexport PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin\nexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib\n```\n\n## 配置\n进入hadoop-2.6.4目录后，主要配置四个文件（hadoop-env.sh，core-site.xml，mapred-site.xml，hdfs-site.xml），很多资料显示这四个文件在conf目录里。但在Hadoop 2.5以后，这四个文件都在etc/hadoop文件夹下。\n``` bash\ncd hadoop-2.6.4/etc/hadoop\n```\n\n### 编辑hadoop-env.sh文件\n该文件涉及Hadoop的配置。\n``` \nexport JAVA_HOME=${JAVA_HOME}\n```\n因为我们在环境配置中已经设置了JAVA_HOME的值，所以这里可以不用修改。\n```\n#export HADOOP_HEADSIZE=\n```\n表示Hadoop堆可用的最大大小，默认是1000MB。没有特殊需求，可以不用修改。修改的话去掉注释符号“#”，并在“=”后面加上数字，比如“=2000”，表示2000MB。\n```\nexport HADOOP_OPTS=\"$HADOOP_OPTS -Djava.net.preferIPv4Stack=true\"\n```\n已经有默认值，暂时不需要修改。\n\n### 编辑core-site.xml文件\n参考官方提供的默认文件[core-default.xml](http://hadoop.apache.org/docs/r2.6.4/hadoop-project-dist/hadoop-common/core-default.xml)，其他版本都可以在官网找到对应的默认文件。\n“hadoop.tmp.dir”表示临时目录，“fs.default.name”表示缺省的文件URI标识，这里设置了主机名和端口。\n```\n<configuration>\n \t<property>\n    \t\t<name>hadoop.tmp.dir</name>\n    \t\t<value>/Users/zhangyunyao/Applications/hadoop-2.6.4/tmp/hadoop-${user.name}</value>\n    \t\t<description>A base for other temporary directories.</description>\n  \t</property>\n  \t<property>\n    \t\t<name>fs.default.name</name>\n    \t\t<value>hdfs://localhost:9000</value>\n  \t</property>\n</configuration>\n```\n\n### 编辑hdfs-site.xml文件\n参考官方提供的默认文件[hdfs-default.xml](http://hadoop.apache.org/docs/r2.6.4/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml)，其他版本都可以在官网找到对应的默认文件。\n“dfs.replication”表示缺省的块复制数量，因为这里只有一个节点，所以值设为1。\n```\n<configuration>\n    \t<property>\n        \t<name>dfs.replication</name>\n        \t<value>1</value>\n    \t</property>\n</configuration>\n```\n\n### 编辑mapred-site.xml文件\n参考官方提供的默认文件[mapred-default.xml](http://hadoop.apache.org/docs/r2.6.4/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml)，其他版本都可以在官网找到对应的默认文件。\n“mapreduce.jobtracker.address”表示JobTracker作业跟踪器的地址，这里设置了它的主机名和端口。\n```\n<configuration>\n\t<property>\n\t\t<name>mapreduce.jobtracker.address</name>\n\t\t<value>localhost:9001</value>\n\t\t<description>The address of JobTracker</description>\n\t</property>\n</configuration>\n```\n注意hadoop-2.6.4/etc/hadoop目录下是没有mapred-site.xml文件的，只有mapred-site.xml.temple。我们需要把该文件复制一份，并命令为mapred-site.xml。\n``` bash\ncp mapred-site.xml.tmple mapred-site.xml\n```\n\n## 安装HDFS\n``` bash\nhadoop namenode -format\n```\n在Hadoop目录内输入以上命令。\n\n## 运行\n运行hadoop-2.6.4/sbin目录下的start-all.sh脚本。\n``` bash\n./start-all.sh\n```\n输入命令``jps``验证是否成功运行Hadoop。\n在本机上出现如下信息：\n``` \n30417 SecondaryNameNode\n30610 Jps\n30324 DataNode\n30571 NodeManager\n29660 ResourceManager\n30253 NameNode\n```\n说明Hadoop已经成功运行。\n\n运行自带的例子验证。\n``` bash\nhadoop jar $HADOOP_HOME/share/hadoop/madreduce/hadoop-mapreduce-examples-2.6.4.jar pi 10 100\n```\n出现以下信息：\n```\nNumber of Maps  = 10\nSamples per Map = 100\nWrote input for Map #0\nWrote input for Map #1\nWrote input for Map #2\nWrote input for Map #3\nWrote input for Map #4\nWrote input for Map #5\nWrote input for Map #6\nWrote input for Map #7\nWrote input for Map #8\nWrote input for Map #9\nStarting Job\n……\nJob Finished in 1.749 seconds\nEstimated value of Pi is 3.14800000000000000000\n```\n说明自带的例子hadoop-mapreduce-examples-2.6.4.jar已经成功运行，至此确认Hadoop已经成功安装。\n\n","source":"_posts/hadoop.md","raw":"title: \"Hadoop安装运行\"\ndate: 2016-05-29 14:18:57\ntags:\n- hadoop\n- java\ncategories: hadoop \ntoc: true\n---\n\nHadoop：是一个由Apache基金会所开发的处理计算机集群上大数据的开源分布式系统基础框架。\n本文基于Mac OSX 10.11操作系统和Hadoop 2.6.4。\n\n<!--more-->\n**Title: [Hadoop安装运行](https://aidaizyy.github.io/hadoop)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2016-05-29](http://aidaizyy.github.io)**\n\n## 准备\n\n### JAVA\nHadoop是由Java实现的，所以首先确入是否已经安装Java。\n``` bash\njava -version\n```\n在终端中输入以上命令，确认是否安装Java。如果没有，可以去[Java官方网站](http://www.java.com)下载，并参照说明配置环境变量。如果已经安装Java，可以进行下一步。\n本文基于JDK 1.8安装Hadoop。官方要求至少java 1.5及其以上版本。\n\n### SSH\n其次，确认ssh安装，且sshd一直运行，以便Hadoop脚本管理远端Hadoop守护进程。\nMac系统已自带ssh，可通过以下三条命令验证。\n``` bash\nwhich ssh\nwhich sshd\nwhich ssh-Keygen\n```\n得到ssh路径。\n我们要实现无密码登录ssh。\n``` bash\nssh-keygen -t rsa\n```\n输入以上命令，需要输入密码时按enter键。\n成功后进入ssh目录。\n``` bash\ncd ~/.ssh\ncp id_rsa.pub authorized_keys\n```\n下面验证是否成功。\n``` bash\nssh localhost\n```\n如果出现\n``` bash\nssh: connect to host localhost port 22: Connection refuse\n```\n说明用户没有权限，需要去“系统偏好设置”——“共享”——“远程登录”，勾选并选择允许访问：“所有用户”。\n\n注意，在Windows系统下，需要安装Cygwin，提供shell支持。\n\n## 下载\n\n### 下载Hadoop\n前往[Apache Hadoop官方网站](http://hadoop.apache.org/releases.html)下载Hadoop发行版。本文下载了最新修改发布的2.6.4版本（2016年2月），选择[binary版本](http://www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-2.6.4/hadoop-2.6.4.tar.gz)，如果选择了source版本，压缩包后会有-src后缀，表示源码，需要额外编译。\n\n### 解开压缩包\n``` bash \ntar -xvzf hadoop-2.6.4.tar.gz\n```\n我这里将其放置的路径是~/Applications（本文的路径是/Users/zhangyunyao/Applications/hadoop-2.6.4）。\n\n### 设置环境变量\n在~/.bash_profile文件或~/.profile文件中添加环境变量（本文在zsh环境下，在~/.zshrc中添加环境变量）。\n\n**添加JAVA_HOME环境变量**\n```\nexport JAVA_HOME=`/usr/libexec/java_home`\n```\n将上面句子加在环境变量文件末尾，并用source命令更新。\n``` bash\nsource .zshrc\n```\n验证JAVA_HOME环境变量是否设置成功。\n``` bash\necho $JAVA_HOME\n```\n如果返回Java路径则说明设置成功。\n\n**添加HADOOP_HOME环境变量**\n``` \nexport HADOOP_HOME=/Users/zhangyunyao/Applications/hadoop-2.6.4\n```\n将上面句子加载环境变量文件末尾，同样可以用source命令更新和echo命令验证。\n\n**添加其他可能用到的环境变量** \n``` \nexport PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin\nexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib\n```\n\n## 配置\n进入hadoop-2.6.4目录后，主要配置四个文件（hadoop-env.sh，core-site.xml，mapred-site.xml，hdfs-site.xml），很多资料显示这四个文件在conf目录里。但在Hadoop 2.5以后，这四个文件都在etc/hadoop文件夹下。\n``` bash\ncd hadoop-2.6.4/etc/hadoop\n```\n\n### 编辑hadoop-env.sh文件\n该文件涉及Hadoop的配置。\n``` \nexport JAVA_HOME=${JAVA_HOME}\n```\n因为我们在环境配置中已经设置了JAVA_HOME的值，所以这里可以不用修改。\n```\n#export HADOOP_HEADSIZE=\n```\n表示Hadoop堆可用的最大大小，默认是1000MB。没有特殊需求，可以不用修改。修改的话去掉注释符号“#”，并在“=”后面加上数字，比如“=2000”，表示2000MB。\n```\nexport HADOOP_OPTS=\"$HADOOP_OPTS -Djava.net.preferIPv4Stack=true\"\n```\n已经有默认值，暂时不需要修改。\n\n### 编辑core-site.xml文件\n参考官方提供的默认文件[core-default.xml](http://hadoop.apache.org/docs/r2.6.4/hadoop-project-dist/hadoop-common/core-default.xml)，其他版本都可以在官网找到对应的默认文件。\n“hadoop.tmp.dir”表示临时目录，“fs.default.name”表示缺省的文件URI标识，这里设置了主机名和端口。\n```\n<configuration>\n \t<property>\n    \t\t<name>hadoop.tmp.dir</name>\n    \t\t<value>/Users/zhangyunyao/Applications/hadoop-2.6.4/tmp/hadoop-${user.name}</value>\n    \t\t<description>A base for other temporary directories.</description>\n  \t</property>\n  \t<property>\n    \t\t<name>fs.default.name</name>\n    \t\t<value>hdfs://localhost:9000</value>\n  \t</property>\n</configuration>\n```\n\n### 编辑hdfs-site.xml文件\n参考官方提供的默认文件[hdfs-default.xml](http://hadoop.apache.org/docs/r2.6.4/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml)，其他版本都可以在官网找到对应的默认文件。\n“dfs.replication”表示缺省的块复制数量，因为这里只有一个节点，所以值设为1。\n```\n<configuration>\n    \t<property>\n        \t<name>dfs.replication</name>\n        \t<value>1</value>\n    \t</property>\n</configuration>\n```\n\n### 编辑mapred-site.xml文件\n参考官方提供的默认文件[mapred-default.xml](http://hadoop.apache.org/docs/r2.6.4/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml)，其他版本都可以在官网找到对应的默认文件。\n“mapreduce.jobtracker.address”表示JobTracker作业跟踪器的地址，这里设置了它的主机名和端口。\n```\n<configuration>\n\t<property>\n\t\t<name>mapreduce.jobtracker.address</name>\n\t\t<value>localhost:9001</value>\n\t\t<description>The address of JobTracker</description>\n\t</property>\n</configuration>\n```\n注意hadoop-2.6.4/etc/hadoop目录下是没有mapred-site.xml文件的，只有mapred-site.xml.temple。我们需要把该文件复制一份，并命令为mapred-site.xml。\n``` bash\ncp mapred-site.xml.tmple mapred-site.xml\n```\n\n## 安装HDFS\n``` bash\nhadoop namenode -format\n```\n在Hadoop目录内输入以上命令。\n\n## 运行\n运行hadoop-2.6.4/sbin目录下的start-all.sh脚本。\n``` bash\n./start-all.sh\n```\n输入命令``jps``验证是否成功运行Hadoop。\n在本机上出现如下信息：\n``` \n30417 SecondaryNameNode\n30610 Jps\n30324 DataNode\n30571 NodeManager\n29660 ResourceManager\n30253 NameNode\n```\n说明Hadoop已经成功运行。\n\n运行自带的例子验证。\n``` bash\nhadoop jar $HADOOP_HOME/share/hadoop/madreduce/hadoop-mapreduce-examples-2.6.4.jar pi 10 100\n```\n出现以下信息：\n```\nNumber of Maps  = 10\nSamples per Map = 100\nWrote input for Map #0\nWrote input for Map #1\nWrote input for Map #2\nWrote input for Map #3\nWrote input for Map #4\nWrote input for Map #5\nWrote input for Map #6\nWrote input for Map #7\nWrote input for Map #8\nWrote input for Map #9\nStarting Job\n……\nJob Finished in 1.749 seconds\nEstimated value of Pi is 3.14800000000000000000\n```\n说明自带的例子hadoop-mapreduce-examples-2.6.4.jar已经成功运行，至此确认Hadoop已经成功安装。\n\n","slug":"hadoop","published":1,"updated":"2016-05-29T14:55:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qse001gmeo3den82wii"},{"title":"DPDK-l2fwd详解","date":"2015-03-31T05:59:13.000Z","toc":true,"_content":"\nL2 forwarding sample application在DPDK（Data Plane Development Kit）的基础上实现了第二层（链路层）的数据包转发。\n\n<!--more-->\n**Title: [dpdk-l2fwd详解](http://aidaizyy.github.io/dpdk_l2fwd)**\n**Author: [Yunyao Zhang（张云尧）](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-04-15](http://aidaizyy.github.io)**\n\n## 概要\n\n版本：DPDK-1.8.0\n\n本例中实现了相邻端口之间的相互转发。\n比如一共4个端口可用，那么端口1收到数据后会转发给端口2，端口2收到数据后会转发给端口1，端口3和端口4也会相互转发。\n\n## 编译\n\n设置环境变量\n``` bash\nexport RTE_SDK=/(RTE_SDK) #DPDK的路径\nexport RTE_TARGET=x86_64-native-linuxapp-gcc #DPDK的编译目标\n```\n\n进入示例目录\n``` bash\ncd /(RTE_SDK)/example/l2wfd\n```\n\n编译\n``` bash\nmake\n```\n\n## 运行\n\n``` bash\n./build/l2wfd [EAL options] -- -p PORTMASK [-q NQ -T t]\n```\n\n- EAL options\n\t- DPDK EAL的默认参数，必须参数为-c COREMASK -n NUM。\n\t- COREMASK：一个十六进制位掩码表示分配的逻辑内核数量。\n\t- NUM：一个十进制整数表示内存通道数量。\n\n- -p PORTMASK\n\tPORTMASK：一个十六进制位掩码表示分配的端口数量。\n\n- -q NQ\n\tNQ：表示分配给每个逻辑内核的收发队列数量。\n\n- -T t\n\tt: 表示打印统计数据到屏幕上的时间间隔，默认为10秒。\n\n``` bash\n./build/l2fwd -c f -n 4 -- -q 4 -p ffff\n```\n表示，分配给4个逻辑内核，每个内核分别有4个收发队列，而一共分配了16个端口。\n\n## 详解\n\n### 初始化EAL(Environment Abstraciton Layer)\n``` C\n\tret = rte_eal_init(argc, argv);\n\tif (ret < 0)\n\t\trte_exit(EXIT_FAILURE, \"Invalid EAL arguments\\n\");\n```\n\n### 参数传递\n``` C\n\tret = l2fwd_parse_args(argc, argv);\n\tif (ret < 0)\n\t\trte_exit(EXIT_FAILURE, \"Invalid L2FWD arguments\\n\");\n```\nEAL参数传递已经在rte_eal_init()函数中完成了，这里主要传递“--”后面的参数。\n传递参数之后，得到三个变量。\n- l2fwd_enabled_port_mask：可用端口位掩码\n- l2fwd_rx_queue_per_lcore：每个逻辑内核的收取队列数量\n- timer_period：打印统计数据的时间间隔\n\n### 创建内存池\n``` C\n\tl2fwd_pktmbuf_pool =\n\t\trte_mempool_create(\"mbuf_pool\", NB_MBUF,\n\t\t\t\t   MBUF_SIZE, 32,\n\t\t\t\t   sizeof(struct rte_pktmbuf_pool_private),\n\t\t\t\t   rte_pktmbuf_pool_init, NULL,\n\t\t\t\t   rte_pktmbuf_init, NULL,\n\t\t\t\t   rte_socket_id(), 0);\n\tif (l2fwd_pktmbuf_pool == NULL)\n\t\trte_exit(EXIT_FAILURE, \"Cannot init mbuf pool\\n\");\n```\n- \"mbuf_pool\"：内存池的名称\n- NB_MBUF：内存池中存储mbuf的数量\n- MBUF_SIZE: mbuf的大小\n- 32：内存池缓存的大小\n\n### 端口处理\n``` C\n\t//rte_eth_dev_count()函数返回端口总数\n\tnb_ports = rte_eth_dev_count();\n\tif (nb_ports == 0)\n\t\trte_exit(EXIT_FAILURE, \"No Ethernet ports - bye\\n\");\n\n\tif (nb_ports > RTE_MAX_ETHPORTS)\n\t\tnb_ports = RTE_MAX_ETHPORTS;\n```\n``` C\n\tfor (portid = 0; portid < nb_ports; portid++) {\n\t\t//跳过未分配或者不可用端口\n\t\tif ((l2fwd_enabled_port_mask & (1 << portid)) == 0)\n\t\t\tcontinue;\n\t}\n```\n可用端口位掩码表示，左数第n位如果为1，表示端口n可用，如果左数第n位如果为0，表示端口n不可用。\n要得到第x位为1还是0，我们的方法是将1左移x位，得到一个只在x位为1，其他位都为0的数，再与位掩码相与。结果为1，那么第x位为1，结果位0，那么第x位为0.\n\n### 设置每个端口的目的端口\n这里设置数据包进入端口后，转发给相邻的端口。\n每两个端口为一对，相互转发。\n``` C\n\tfor (portid = 0; portid < nb_ports; portid++) {\n\t\tif ((l2fwd_enabled_port_mask & (1 << portid)) == 0)\n\t\t\tcontinue;\n\n\t\tif (nb_ports_in_mask % 2) {\n\t\t\tl2fwd_dst_ports[portid] = last_port;\n\t\t\tl2fwd_dst_ports[last_port] = portid;\n\t\t}\n\t\telse\n\t\t\tlast_port = portid;\n\n\t\tnb_ports_in_mask++;\n\n\t\trte_eth_dev_info_get(portid, &dev_info);\n\t}\n\tif (nb_ports_in_mask % 2) {\n\t\tprintf(\"Notice: odd number of ports in portmask.\\n\");\n\t\tl2fwd_dst_ports[last_port] = last_port;\n\t}\n```\n\n### 初始化端口的配置信息\n为每个端口分配到相应的逻辑内核\n每个端口只对应一个逻辑内核\n每个逻辑内核对应l2fwd_rx_queue_per_lcore个端口\n``` C\n\tfor (portid = 0; portid < nb_ports; portid++) {\n\t\tif ((l2fwd_enabled_port_mask & (1 << portid)) == 0)\n\t\t\tcontinue;\n\n\t\t//得到一个收取队列未分配满且可用的逻辑内核\n\t\twhile (rte_lcore_is_enabled(rx_lcore_id) == 0 ||\n\t\t       lcore_queue_conf[rx_lcore_id].n_rx_port ==\n\t\t       l2fwd_rx_queue_per_lcore) {\n\t\t\trx_lcore_id++;\n\t\t\tif (rx_lcore_id >= RTE_MAX_LCORE)\n\t\t\t\trte_exit(EXIT_FAILURE, \"Not enough cores\\n\");\n\t\t}\n\n\t\tif (qconf != &lcore_queue_conf[rx_lcore_id])\n\t\t\t/* Assigned a new logical core in the loop above. */\n\t\t\tqconf = &lcore_queue_conf[rx_lcore_id];\n\n\t\tqconf->rx_port_list[qconf->n_rx_port] = portid;\n\t\tqconf->n_rx_port++;\n\t\tprintf(\"Lcore %u: RX port %u\\n\", rx_lcore_id, (unsigned) portid);\n\t}\n```\n\n### 初始化每个端口\n``` C\n\tfor (portid = 0; portid < nb_ports; portid++) {\n\t\tif ((l2fwd_enabled_port_mask & (1 << portid)) == 0) {\n\t\t\tprintf(\"Skipping disabled port %u\\n\", (unsigned) portid);\n\t\t\tnb_ports_available--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"Initializing port %u... \", (unsigned) portid);\n\t\tfflush(stdout);\n\t\t//初始化端口，第二个参数和第三个参数表示分配收取队列和发送队列的数量\n\t\tret = rte_eth_dev_configure(portid, 1, 1, &port_conf);\n\t\tif (ret < 0)\n\t\t\trte_exit(EXIT_FAILURE, \"Cannot configure device: err=%d, port=%u\\n\",\n\t\t\t\t  ret, (unsigned) portid);\n\n\t\t//得到端口对应的mac地址，存入l2fwd_ports_eth_addr[]数组\n\t\trte_eth_macaddr_get(portid,&l2fwd_ports_eth_addr[portid]);\n\n\t\tfflush(stdout);\n\t\t//初始化一个收取队列，nb_rxd指收取队列的大小，最大能够存储mbuf的数量\n\t\tret = rte_eth_rx_queue_setup(portid, 0, nb_rxd,\n\t\t\t\t\t     rte_eth_dev_socket_id(portid),\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     l2fwd_pktmbuf_pool);\n\t\tif (ret < 0)\n\t\t\trte_exit(EXIT_FAILURE, \"rte_eth_rx_queue_setup:err=%d, port=%u\\n\",\n\t\t\t\t  ret, (unsigned) portid);\n\n\t\tfflush(stdout);\n\t\t//初始化一个发送队列，nb_txd指发送队列的大小，最大能够存储mbuf的数量\n\t\tret = rte_eth_tx_queue_setup(portid, 0, nb_txd,\n\t\t\t\trte_eth_dev_socket_id(portid),\n\t\t\t\tNULL);\n\t\tif (ret < 0)\n\t\t\trte_exit(EXIT_FAILURE, \"rte_eth_tx_queue_setup:err=%d, port=%u\\n\",\n\t\t\t\tret, (unsigned) portid);\n\n\t\t//开始运行该端口\n\t\tret = rte_eth_dev_start(portid);\n\t\tif (ret < 0)\n\t\t\trte_exit(EXIT_FAILURE, \"rte_eth_dev_start:err=%d, port=%u\\n\",\n\t\t\t\t  ret, (unsigned) portid);\n\n\t\tprintf(\"done: \\n\");\n\n\t\trte_eth_promiscuous_enable(portid);\n\n\t\tprintf(\"Port %u, MAC address: %02X:%02X:%02X:%02X:%02X:%02X\\n\\n\",\n\t\t\t\t(unsigned) portid,\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[0],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[1],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[2],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[3],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[4],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[5]);\n\n\t\t//初始化端口的统计数据\n\t\tmemset(&port_statistics, 0, sizeof(port_statistics));\n\t}\n```\n\n### 检查每个端口的连接状态\n``` C\n\tcheck_all_ports_link_status(nb_ports, l2fwd_enabled_port_mask);\n```\n\n### 在每个逻辑内核上启动线程，开始转发\n``` C\n\trte_eal_mp_remote_launch(l2fwd_launch_one_lcore, NULL, CALL_MASTER);\n\tRTE_LCORE_FOREACH_SLAVE(lcore_id) {\n\t\tif (rte_eal_wait_lcore(lcore_id) < 0)\n\t\t\treturn -1;\n\t}\n```\n\n收包\n``` C\n\tfor (i = 0; i < qconf->n_rx_port; i++) {\n\n\t\tportid = qconf->rx_port_list[i];\n\t\t//收包，一次最多收取MAX_PKT_BURST个数据包\n\t\tnb_rx = rte_eth_rx_burst((uint8_t) portid, 0,\n\t\t\t\t\t pkts_burst, MAX_PKT_BURST);\n\t\t\n\t\t//更新统计数据\n\t\tport_statistics[portid].rx += nb_rx;\n\n\t\tfor (j = 0; j < nb_rx; j++) {\n\t\t\tm = pkts_burst[j];\n\t\t\trte_prefetch0(rte_pktmbuf_mtod(m, void *));\n\t\t\t//转发\n\t\t\tl2fwd_simple_forward(m, portid);\n\t\t}\n\t}\n```\n\n转发\n替换源MAC地址和目的MAC地址\n``` C\n\tstatic void\n\tl2fwd_simple_forward(struct rte_mbuf *m, unsigned portid)\n\t{\n\t\tstruct ether_hdr *eth;\n\t\tvoid *tmp;\n\t\tunsigned dst_port;\n\n\t\tdst_port = l2fwd_dst_ports[portid];\n\t\teth = rte_pktmbuf_mtod(m, struct ether_hdr *);\n\n\t\t//目的地址\n\t\t/* 02:00:00:00:00:xx */\n\t\ttmp = &eth->d_addr.addr_bytes[0];\n\t\t*((uint64_t *)tmp) = 0x000000000002 + ((uint64_t)dst_port << 40);\n\n\t\t//源地址\n\t\tether_addr_copy(&l2fwd_ports_eth_addr[dst_port], &eth->s_addr);\n\n\t\tl2fwd_send_packet(m, (uint8_t) dst_port);\n\t}\n```\n\n将数据包推送至发送队列，如果发送队列存够MAX_PKT_BURST，即每次最大收取包的数量，就会发包\n``` C\n\tstatic int\n\tl2fwd_send_packet(struct rte_mbuf *m, uint8_t port)\n\t{\n\t\tunsigned lcore_id, len;\n\t\tstruct lcore_queue_conf *qconf;\n\n\t\tlcore_id = rte_lcore_id();\n\n\t\tqconf = &lcore_queue_conf[lcore_id];\n\t\tlen = qconf->tx_mbufs[port].len;\n\t\tqconf->tx_mbufs[port].m_table[len] = m;\n\t\tlen++;\n\n\t\t//当发包队列存够MAX_PKT_BURST，发包\n\t\tif (unlikely(len == MAX_PKT_BURST)) {\n\t\t\tl2fwd_send_burst(qconf, MAX_PKT_BURST, port);\n\t\t\tlen = 0;\n\t\t}\n\n\t\tqconf->tx_mbufs[port].len = len;\n\t\treturn 0;\n\t}\n```\n\n每隔一定时间也会发包\n``` C\n\t//上次收包时间和这次收包时间差\n\tdiff_tsc = cur_tsc - prev_tsc;\n\t//如果时间差大于我们设定的阈值，这里是100us\n\tif (unlikely(diff_tsc > drain_tsc)) {\n\n\t\tfor (portid = 0; portid < RTE_MAX_ETHPORTS; portid++) {\t\t\t\n\t\t\tif (qconf->tx_mbufs[portid].len == 0)\n\t\t\t\tcontinue;\n\t\t\t//发包\n\t\t\tl2fwd_send_burst(&lcore_queue_conf[lcore_id],\n\t\t\t\t\t qconf->tx_mbufs[portid].len,\n\t\t\t\t\t (uint8_t) portid);\n\t\t\t\t\tqconf->tx_mbufs[portid].len = 0;\n\t\t}\n\t\t\n\t\tif (timer_period > 0) {\n\t\t\t\t\n\t\t\ttimer_tsc += diff_tsc;\n\n\t\t\t//如果累积时间超过我们设定的阈值，就打印出统计数据，默认是10s\n\t\t\tif (unlikely(timer_tsc >= (uint64_t) timer_period)) {\n\n\t\t\t\t//打印数据在发生在主逻辑内核上\n\t\t\t\tif (lcore_id == rte_get_master_lcore()) {\n\t\t\t\t\t//打印统计数据\n\t\t\t\t\tprint_stats();\n\t\t\t\t\t//累积时间置零\n\t\t\t\t\ttimer_tsc = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprev_tsc = cur_tsc;\n\t}\n```\n这两种情况都会产生发包，无论是发送队列存够阈值MAX_PKT_BURST，或者，时间差超过阈值brain_tsc，都会把发送队列上MAX_PKT_BURST个数据包推送出去，如果不足MAX_PKT_BURST，则把发送队列上全部数据包推送出去。\n\n发包函数\n``` C\n\tstatic int\n\tl2fwd_send_burst(struct lcore_queue_conf *qconf, unsigned n, uint8_t port)\n\t{\n\t\tstruct rte_mbuf **m_table;\n\t\tunsigned ret;\n\t\tunsigned queueid =0;\n\n\t\tm_table = (struct rte_mbuf **)qconf->tx_mbufs[port].m_table;\n\t\t//发包\n\t\tret = rte_eth_tx_burst(port, (uint16_t) queueid, m_table, (uint16_t) n);\n\t\t//更新统计数据\n\t\tport_statistics[port].tx += ret;\n\t\t//丢包\n\t\tif (unlikely(ret < n)) {\n\t\t\t//更新统计数据\n\t\t\tport_statistics[port].dropped += (n - ret);\n\t\t\tdo {\n\t\t\t\t//把丢包部分free掉\n\t\t\t\trte_pktmbuf_free(m_table[ret]);\n\t\t\t} while (++ret < n);\n\t\t}\n\n\t\treturn 0;\n\t}\n```\n在函数rte_eth_tx_burst()中：\n- port：端口号。\n- queueid：端口中的发送队列号。本例中每个端口都只有一个发送队列，所以固定为0。\n- m_table：**rte_mbuf数据\n- n：发送包的数量\n\n","source":"_posts/dpdk_l2fwd.md","raw":"title: DPDK-l2fwd详解\ndate: 2015-03-31 13:59:13\ntags: \n- dpdk\ncategories: dpdk\ntoc: true\n---\n\nL2 forwarding sample application在DPDK（Data Plane Development Kit）的基础上实现了第二层（链路层）的数据包转发。\n\n<!--more-->\n**Title: [dpdk-l2fwd详解](http://aidaizyy.github.io/dpdk_l2fwd)**\n**Author: [Yunyao Zhang（张云尧）](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-04-15](http://aidaizyy.github.io)**\n\n## 概要\n\n版本：DPDK-1.8.0\n\n本例中实现了相邻端口之间的相互转发。\n比如一共4个端口可用，那么端口1收到数据后会转发给端口2，端口2收到数据后会转发给端口1，端口3和端口4也会相互转发。\n\n## 编译\n\n设置环境变量\n``` bash\nexport RTE_SDK=/(RTE_SDK) #DPDK的路径\nexport RTE_TARGET=x86_64-native-linuxapp-gcc #DPDK的编译目标\n```\n\n进入示例目录\n``` bash\ncd /(RTE_SDK)/example/l2wfd\n```\n\n编译\n``` bash\nmake\n```\n\n## 运行\n\n``` bash\n./build/l2wfd [EAL options] -- -p PORTMASK [-q NQ -T t]\n```\n\n- EAL options\n\t- DPDK EAL的默认参数，必须参数为-c COREMASK -n NUM。\n\t- COREMASK：一个十六进制位掩码表示分配的逻辑内核数量。\n\t- NUM：一个十进制整数表示内存通道数量。\n\n- -p PORTMASK\n\tPORTMASK：一个十六进制位掩码表示分配的端口数量。\n\n- -q NQ\n\tNQ：表示分配给每个逻辑内核的收发队列数量。\n\n- -T t\n\tt: 表示打印统计数据到屏幕上的时间间隔，默认为10秒。\n\n``` bash\n./build/l2fwd -c f -n 4 -- -q 4 -p ffff\n```\n表示，分配给4个逻辑内核，每个内核分别有4个收发队列，而一共分配了16个端口。\n\n## 详解\n\n### 初始化EAL(Environment Abstraciton Layer)\n``` C\n\tret = rte_eal_init(argc, argv);\n\tif (ret < 0)\n\t\trte_exit(EXIT_FAILURE, \"Invalid EAL arguments\\n\");\n```\n\n### 参数传递\n``` C\n\tret = l2fwd_parse_args(argc, argv);\n\tif (ret < 0)\n\t\trte_exit(EXIT_FAILURE, \"Invalid L2FWD arguments\\n\");\n```\nEAL参数传递已经在rte_eal_init()函数中完成了，这里主要传递“--”后面的参数。\n传递参数之后，得到三个变量。\n- l2fwd_enabled_port_mask：可用端口位掩码\n- l2fwd_rx_queue_per_lcore：每个逻辑内核的收取队列数量\n- timer_period：打印统计数据的时间间隔\n\n### 创建内存池\n``` C\n\tl2fwd_pktmbuf_pool =\n\t\trte_mempool_create(\"mbuf_pool\", NB_MBUF,\n\t\t\t\t   MBUF_SIZE, 32,\n\t\t\t\t   sizeof(struct rte_pktmbuf_pool_private),\n\t\t\t\t   rte_pktmbuf_pool_init, NULL,\n\t\t\t\t   rte_pktmbuf_init, NULL,\n\t\t\t\t   rte_socket_id(), 0);\n\tif (l2fwd_pktmbuf_pool == NULL)\n\t\trte_exit(EXIT_FAILURE, \"Cannot init mbuf pool\\n\");\n```\n- \"mbuf_pool\"：内存池的名称\n- NB_MBUF：内存池中存储mbuf的数量\n- MBUF_SIZE: mbuf的大小\n- 32：内存池缓存的大小\n\n### 端口处理\n``` C\n\t//rte_eth_dev_count()函数返回端口总数\n\tnb_ports = rte_eth_dev_count();\n\tif (nb_ports == 0)\n\t\trte_exit(EXIT_FAILURE, \"No Ethernet ports - bye\\n\");\n\n\tif (nb_ports > RTE_MAX_ETHPORTS)\n\t\tnb_ports = RTE_MAX_ETHPORTS;\n```\n``` C\n\tfor (portid = 0; portid < nb_ports; portid++) {\n\t\t//跳过未分配或者不可用端口\n\t\tif ((l2fwd_enabled_port_mask & (1 << portid)) == 0)\n\t\t\tcontinue;\n\t}\n```\n可用端口位掩码表示，左数第n位如果为1，表示端口n可用，如果左数第n位如果为0，表示端口n不可用。\n要得到第x位为1还是0，我们的方法是将1左移x位，得到一个只在x位为1，其他位都为0的数，再与位掩码相与。结果为1，那么第x位为1，结果位0，那么第x位为0.\n\n### 设置每个端口的目的端口\n这里设置数据包进入端口后，转发给相邻的端口。\n每两个端口为一对，相互转发。\n``` C\n\tfor (portid = 0; portid < nb_ports; portid++) {\n\t\tif ((l2fwd_enabled_port_mask & (1 << portid)) == 0)\n\t\t\tcontinue;\n\n\t\tif (nb_ports_in_mask % 2) {\n\t\t\tl2fwd_dst_ports[portid] = last_port;\n\t\t\tl2fwd_dst_ports[last_port] = portid;\n\t\t}\n\t\telse\n\t\t\tlast_port = portid;\n\n\t\tnb_ports_in_mask++;\n\n\t\trte_eth_dev_info_get(portid, &dev_info);\n\t}\n\tif (nb_ports_in_mask % 2) {\n\t\tprintf(\"Notice: odd number of ports in portmask.\\n\");\n\t\tl2fwd_dst_ports[last_port] = last_port;\n\t}\n```\n\n### 初始化端口的配置信息\n为每个端口分配到相应的逻辑内核\n每个端口只对应一个逻辑内核\n每个逻辑内核对应l2fwd_rx_queue_per_lcore个端口\n``` C\n\tfor (portid = 0; portid < nb_ports; portid++) {\n\t\tif ((l2fwd_enabled_port_mask & (1 << portid)) == 0)\n\t\t\tcontinue;\n\n\t\t//得到一个收取队列未分配满且可用的逻辑内核\n\t\twhile (rte_lcore_is_enabled(rx_lcore_id) == 0 ||\n\t\t       lcore_queue_conf[rx_lcore_id].n_rx_port ==\n\t\t       l2fwd_rx_queue_per_lcore) {\n\t\t\trx_lcore_id++;\n\t\t\tif (rx_lcore_id >= RTE_MAX_LCORE)\n\t\t\t\trte_exit(EXIT_FAILURE, \"Not enough cores\\n\");\n\t\t}\n\n\t\tif (qconf != &lcore_queue_conf[rx_lcore_id])\n\t\t\t/* Assigned a new logical core in the loop above. */\n\t\t\tqconf = &lcore_queue_conf[rx_lcore_id];\n\n\t\tqconf->rx_port_list[qconf->n_rx_port] = portid;\n\t\tqconf->n_rx_port++;\n\t\tprintf(\"Lcore %u: RX port %u\\n\", rx_lcore_id, (unsigned) portid);\n\t}\n```\n\n### 初始化每个端口\n``` C\n\tfor (portid = 0; portid < nb_ports; portid++) {\n\t\tif ((l2fwd_enabled_port_mask & (1 << portid)) == 0) {\n\t\t\tprintf(\"Skipping disabled port %u\\n\", (unsigned) portid);\n\t\t\tnb_ports_available--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"Initializing port %u... \", (unsigned) portid);\n\t\tfflush(stdout);\n\t\t//初始化端口，第二个参数和第三个参数表示分配收取队列和发送队列的数量\n\t\tret = rte_eth_dev_configure(portid, 1, 1, &port_conf);\n\t\tif (ret < 0)\n\t\t\trte_exit(EXIT_FAILURE, \"Cannot configure device: err=%d, port=%u\\n\",\n\t\t\t\t  ret, (unsigned) portid);\n\n\t\t//得到端口对应的mac地址，存入l2fwd_ports_eth_addr[]数组\n\t\trte_eth_macaddr_get(portid,&l2fwd_ports_eth_addr[portid]);\n\n\t\tfflush(stdout);\n\t\t//初始化一个收取队列，nb_rxd指收取队列的大小，最大能够存储mbuf的数量\n\t\tret = rte_eth_rx_queue_setup(portid, 0, nb_rxd,\n\t\t\t\t\t     rte_eth_dev_socket_id(portid),\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     l2fwd_pktmbuf_pool);\n\t\tif (ret < 0)\n\t\t\trte_exit(EXIT_FAILURE, \"rte_eth_rx_queue_setup:err=%d, port=%u\\n\",\n\t\t\t\t  ret, (unsigned) portid);\n\n\t\tfflush(stdout);\n\t\t//初始化一个发送队列，nb_txd指发送队列的大小，最大能够存储mbuf的数量\n\t\tret = rte_eth_tx_queue_setup(portid, 0, nb_txd,\n\t\t\t\trte_eth_dev_socket_id(portid),\n\t\t\t\tNULL);\n\t\tif (ret < 0)\n\t\t\trte_exit(EXIT_FAILURE, \"rte_eth_tx_queue_setup:err=%d, port=%u\\n\",\n\t\t\t\tret, (unsigned) portid);\n\n\t\t//开始运行该端口\n\t\tret = rte_eth_dev_start(portid);\n\t\tif (ret < 0)\n\t\t\trte_exit(EXIT_FAILURE, \"rte_eth_dev_start:err=%d, port=%u\\n\",\n\t\t\t\t  ret, (unsigned) portid);\n\n\t\tprintf(\"done: \\n\");\n\n\t\trte_eth_promiscuous_enable(portid);\n\n\t\tprintf(\"Port %u, MAC address: %02X:%02X:%02X:%02X:%02X:%02X\\n\\n\",\n\t\t\t\t(unsigned) portid,\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[0],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[1],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[2],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[3],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[4],\n\t\t\t\tl2fwd_ports_eth_addr[portid].addr_bytes[5]);\n\n\t\t//初始化端口的统计数据\n\t\tmemset(&port_statistics, 0, sizeof(port_statistics));\n\t}\n```\n\n### 检查每个端口的连接状态\n``` C\n\tcheck_all_ports_link_status(nb_ports, l2fwd_enabled_port_mask);\n```\n\n### 在每个逻辑内核上启动线程，开始转发\n``` C\n\trte_eal_mp_remote_launch(l2fwd_launch_one_lcore, NULL, CALL_MASTER);\n\tRTE_LCORE_FOREACH_SLAVE(lcore_id) {\n\t\tif (rte_eal_wait_lcore(lcore_id) < 0)\n\t\t\treturn -1;\n\t}\n```\n\n收包\n``` C\n\tfor (i = 0; i < qconf->n_rx_port; i++) {\n\n\t\tportid = qconf->rx_port_list[i];\n\t\t//收包，一次最多收取MAX_PKT_BURST个数据包\n\t\tnb_rx = rte_eth_rx_burst((uint8_t) portid, 0,\n\t\t\t\t\t pkts_burst, MAX_PKT_BURST);\n\t\t\n\t\t//更新统计数据\n\t\tport_statistics[portid].rx += nb_rx;\n\n\t\tfor (j = 0; j < nb_rx; j++) {\n\t\t\tm = pkts_burst[j];\n\t\t\trte_prefetch0(rte_pktmbuf_mtod(m, void *));\n\t\t\t//转发\n\t\t\tl2fwd_simple_forward(m, portid);\n\t\t}\n\t}\n```\n\n转发\n替换源MAC地址和目的MAC地址\n``` C\n\tstatic void\n\tl2fwd_simple_forward(struct rte_mbuf *m, unsigned portid)\n\t{\n\t\tstruct ether_hdr *eth;\n\t\tvoid *tmp;\n\t\tunsigned dst_port;\n\n\t\tdst_port = l2fwd_dst_ports[portid];\n\t\teth = rte_pktmbuf_mtod(m, struct ether_hdr *);\n\n\t\t//目的地址\n\t\t/* 02:00:00:00:00:xx */\n\t\ttmp = &eth->d_addr.addr_bytes[0];\n\t\t*((uint64_t *)tmp) = 0x000000000002 + ((uint64_t)dst_port << 40);\n\n\t\t//源地址\n\t\tether_addr_copy(&l2fwd_ports_eth_addr[dst_port], &eth->s_addr);\n\n\t\tl2fwd_send_packet(m, (uint8_t) dst_port);\n\t}\n```\n\n将数据包推送至发送队列，如果发送队列存够MAX_PKT_BURST，即每次最大收取包的数量，就会发包\n``` C\n\tstatic int\n\tl2fwd_send_packet(struct rte_mbuf *m, uint8_t port)\n\t{\n\t\tunsigned lcore_id, len;\n\t\tstruct lcore_queue_conf *qconf;\n\n\t\tlcore_id = rte_lcore_id();\n\n\t\tqconf = &lcore_queue_conf[lcore_id];\n\t\tlen = qconf->tx_mbufs[port].len;\n\t\tqconf->tx_mbufs[port].m_table[len] = m;\n\t\tlen++;\n\n\t\t//当发包队列存够MAX_PKT_BURST，发包\n\t\tif (unlikely(len == MAX_PKT_BURST)) {\n\t\t\tl2fwd_send_burst(qconf, MAX_PKT_BURST, port);\n\t\t\tlen = 0;\n\t\t}\n\n\t\tqconf->tx_mbufs[port].len = len;\n\t\treturn 0;\n\t}\n```\n\n每隔一定时间也会发包\n``` C\n\t//上次收包时间和这次收包时间差\n\tdiff_tsc = cur_tsc - prev_tsc;\n\t//如果时间差大于我们设定的阈值，这里是100us\n\tif (unlikely(diff_tsc > drain_tsc)) {\n\n\t\tfor (portid = 0; portid < RTE_MAX_ETHPORTS; portid++) {\t\t\t\n\t\t\tif (qconf->tx_mbufs[portid].len == 0)\n\t\t\t\tcontinue;\n\t\t\t//发包\n\t\t\tl2fwd_send_burst(&lcore_queue_conf[lcore_id],\n\t\t\t\t\t qconf->tx_mbufs[portid].len,\n\t\t\t\t\t (uint8_t) portid);\n\t\t\t\t\tqconf->tx_mbufs[portid].len = 0;\n\t\t}\n\t\t\n\t\tif (timer_period > 0) {\n\t\t\t\t\n\t\t\ttimer_tsc += diff_tsc;\n\n\t\t\t//如果累积时间超过我们设定的阈值，就打印出统计数据，默认是10s\n\t\t\tif (unlikely(timer_tsc >= (uint64_t) timer_period)) {\n\n\t\t\t\t//打印数据在发生在主逻辑内核上\n\t\t\t\tif (lcore_id == rte_get_master_lcore()) {\n\t\t\t\t\t//打印统计数据\n\t\t\t\t\tprint_stats();\n\t\t\t\t\t//累积时间置零\n\t\t\t\t\ttimer_tsc = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprev_tsc = cur_tsc;\n\t}\n```\n这两种情况都会产生发包，无论是发送队列存够阈值MAX_PKT_BURST，或者，时间差超过阈值brain_tsc，都会把发送队列上MAX_PKT_BURST个数据包推送出去，如果不足MAX_PKT_BURST，则把发送队列上全部数据包推送出去。\n\n发包函数\n``` C\n\tstatic int\n\tl2fwd_send_burst(struct lcore_queue_conf *qconf, unsigned n, uint8_t port)\n\t{\n\t\tstruct rte_mbuf **m_table;\n\t\tunsigned ret;\n\t\tunsigned queueid =0;\n\n\t\tm_table = (struct rte_mbuf **)qconf->tx_mbufs[port].m_table;\n\t\t//发包\n\t\tret = rte_eth_tx_burst(port, (uint16_t) queueid, m_table, (uint16_t) n);\n\t\t//更新统计数据\n\t\tport_statistics[port].tx += ret;\n\t\t//丢包\n\t\tif (unlikely(ret < n)) {\n\t\t\t//更新统计数据\n\t\t\tport_statistics[port].dropped += (n - ret);\n\t\t\tdo {\n\t\t\t\t//把丢包部分free掉\n\t\t\t\trte_pktmbuf_free(m_table[ret]);\n\t\t\t} while (++ret < n);\n\t\t}\n\n\t\treturn 0;\n\t}\n```\n在函数rte_eth_tx_burst()中：\n- port：端口号。\n- queueid：端口中的发送队列号。本例中每个端口都只有一个发送队列，所以固定为0。\n- m_table：**rte_mbuf数据\n- n：发送包的数量\n\n","slug":"dpdk_l2fwd","published":1,"updated":"2016-08-15T15:10:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qsh001nmeo3eouicaiz"},{"title":"DPDK编译运行","toc":true,"date":"2015-04-28T06:46:52.000Z","_content":"\nDPDK（Data Plane Development kit）是Intel发布的数据包处理转发套件。\n\n<!--more-->\n**Title: [dpdk编译运行](https://aidaizyy.github.io/dpdk)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-04-28](http://aidaizyy.github.io)**\n\n##下载\n\n下载DPDK-2.0.0\n``` bash\nwget http://www.dpdk.org/browse/dpdk/snapshot/dpdk-2.0.0.tar.gz\n```\n或者直接访问http://www.dpdk.org/download/ 下载最新的版本。\n\n解开压缩包\n``` bash\ntar -xvzf dpdk-2.0.0.tar.gz\n```\n\n##准备\n\n### linux kernel header\n\n确保系统是否已安装linux kernel header，未安装则：\n``` bash\nsudo apt-get install linux-header-3.13.0-49-generic\n```\n\nlinux kernel版本号由系统本身决定，以下命令查看：\n``` bash\nuname -r\n```\n\nkernel版本号必须大于2.6.33。\n同时glibc版本号大于2.7。\n\n### libpcap函数库\n\n``` bash\nsudo apt-get install libpcap-dev\n```\n\n### hugepages\n\n查看kernel是否支持hugepapse\n``` bash\ngrep -i huge /boot/config-3.13.0-49-generic\n```\n同样，kernel版本号由系统本身决定。\n如果出现\n``` bash\nCONFIG_HUGETLBFS=y\nCONFIG_HUGETLB_PAGE=y\n```\n则表示支持hugepages。\n\n查看当前系统hugepages信息\n``` bash\ngrep -i huge /proc/meminfo\n```\n\n配置hugepages\n``` bash\nvi /etc/sysctl.conf\n#在文件底部添加\nvm.nr_hugepages=512\n#表示hugepages的页面数量\n\nvi /etc/fstab\n#在文件底部添加\nhuge /mnt/huge hugetlbfs defaults 0 0\n\nmkdir /mnt/huge\nchmod 777 /mnt/huge\n```\n\n重新启动后查看/proc/meminfo 就会发现hugepages已经加载。\n``` bash\nAnonHugePages:     53248 kB\nHugePages_Total:     512\nHugePages_Free:      512\nHugePages_Rsvd:        0\nHugePages_Surp:        0\nHugepagesize:       2048 kB\n```\n\n##编译\n``` bash\ncd dpdk-2.0.0\nmake install T=x86_64-native-linuxapp-gcc\n```\nx86_64指x86构架64位系统。如果是32位系统，将x86_64替换为i686。\n\n官网给出的编译平台规范是ARCH-MACHINE-EXECENV-TOOLCHAIN\nARCH can be: i686, x86_64, ppc_64\nMACHINE can be: native, ivshmem, power8\nEXECENV can be: linuxapp, bsdapp\nTOOLCHAIN can be: gcc, icc\n\n这里在Ubuntu Linux 64位系统本地环境下gcc工具编译\n\n也可以先设置，再编译。\n``` bash\nmake config T=x86_64-native-linuxapp-gcc\nmake\n```\n\nmake install会将编译后的文件放入新建的x86_64-native-linuxapp-gcc目录。\nmake config + make会将编译后的文件放入新建的build目录。\n\n##加载模块\n\n``` bash\nsudo modprobe uio\nsudo insmod kmod/igb_uio.ko\n```\nuio是kernel自带的用户空间IO模块\nigb_uio是dpdk编译的模块，出现在dpdk-2.0.0/build/kmod 或者dpdk-2.0.0/x86_64-native-linuxapp-gcc/kmod 目录中。\n\n##绑定网卡\n\n查看当前网卡信息\n``` bash\ncd dpdk-2.0.0\n./tools/dpdk_nic_bind.py --status\n\nNetwork devices using kernel driver\n===================================\n0000:00:05.0 '82545EM Gigabit Ethernet Controller (Copper)' if=eth0 drv=e1000 unused= *Active*\n0000:00:06.0 '82545EM Gigabit Ethernet Controller (Copper)' if=eth1 drv=e1000 unused= *Active*\n0000:00:07.0 '82545EM Gigabit Ethernet Controller (Copper)' if=eth3 drv=e1000 unused= *Active*\n\nOther network devices\n=====================\n<none>\n\n```\n\n绑定网卡\n``` bash\n./tools/dpdk_nic_bind.py --bind=igb_uio 00:05.0\n``` \n\n绑定之前，保证网卡处于非活跃状态\n``` bash\nifconfig eth0 down\n```\n\n##运行示例\n\n运行helloworld示例\n``` bash\n#添加环境变量\nexport RTE_SDK=$SDK/dpdp-2.0.0\nexport RTE_TARGET=x86_64-native-linuxapp-gcc\n\n#编译\ncd /dpdk-2.0.0/example/helloworld\nmake\n\n#运行\n./build/helloworld -c 3 -n 2\n\nhello from core 1\nhello from core 0\n```\n\n这里的RTE_SDK指dpdk主目录的路径。\n\n-c COREMASK -n NUM为必须参数\nCOREMASK: 一个十六进制位掩码表示分配的逻辑内核数量。\nNUM: 一个十进制整数表示内存通道数量。\n\n运行完成后，显示\nhello from core 1\nhello from core 0。\n\n其他示例程序参数有不同要求，参见官方网站的说明文档。\n\n##脚本安装\n\nDPDK提供了更简单的脚本安装。\n在解开压缩包和设置好环境变量RTE_SDK和RTE_TARGET后，运行setup.sh脚本。\n``` bash\ncd /dpdk-2.0.0\n./tools/setup.sh\n\n----------------------------------------------------------\n Step 1: Select the DPDK environment to build\n----------------------------------------------------------\n[1] i686-native-linuxapp-gcc\n[2] i686-native-linuxapp-icc\n[3] ppc_64-power8-linuxapp-gcc\n[4] x86_64-ivshmem-linuxapp-gcc\n[5] x86_64-ivshmem-linuxapp-icc\n[6] x86_64-native-bsdapp-clang\n[7] x86_64-native-bsdapp-gcc\n[8] x86_64-native-linuxapp-clang\n[9] x86_64-native-linuxapp-gcc\n[10] x86_64-native-linuxapp-icc\n[11] x86_x32-native-linuxapp-gcc\n\n----------------------------------------------------------\n Step 2: Setup linuxapp environment\n----------------------------------------------------------\n[12] Insert IGB UIO module\n[13] Insert VFIO module\n[14] Insert KNI module\n[15] Setup hugepage mappings for non-NUMA systems\n[16] Setup hugepage mappings for NUMA systems\n[17] Display current Ethernet device settings\n[18] Bind Ethernet device to IGB UIO module\n[19] Bind Ethernet device to VFIO module\n[20] Setup VFIO permissions\n\n----------------------------------------------------------\n Step 3: Run test application for linuxapp environment\n----------------------------------------------------------\n[21] Run test application ($RTE_TARGET/app/test)\n[22] Run testpmd application in interactive mode ($RTE_TARGET/app/testpmd)\n\n----------------------------------------------------------\n Step 4: Other tools\n----------------------------------------------------------\n[23] List hugepage info from /proc/meminfo\n\n----------------------------------------------------------\n Step 5: Uninstall and system cleanup\n----------------------------------------------------------\n[24] Uninstall all targets\n[25] Unbind NICs from IGB UIO or VFIO driver\n[26] Remove IGB UIO module\n[27] Remove VFIO module\n[28] Remove KNI module\n[29] Remove hugepage mappings\n\n[30] Exit Script\n\nOption: \n```\n按照脚本指示一步一步运行即可。\n依次执行9-12-15-18就可以达到和上面一样的结果。\n当然不同情况，脚本执行步骤不同。\n\n##示例程序\n\n几个值得关注的示例程序。\n\n- testpmd: 测试程序，可以在setup.sh脚本中运行或者在app/ 目录下。\n\t文档: http://www.dpdk.org/doc/guides/testpmd_app_ug/index.html\n\n- l2fwd: 链路层转发程序，在example/ 目录下。\n\texample /目录下有很多其他值得关注的示例程序。\n\t文档: http://www.dpdk.org/doc/guides/sample_app_ug/index.html\n\n- pktgen-dpdk: 基于DPDK的高速发包程序\n\tDPDK官方网站：http://www.dpdk.org/browse/apps/pktgen-dpdk \n\tGithub：http://github.com/pktgen/Pktgen-DPDK\n\n","source":"_posts/dpdk.md","raw":"title: DPDK编译运行\ntoc: true\ndate: 2015-04-28 14:46:52\ntags: \n- dpdk\ncategories: dpdk\n---\n\nDPDK（Data Plane Development kit）是Intel发布的数据包处理转发套件。\n\n<!--more-->\n**Title: [dpdk编译运行](https://aidaizyy.github.io/dpdk)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-04-28](http://aidaizyy.github.io)**\n\n##下载\n\n下载DPDK-2.0.0\n``` bash\nwget http://www.dpdk.org/browse/dpdk/snapshot/dpdk-2.0.0.tar.gz\n```\n或者直接访问http://www.dpdk.org/download/ 下载最新的版本。\n\n解开压缩包\n``` bash\ntar -xvzf dpdk-2.0.0.tar.gz\n```\n\n##准备\n\n### linux kernel header\n\n确保系统是否已安装linux kernel header，未安装则：\n``` bash\nsudo apt-get install linux-header-3.13.0-49-generic\n```\n\nlinux kernel版本号由系统本身决定，以下命令查看：\n``` bash\nuname -r\n```\n\nkernel版本号必须大于2.6.33。\n同时glibc版本号大于2.7。\n\n### libpcap函数库\n\n``` bash\nsudo apt-get install libpcap-dev\n```\n\n### hugepages\n\n查看kernel是否支持hugepapse\n``` bash\ngrep -i huge /boot/config-3.13.0-49-generic\n```\n同样，kernel版本号由系统本身决定。\n如果出现\n``` bash\nCONFIG_HUGETLBFS=y\nCONFIG_HUGETLB_PAGE=y\n```\n则表示支持hugepages。\n\n查看当前系统hugepages信息\n``` bash\ngrep -i huge /proc/meminfo\n```\n\n配置hugepages\n``` bash\nvi /etc/sysctl.conf\n#在文件底部添加\nvm.nr_hugepages=512\n#表示hugepages的页面数量\n\nvi /etc/fstab\n#在文件底部添加\nhuge /mnt/huge hugetlbfs defaults 0 0\n\nmkdir /mnt/huge\nchmod 777 /mnt/huge\n```\n\n重新启动后查看/proc/meminfo 就会发现hugepages已经加载。\n``` bash\nAnonHugePages:     53248 kB\nHugePages_Total:     512\nHugePages_Free:      512\nHugePages_Rsvd:        0\nHugePages_Surp:        0\nHugepagesize:       2048 kB\n```\n\n##编译\n``` bash\ncd dpdk-2.0.0\nmake install T=x86_64-native-linuxapp-gcc\n```\nx86_64指x86构架64位系统。如果是32位系统，将x86_64替换为i686。\n\n官网给出的编译平台规范是ARCH-MACHINE-EXECENV-TOOLCHAIN\nARCH can be: i686, x86_64, ppc_64\nMACHINE can be: native, ivshmem, power8\nEXECENV can be: linuxapp, bsdapp\nTOOLCHAIN can be: gcc, icc\n\n这里在Ubuntu Linux 64位系统本地环境下gcc工具编译\n\n也可以先设置，再编译。\n``` bash\nmake config T=x86_64-native-linuxapp-gcc\nmake\n```\n\nmake install会将编译后的文件放入新建的x86_64-native-linuxapp-gcc目录。\nmake config + make会将编译后的文件放入新建的build目录。\n\n##加载模块\n\n``` bash\nsudo modprobe uio\nsudo insmod kmod/igb_uio.ko\n```\nuio是kernel自带的用户空间IO模块\nigb_uio是dpdk编译的模块，出现在dpdk-2.0.0/build/kmod 或者dpdk-2.0.0/x86_64-native-linuxapp-gcc/kmod 目录中。\n\n##绑定网卡\n\n查看当前网卡信息\n``` bash\ncd dpdk-2.0.0\n./tools/dpdk_nic_bind.py --status\n\nNetwork devices using kernel driver\n===================================\n0000:00:05.0 '82545EM Gigabit Ethernet Controller (Copper)' if=eth0 drv=e1000 unused= *Active*\n0000:00:06.0 '82545EM Gigabit Ethernet Controller (Copper)' if=eth1 drv=e1000 unused= *Active*\n0000:00:07.0 '82545EM Gigabit Ethernet Controller (Copper)' if=eth3 drv=e1000 unused= *Active*\n\nOther network devices\n=====================\n<none>\n\n```\n\n绑定网卡\n``` bash\n./tools/dpdk_nic_bind.py --bind=igb_uio 00:05.0\n``` \n\n绑定之前，保证网卡处于非活跃状态\n``` bash\nifconfig eth0 down\n```\n\n##运行示例\n\n运行helloworld示例\n``` bash\n#添加环境变量\nexport RTE_SDK=$SDK/dpdp-2.0.0\nexport RTE_TARGET=x86_64-native-linuxapp-gcc\n\n#编译\ncd /dpdk-2.0.0/example/helloworld\nmake\n\n#运行\n./build/helloworld -c 3 -n 2\n\nhello from core 1\nhello from core 0\n```\n\n这里的RTE_SDK指dpdk主目录的路径。\n\n-c COREMASK -n NUM为必须参数\nCOREMASK: 一个十六进制位掩码表示分配的逻辑内核数量。\nNUM: 一个十进制整数表示内存通道数量。\n\n运行完成后，显示\nhello from core 1\nhello from core 0。\n\n其他示例程序参数有不同要求，参见官方网站的说明文档。\n\n##脚本安装\n\nDPDK提供了更简单的脚本安装。\n在解开压缩包和设置好环境变量RTE_SDK和RTE_TARGET后，运行setup.sh脚本。\n``` bash\ncd /dpdk-2.0.0\n./tools/setup.sh\n\n----------------------------------------------------------\n Step 1: Select the DPDK environment to build\n----------------------------------------------------------\n[1] i686-native-linuxapp-gcc\n[2] i686-native-linuxapp-icc\n[3] ppc_64-power8-linuxapp-gcc\n[4] x86_64-ivshmem-linuxapp-gcc\n[5] x86_64-ivshmem-linuxapp-icc\n[6] x86_64-native-bsdapp-clang\n[7] x86_64-native-bsdapp-gcc\n[8] x86_64-native-linuxapp-clang\n[9] x86_64-native-linuxapp-gcc\n[10] x86_64-native-linuxapp-icc\n[11] x86_x32-native-linuxapp-gcc\n\n----------------------------------------------------------\n Step 2: Setup linuxapp environment\n----------------------------------------------------------\n[12] Insert IGB UIO module\n[13] Insert VFIO module\n[14] Insert KNI module\n[15] Setup hugepage mappings for non-NUMA systems\n[16] Setup hugepage mappings for NUMA systems\n[17] Display current Ethernet device settings\n[18] Bind Ethernet device to IGB UIO module\n[19] Bind Ethernet device to VFIO module\n[20] Setup VFIO permissions\n\n----------------------------------------------------------\n Step 3: Run test application for linuxapp environment\n----------------------------------------------------------\n[21] Run test application ($RTE_TARGET/app/test)\n[22] Run testpmd application in interactive mode ($RTE_TARGET/app/testpmd)\n\n----------------------------------------------------------\n Step 4: Other tools\n----------------------------------------------------------\n[23] List hugepage info from /proc/meminfo\n\n----------------------------------------------------------\n Step 5: Uninstall and system cleanup\n----------------------------------------------------------\n[24] Uninstall all targets\n[25] Unbind NICs from IGB UIO or VFIO driver\n[26] Remove IGB UIO module\n[27] Remove VFIO module\n[28] Remove KNI module\n[29] Remove hugepage mappings\n\n[30] Exit Script\n\nOption: \n```\n按照脚本指示一步一步运行即可。\n依次执行9-12-15-18就可以达到和上面一样的结果。\n当然不同情况，脚本执行步骤不同。\n\n##示例程序\n\n几个值得关注的示例程序。\n\n- testpmd: 测试程序，可以在setup.sh脚本中运行或者在app/ 目录下。\n\t文档: http://www.dpdk.org/doc/guides/testpmd_app_ug/index.html\n\n- l2fwd: 链路层转发程序，在example/ 目录下。\n\texample /目录下有很多其他值得关注的示例程序。\n\t文档: http://www.dpdk.org/doc/guides/sample_app_ug/index.html\n\n- pktgen-dpdk: 基于DPDK的高速发包程序\n\tDPDK官方网站：http://www.dpdk.org/browse/apps/pktgen-dpdk \n\tGithub：http://github.com/pktgen/Pktgen-DPDK\n\n","slug":"dpdk","published":1,"updated":"2016-08-15T15:10:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qsj001smeo3j8hpul5x"},{"title":"容量失效（capacity miss）与冲突失效（conflict miss）的区别","date":"2015-12-10T08:26:02.000Z","toc":false,"_content":"\nCache访问失效分为强制性失效/冷失效（compulsory miss/cold miss）、容量失效（capacity miss）和冲突失效（conflict miss）。其中容量失效和冲突失效概念非常相近，理解起来不容易区别。\n\n<!--more-->\n**Title: [容量失效（capacity miss）与冲突失效（conflict miss）的区别](https://aidaizyy.github.io/cache_miss_type)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-12-10](http://aidaizyy.github.io)**\n\n# 概念\n\n- **强制性失效：**CPU第一次访问相应cache块，cache中肯定没有该cache块，引起的失效叫做强制性失效。这是不可避免的。\n- **容量失效：**有限的cache容量导致cache放不下而替换出cache块，被替换出去的cache块再被访问，引起的失效叫做容量失效。\n- **冲突失效：**在直接相联或组相联的cache中，不同的cache块由于index相同相互替换，引起的失效叫做冲突失效。\n\n#理解\n\n如果两个cache块指向同一个cache位置，替换后，访问被替换cache块到底是属于容量失效还是冲突失效呢？\n主要看当前cache的存储情况。\n假设这里有32KB大小的直接相联cache。\n情况一（容量失效）：如果有一个64KB大小的数组需要重复访问，数组的大小远远大于cache大小，没办法全部放入cache。第一次访问数组发生的失效全都是强制性失效。之后再访问数组，再发生的失效则全都是容量失效，这时cache已经存满，容量不足以存储全部数据。\n情况二（冲突失效）：如果有两个8KB大小的数据需要来回访问，但是这两个数组都映射到相同的地址，cache大小足够存储全部的数据，但是因为相同地址发生了冲突需要来回替换，发生的失效则全都是冲突失效（第一次访问失效依旧是强制性失效），这时cache并没有存满。\n避免容量失效只能通过增加cache大小实现，而避免冲突失效则可以通过提高相联度，优化替换策略，优化代码，增大cache容量等很多措施实现。\n","source":"_posts/cache_miss_type.md","raw":"title: 容量失效（capacity miss）与冲突失效（conflict miss）的区别\ndate: 2015-12-10 16:26:02\ntags: \n- cache\n- computer architecture\ncategories: computer architecture\ntoc: false\n---\n\nCache访问失效分为强制性失效/冷失效（compulsory miss/cold miss）、容量失效（capacity miss）和冲突失效（conflict miss）。其中容量失效和冲突失效概念非常相近，理解起来不容易区别。\n\n<!--more-->\n**Title: [容量失效（capacity miss）与冲突失效（conflict miss）的区别](https://aidaizyy.github.io/cache_miss_type)**\n**Author: [Yunyao Zhang(张云尧)](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-12-10](http://aidaizyy.github.io)**\n\n# 概念\n\n- **强制性失效：**CPU第一次访问相应cache块，cache中肯定没有该cache块，引起的失效叫做强制性失效。这是不可避免的。\n- **容量失效：**有限的cache容量导致cache放不下而替换出cache块，被替换出去的cache块再被访问，引起的失效叫做容量失效。\n- **冲突失效：**在直接相联或组相联的cache中，不同的cache块由于index相同相互替换，引起的失效叫做冲突失效。\n\n#理解\n\n如果两个cache块指向同一个cache位置，替换后，访问被替换cache块到底是属于容量失效还是冲突失效呢？\n主要看当前cache的存储情况。\n假设这里有32KB大小的直接相联cache。\n情况一（容量失效）：如果有一个64KB大小的数组需要重复访问，数组的大小远远大于cache大小，没办法全部放入cache。第一次访问数组发生的失效全都是强制性失效。之后再访问数组，再发生的失效则全都是容量失效，这时cache已经存满，容量不足以存储全部数据。\n情况二（冲突失效）：如果有两个8KB大小的数据需要来回访问，但是这两个数组都映射到相同的地址，cache大小足够存储全部的数据，但是因为相同地址发生了冲突需要来回替换，发生的失效则全都是冲突失效（第一次访问失效依旧是强制性失效），这时cache并没有存满。\n避免容量失效只能通过增加cache大小实现，而避免冲突失效则可以通过提高相联度，优化替换策略，优化代码，增大cache容量等很多措施实现。\n","slug":"cache_miss_type","published":1,"updated":"2015-12-10T14:26:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qsm001vmeo3bzak4ghn"},{"title":"Android代码混淆（Proguard）","date":"2015-07-13T03:42:52.000Z","toc":true,"_content":"\nAndroid采用Java语言，编译成class文件，会很容易被反编译为java源代码。为了代码不被反编译，往往采用代码混淆。Android自带Proguard可以完成这项工作，同时删除没有使用的字段属性等，优化代码。\n\n<!--more-->\n**Title: [Android代码混淆（Proguard）](https://aidaizyy.github.io/android_proguard)**\n**Author: [Yunyao Zhang（张云尧）](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-13](http://aidaizyy.github.io)**\n\n##概要\n\nProguard并没有改变程序结构，只是通过修改名称，调整顺序等措施将代码变得难以阅读，难以理解，但却可以运行。\n在Android项目的主目录里自带proguard-project.txt文件，代码混淆的规则就写在里面。\n\n##配置\n\n主目录的project.properties文件需要加上下面这句话，以告诉项目需要运行Proguard：\n\n_proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt_ \n\n创建好的Android项目一般自带这条语句，不过开头用#注释了，去掉#即可。\n\n##规则\n_摘抄自http://blog.csdn.net/banketree/article/details/41928175_\n\n``` bash\n-include {filename}    从给定的文件中读取配置参数 \n-basedirectory {directoryname}    指定基础目录为以后相对的档案名称 \n-injars {class_path}    指定要处理的应用程序jar,war,ear和目录 \n-outjars {class_path}    指定处理完后要输出的jar,war,ear和目录的名称 \n-libraryjars {classpath}    指定要处理的应用程序jar,war,ear和目录所需要的程序库文件 \n-dontskipnonpubliclibraryclasses    指定不去忽略非公共的库类。 \n-dontskipnonpubliclibraryclassmembers    指定不去忽略包可见的库类的成员。\n\n保留选项 \n-keep {Modifier} {class_specification}    保护指定的类文件和类的成员 \n-keepclassmembers {modifier} {class_specification}    保护指定类的成员，如果此类受到保护他们会保护的更好\n-keepclasseswithmembers {class_specification}    保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。 \n-keepnames {class_specification}    保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除） \n-keepclassmembernames {class_specification}    保护指定的类的成员的名称（如果他们不会压缩步骤中删除） \n-keepclasseswithmembernames {class_specification}    保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后） \n-printseeds {filename}    列出类和类的成员-keep选项的清单，标准输出到给定的文件 \n\n压缩 \n-dontshrink    不压缩输入的类文件 \n-printusage {filename} \n-whyareyoukeeping {class_specification}     \n\n优化 \n-dontoptimize    不优化输入的类文件 \n-assumenosideeffects {class_specification}    优化时假设指定的方法，没有任何副作用 \n-allowaccessmodification    优化时允许访问并修改有修饰符的类和类的成员 \n\n混淆 \n-dontobfuscate    不混淆输入的类文件 \n-printmapping {filename} \n-applymapping {filename}    重用映射增加混淆 \n-obfuscationdictionary {filename}    使用给定文件中的关键字作为要混淆方法的名称 \n-overloadaggressively    混淆时应用侵入式重载 \n-useuniqueclassmembernames    确定统一的混淆类的成员名称来增加混淆 \n-flattenpackagehierarchy {package_name}    重新包装所有重命名的包并放在给定的单一包中 \n-repackageclass {package_name}    重新包装所有重命名的类文件中放在给定的单一包中 \n-dontusemixedcaseclassnames    混淆时不会产生形形色色的类名 \n-keepattributes {attribute_name,...}    保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, Deprecated, Synthetic, Signature, and InnerClasses. \n-renamesourcefileattribute {string}    设置源文件中给定的字符串常量\n```\n\n##实例\n\nproject-proguard.txt中创建混淆规则。\n缺省情况下会混淆所有代码，导致出错，必须保证不能被混淆的代码被保持。\n\n``` java\n-ignorewarnings\t\t\t\t# 忽略警告，避免打包时某些警告出现\n-optimizationpasses 5\t\t\t# 指定代码的压缩级别\n-dontusemixedcaseclassnames\t\t# 是否使用大小写混合\n-dontskipnonpubliclibraryclasses\t# 是否混淆第三方jar\n-dontpreverify                   \t# 混淆时是否做预校验\n-verbose                            \t# 混淆时是否记录日志\n-optimizations !code/simplification/arithmetic,!field/\\*,!class/merging/\\*\t# 混淆时所采用的算法\n\n-keepattributes \\*Annotation\\*\n-keepattributes Signature\n\n-libraryjars   libs/treecore.jar\t# 保持第三方jar包不被混淆\n-libraryjars   libs/android-viewbadger.jar\n-libraryjars   libs/MapApi.jar\n-libraryjars   libs/SinaWeiboSDK.jar\n\n-dontwarn android.support.v4.**     \n-dontwarn android.os.**\n\n-keep class android.support.v4.** { *; } \t\t# 保持哪些类不被混淆\n-keep class com.baidu.** { *; }  \n-keep class vi.com.gdi.bgl.android.**{*;}\n-keep class android.os.**{*;}\n\n-keep interface android.support.v4.app.** { *; }  \n-keep public class * extends android.support.v4.**  \n-keep public class * extends android.app.Fragment\n-keep public class * extends android.app.Activity\n-keep public class * extends android.app.Application\n-keep public class * extends android.app.Service\n-keep public class * extends android.content.BroadcastReceiver\n-keep public class * extends android.content.ContentProvider\n-keep public class * extends android.support.v4.widget\n-keep public class * extends com.sqlcrypt.database\n-keep public class * extends com.sqlcrypt.database.sqlite\n-keep public class * extends com.treecore.**\n-keep public class * extends de.greenrobot.dao.**\n\n\n-keepclasseswithmembernames class * {\t# 保持 native 方法不被混淆\n    native <methods>;\n}\n\n-keepclasseswithmembers class * {\t# 保持自定义控件类不被混淆\n    public <init>(android.content.Context, android.util.AttributeSet);\n}\n\n-keepclasseswithmembers class * {\t# 保持自定义控件类不被混淆\n    public <init>(android.content.Context, android.util.AttributeSet, int);\n}\n\n-keepclassmembers class * extends android.app.Activity {\t#保持类成员\n   public void *(android.view.View);\n}\n\n-keepclassmembers enum * {\t# 保持枚举 enum 类不被混淆\n    public static **[] values();\n    public static ** valueOf(java.lang.String);\n}\n\n-keep class * implements android.os.Parcelable {\t# 保持 Parcelable 不被混淆\n  public static final android.os.Parcelable$Creator *;\n}\n\n-keep class MyClass;\t# 保持自己定义的类不被混淆\n```\n##反编译\n\ndex2jar：将apk转化为class文件\n``` bash\nhttps://github.com/pxb1988/dex2jar \n```\nJD-GUI：将class文件转化为java文件\n``` bash\nhttp://jd.benow.ca/ \n```\n\n通过这个两个工具可以将apk转化为java源文件。\n通过Proguard生成的apk可转化为java源文件来进行比对以检测Proguard是否生效。\n","source":"_posts/android_proguard.md","raw":"title: \"Android代码混淆（Proguard）\"\ndate: 2015-07-13 11:42:52\ntags:\n- android\n- proguard\ncategories: android\ntoc: true\n---\n\nAndroid采用Java语言，编译成class文件，会很容易被反编译为java源代码。为了代码不被反编译，往往采用代码混淆。Android自带Proguard可以完成这项工作，同时删除没有使用的字段属性等，优化代码。\n\n<!--more-->\n**Title: [Android代码混淆（Proguard）](https://aidaizyy.github.io/android_proguard)**\n**Author: [Yunyao Zhang（张云尧）](http://aidaizyy.github.io)**\n**E-mail: <aidaizyy@gmail.com>**\n**Last Modified: [2015-07-13](http://aidaizyy.github.io)**\n\n##概要\n\nProguard并没有改变程序结构，只是通过修改名称，调整顺序等措施将代码变得难以阅读，难以理解，但却可以运行。\n在Android项目的主目录里自带proguard-project.txt文件，代码混淆的规则就写在里面。\n\n##配置\n\n主目录的project.properties文件需要加上下面这句话，以告诉项目需要运行Proguard：\n\n_proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt_ \n\n创建好的Android项目一般自带这条语句，不过开头用#注释了，去掉#即可。\n\n##规则\n_摘抄自http://blog.csdn.net/banketree/article/details/41928175_\n\n``` bash\n-include {filename}    从给定的文件中读取配置参数 \n-basedirectory {directoryname}    指定基础目录为以后相对的档案名称 \n-injars {class_path}    指定要处理的应用程序jar,war,ear和目录 \n-outjars {class_path}    指定处理完后要输出的jar,war,ear和目录的名称 \n-libraryjars {classpath}    指定要处理的应用程序jar,war,ear和目录所需要的程序库文件 \n-dontskipnonpubliclibraryclasses    指定不去忽略非公共的库类。 \n-dontskipnonpubliclibraryclassmembers    指定不去忽略包可见的库类的成员。\n\n保留选项 \n-keep {Modifier} {class_specification}    保护指定的类文件和类的成员 \n-keepclassmembers {modifier} {class_specification}    保护指定类的成员，如果此类受到保护他们会保护的更好\n-keepclasseswithmembers {class_specification}    保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。 \n-keepnames {class_specification}    保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除） \n-keepclassmembernames {class_specification}    保护指定的类的成员的名称（如果他们不会压缩步骤中删除） \n-keepclasseswithmembernames {class_specification}    保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后） \n-printseeds {filename}    列出类和类的成员-keep选项的清单，标准输出到给定的文件 \n\n压缩 \n-dontshrink    不压缩输入的类文件 \n-printusage {filename} \n-whyareyoukeeping {class_specification}     \n\n优化 \n-dontoptimize    不优化输入的类文件 \n-assumenosideeffects {class_specification}    优化时假设指定的方法，没有任何副作用 \n-allowaccessmodification    优化时允许访问并修改有修饰符的类和类的成员 \n\n混淆 \n-dontobfuscate    不混淆输入的类文件 \n-printmapping {filename} \n-applymapping {filename}    重用映射增加混淆 \n-obfuscationdictionary {filename}    使用给定文件中的关键字作为要混淆方法的名称 \n-overloadaggressively    混淆时应用侵入式重载 \n-useuniqueclassmembernames    确定统一的混淆类的成员名称来增加混淆 \n-flattenpackagehierarchy {package_name}    重新包装所有重命名的包并放在给定的单一包中 \n-repackageclass {package_name}    重新包装所有重命名的类文件中放在给定的单一包中 \n-dontusemixedcaseclassnames    混淆时不会产生形形色色的类名 \n-keepattributes {attribute_name,...}    保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, Deprecated, Synthetic, Signature, and InnerClasses. \n-renamesourcefileattribute {string}    设置源文件中给定的字符串常量\n```\n\n##实例\n\nproject-proguard.txt中创建混淆规则。\n缺省情况下会混淆所有代码，导致出错，必须保证不能被混淆的代码被保持。\n\n``` java\n-ignorewarnings\t\t\t\t# 忽略警告，避免打包时某些警告出现\n-optimizationpasses 5\t\t\t# 指定代码的压缩级别\n-dontusemixedcaseclassnames\t\t# 是否使用大小写混合\n-dontskipnonpubliclibraryclasses\t# 是否混淆第三方jar\n-dontpreverify                   \t# 混淆时是否做预校验\n-verbose                            \t# 混淆时是否记录日志\n-optimizations !code/simplification/arithmetic,!field/\\*,!class/merging/\\*\t# 混淆时所采用的算法\n\n-keepattributes \\*Annotation\\*\n-keepattributes Signature\n\n-libraryjars   libs/treecore.jar\t# 保持第三方jar包不被混淆\n-libraryjars   libs/android-viewbadger.jar\n-libraryjars   libs/MapApi.jar\n-libraryjars   libs/SinaWeiboSDK.jar\n\n-dontwarn android.support.v4.**     \n-dontwarn android.os.**\n\n-keep class android.support.v4.** { *; } \t\t# 保持哪些类不被混淆\n-keep class com.baidu.** { *; }  \n-keep class vi.com.gdi.bgl.android.**{*;}\n-keep class android.os.**{*;}\n\n-keep interface android.support.v4.app.** { *; }  \n-keep public class * extends android.support.v4.**  \n-keep public class * extends android.app.Fragment\n-keep public class * extends android.app.Activity\n-keep public class * extends android.app.Application\n-keep public class * extends android.app.Service\n-keep public class * extends android.content.BroadcastReceiver\n-keep public class * extends android.content.ContentProvider\n-keep public class * extends android.support.v4.widget\n-keep public class * extends com.sqlcrypt.database\n-keep public class * extends com.sqlcrypt.database.sqlite\n-keep public class * extends com.treecore.**\n-keep public class * extends de.greenrobot.dao.**\n\n\n-keepclasseswithmembernames class * {\t# 保持 native 方法不被混淆\n    native <methods>;\n}\n\n-keepclasseswithmembers class * {\t# 保持自定义控件类不被混淆\n    public <init>(android.content.Context, android.util.AttributeSet);\n}\n\n-keepclasseswithmembers class * {\t# 保持自定义控件类不被混淆\n    public <init>(android.content.Context, android.util.AttributeSet, int);\n}\n\n-keepclassmembers class * extends android.app.Activity {\t#保持类成员\n   public void *(android.view.View);\n}\n\n-keepclassmembers enum * {\t# 保持枚举 enum 类不被混淆\n    public static **[] values();\n    public static ** valueOf(java.lang.String);\n}\n\n-keep class * implements android.os.Parcelable {\t# 保持 Parcelable 不被混淆\n  public static final android.os.Parcelable$Creator *;\n}\n\n-keep class MyClass;\t# 保持自己定义的类不被混淆\n```\n##反编译\n\ndex2jar：将apk转化为class文件\n``` bash\nhttps://github.com/pxb1988/dex2jar \n```\nJD-GUI：将class文件转化为java文件\n``` bash\nhttp://jd.benow.ca/ \n```\n\n通过这个两个工具可以将apk转化为java源文件。\n通过Proguard生成的apk可转化为java源文件来进行比对以检测Proguard是否生效。\n","slug":"android_proguard","published":1,"updated":"2015-07-13T10:36:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis021qsp0022meo3tv6bk7qh"}],"PostAsset":[],"PostCategory":[{"post_id":"cis021qr80003meo34pns638v","category_id":"cis021qrc0004meo32sqvdj52","_id":"cis021qre0007meo30aq6av6h"},{"post_id":"cis021qrg0008meo3f0coo0k9","category_id":"cis021qrc0004meo32sqvdj52","_id":"cis021qrh0009meo30l2b4swp"},{"post_id":"cis021qrj000bmeo3jn5fla5g","category_id":"cis021qrc0004meo32sqvdj52","_id":"cis021qrk000cmeo3cg6zffi4"},{"post_id":"cis021qrl000emeo3gg22v2q8","category_id":"cis021qrc0004meo32sqvdj52","_id":"cis021qrm000fmeo3gz3zge62"},{"post_id":"cis021qrn000hmeo3z3mddj1w","category_id":"cis021qrc0004meo32sqvdj52","_id":"cis021qro000imeo3fa6o9h3p"},{"post_id":"cis021qrq000kmeo30a79pyf3","category_id":"cis021qrc0004meo32sqvdj52","_id":"cis021qrr000lmeo3phmp6obu"},{"post_id":"cis021qrs000nmeo3e9gkksds","category_id":"cis021qrc0004meo32sqvdj52","_id":"cis021qrt000omeo3x4rif6hk"},{"post_id":"cis021qru000qmeo32cq9js95","category_id":"cis021qrc0004meo32sqvdj52","_id":"cis021qrv000rmeo3f0cbggqq"},{"post_id":"cis021qrw000tmeo3spj99g5t","category_id":"cis021qrc0004meo32sqvdj52","_id":"cis021qry000umeo39rsx2jmt"},{"post_id":"cis021qs0000wmeo3l6ja8pw5","category_id":"cis021qrc0004meo32sqvdj52","_id":"cis021qs2000xmeo3nmhhg0ne"},{"post_id":"cis021qs3000zmeo32vtgqkrp","category_id":"cis021qrc0004meo32sqvdj52","_id":"cis021qs40010meo3srolro5a"},{"post_id":"cis021qs60012meo321006qay","category_id":"cis021qrc0004meo32sqvdj52","_id":"cis021qs60013meo35yk00fon"},{"post_id":"cis021qs70015meo38i7757zl","category_id":"cis021qrc0004meo32sqvdj52","_id":"cis021qs80016meo3kcsjuwcu"},{"post_id":"cis021qs90018meo3pmqta7wk","category_id":"cis021qrc0004meo32sqvdj52","_id":"cis021qsa0019meo3fqyqyivo"},{"post_id":"cis021qsc001bmeo3nwnlyd6a","category_id":"cis021qsd001cmeo3omq4g5ra","_id":"cis021qse001fmeo3z75zdnaw"},{"post_id":"cis021qse001gmeo3den82wii","category_id":"cis021qsf001hmeo3orj0yjdy","_id":"cis021qsg001kmeo3vgr7c9vf"},{"post_id":"cis021qsh001nmeo3eouicaiz","category_id":"cis021qsi001omeo3cs8f5uwg","_id":"cis021qsi001rmeo3o2ekzhde"},{"post_id":"cis021qsj001smeo3j8hpul5x","category_id":"cis021qsi001omeo3cs8f5uwg","_id":"cis021qsk001tmeo3wb8a7orb"},{"post_id":"cis021qsm001vmeo3bzak4ghn","category_id":"cis021qsn001wmeo3qxv7o6br","_id":"cis021qso001zmeo3vlf31yzs"},{"post_id":"cis021qsp0022meo3tv6bk7qh","category_id":"cis021qsq0023meo3y60ppywd","_id":"cis021qsr0026meo350chr6eg"}],"PostTag":[{"post_id":"cis021qr80003meo34pns638v","tag_id":"cis021qrc0005meo3afd7gkm0","_id":"cis021qre0006meo3x15kn5f2"},{"post_id":"cis021qrg0008meo3f0coo0k9","tag_id":"cis021qrc0005meo3afd7gkm0","_id":"cis021qrh000ameo3revfgnoy"},{"post_id":"cis021qrj000bmeo3jn5fla5g","tag_id":"cis021qrc0005meo3afd7gkm0","_id":"cis021qrk000dmeo39ayck4lx"},{"post_id":"cis021qrl000emeo3gg22v2q8","tag_id":"cis021qrc0005meo3afd7gkm0","_id":"cis021qrm000gmeo32kxobj1x"},{"post_id":"cis021qrn000hmeo3z3mddj1w","tag_id":"cis021qrc0005meo3afd7gkm0","_id":"cis021qro000jmeo39sqigcyu"},{"post_id":"cis021qrq000kmeo30a79pyf3","tag_id":"cis021qrc0005meo3afd7gkm0","_id":"cis021qrr000mmeo3gqhlp65e"},{"post_id":"cis021qrs000nmeo3e9gkksds","tag_id":"cis021qrc0005meo3afd7gkm0","_id":"cis021qrt000pmeo39wc48syk"},{"post_id":"cis021qru000qmeo32cq9js95","tag_id":"cis021qrc0005meo3afd7gkm0","_id":"cis021qrv000smeo3axfxbt6j"},{"post_id":"cis021qrw000tmeo3spj99g5t","tag_id":"cis021qrc0005meo3afd7gkm0","_id":"cis021qrz000vmeo3v73w9gjg"},{"post_id":"cis021qs0000wmeo3l6ja8pw5","tag_id":"cis021qrc0005meo3afd7gkm0","_id":"cis021qs2000ymeo3opq9oro5"},{"post_id":"cis021qs3000zmeo32vtgqkrp","tag_id":"cis021qrc0005meo3afd7gkm0","_id":"cis021qs40011meo3f03467me"},{"post_id":"cis021qs60012meo321006qay","tag_id":"cis021qrc0005meo3afd7gkm0","_id":"cis021qs60014meo35iwmew51"},{"post_id":"cis021qs70015meo38i7757zl","tag_id":"cis021qrc0005meo3afd7gkm0","_id":"cis021qs90017meo3pxsqauwy"},{"post_id":"cis021qs90018meo3pmqta7wk","tag_id":"cis021qrc0005meo3afd7gkm0","_id":"cis021qsb001ameo3x79yxsj0"},{"post_id":"cis021qsc001bmeo3nwnlyd6a","tag_id":"cis021qsd001dmeo3mplxtgt3","_id":"cis021qse001emeo3uf3qnn2x"},{"post_id":"cis021qse001gmeo3den82wii","tag_id":"cis021qsf001imeo38p0ehowv","_id":"cis021qsg001lmeo3a7vr1zj8"},{"post_id":"cis021qse001gmeo3den82wii","tag_id":"cis021qsg001jmeo35apu442u","_id":"cis021qsg001mmeo3l26x4dz5"},{"post_id":"cis021qsh001nmeo3eouicaiz","tag_id":"cis021qsi001pmeo3h5npjtsc","_id":"cis021qsi001qmeo301b8k0i2"},{"post_id":"cis021qsj001smeo3j8hpul5x","tag_id":"cis021qsi001pmeo3h5npjtsc","_id":"cis021qsl001umeo3e1jywulw"},{"post_id":"cis021qsm001vmeo3bzak4ghn","tag_id":"cis021qsn001xmeo38vcmmupw","_id":"cis021qso0020meo3805jr9w3"},{"post_id":"cis021qsm001vmeo3bzak4ghn","tag_id":"cis021qso001ymeo3z6r3soa2","_id":"cis021qso0021meo38276o7i7"},{"post_id":"cis021qsp0022meo3tv6bk7qh","tag_id":"cis021qsq0024meo3nu9xfnyj","_id":"cis021qsr0027meo3uk6c0n5u"},{"post_id":"cis021qsp0022meo3tv6bk7qh","tag_id":"cis021qsq0025meo3olj6kopc","_id":"cis021qsr0028meo3qmb9j2ye"}],"Tag":[{"name":"swift","_id":"cis021qrc0005meo3afd7gkm0"},{"name":"spdk","_id":"cis021qsd001dmeo3mplxtgt3"},{"name":"hadoop","_id":"cis021qsf001imeo38p0ehowv"},{"name":"java","_id":"cis021qsg001jmeo35apu442u"},{"name":"dpdk","_id":"cis021qsi001pmeo3h5npjtsc"},{"name":"cache","_id":"cis021qsn001xmeo38vcmmupw"},{"name":"computer architecture","_id":"cis021qso001ymeo3z6r3soa2"},{"name":"android","_id":"cis021qsq0024meo3nu9xfnyj"},{"name":"proguard","_id":"cis021qsq0025meo3olj6kopc"}]}}